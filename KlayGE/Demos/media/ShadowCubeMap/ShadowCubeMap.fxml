<?xml version='1.0'?>

<effect>
	<parameter type="float4x4" name="model_view_proj"/>
	<parameter type="float4x4" name="model"/>
	<parameter type="float4x4" name="obj_model_to_light_model"/>

	<shader>
		<![CDATA[
void GenShadowMapVS(float4 Position : POSITION,
						out float4 oPos : POSITION,
						out float4 oLightWorldPos : TEXCOORD0)
{
    oPos = mul(Position, model_view_proj);
    oLightWorldPos = mul(Position, obj_model_to_light_model);
}

half4 GenShadowMapPS(half4 LightWorldPos : TEXCOORD0) : COLOR
{
	LightWorldPos /= LightWorldPos.w;
	half dist = length(LightWorldPos.xyz);
	return half4(dist, dist * dist, 0, 1);
}
		]]>
	</shader>

	<technique name="GenShadowMap">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="GenShadowMapVS()"/>
			<state name="pixel_shader" value="GenShadowMapPS()"/>
		</pass>
	</technique>

	<parameter type="float3" name="light_pos"/>

	<parameter type="sampler" name="lamp_sampler"/>
	<parameter type="sampler" name="shadow_map_sampler"/>

	<shader>
		<![CDATA[
void RenderSceneVS(float4 Position : POSITION,
					float3 Normal   : NORMAL,
					out float4 oPos : POSITION,
					out float3 oDiffuse : COLOR0,
					out float4 oLightWorldPos : TEXCOORD0)
{
	float4 world_pos = mul(Position, model);
	world_pos /= world_pos.w;
	float3 world_normal = normalize(mul(Normal, (float3x3)model));

	oPos = mul(Position, model_view_proj);
	oLightWorldPos = mul(Position, obj_model_to_light_model);
    oDiffuse = dot(normalize(light_pos - world_pos.xyz), world_normal);
}

float4 RenderScenePS(half3 diffuse : COLOR0,
				float3 LightWorldPos : TEXCOORD0) : COLOR 
{
	half2 moments = texCUBE(shadow_map_sampler, LightWorldPos);
	
	half dist = length(LightWorldPos);
	half3 color = diffuse * texCUBE(lamp_sampler, LightWorldPos).rgb / (0.001f + 0.4 * moments.y);
	if (dist > moments.x + 0.1f)
	{
		// Variance shadow mapping
		half variance = moments.y - moments.x * moments.x;
		half m_d = moments.x - dist;
		half p_max = variance / (variance + m_d * m_d);

		color *= p_max;
	}

	return float4(color, 1.0);
}
		]]>
	</shader>

	<technique name="RenderScene">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="anti_clock_wise"/>
			<state name="blend_enable" value="false"/>

			<state name="vertex_shader" value="RenderSceneVS()"/>
			<state name="pixel_shader" value="RenderScenePS()"/>
		</pass>
	</technique>
</effect>
