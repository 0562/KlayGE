<?xml version='1.0'?>

<effect>
	<shader>
		<![CDATA[
float4 StoreGBuffer(float3 normal, float specular_level, float shininess)
{
	return float4(normalize(normal.xy) * sqrt(normal.z * 0.5f + 0.5f) * 0.5f + 0.5f, specular_level, shininess);
}

void StoreMRTGBuffer(float3 normal, float specular_level, float shininess, float3 diffuse,
			out float4 mrt_0, out float4 mrt_1)
{
	mrt_0 = StoreGBuffer(normal, specular_level, shininess);
	mrt_1 = float4(diffuse, 1);
}

float3 GetNormal(float4 ndc)
{
	float3 normal;
	ndc.xy = ndc.xy * 2 - 1;
	normal.z = dot(ndc.xy, ndc.xy) * 2 - 1;
	normal.xy = normalize(ndc.xy) * sqrt(1 - normal.z * normal.z);
	return normal;
}

float GetSpecular(float4 ndc)
{
	return ndc.z;
}

float GetShininess(float4 ndc)
{
	return ndc.w * 256.0f;
}


float3 NearestDepthUpsampling(float2 tc, float4 z_half, float z_full, float2 l1_inv_width_height, float threshold)
{
	float4 dist_z = abs(z_half - z_full);
	float nearest_z = dist_z.x;
	float2 nearest_tc = tc;
	if (dist_z.y < nearest_z)
	{
		nearest_z = dist_z.y;
		nearest_tc = tc + float2(l1_inv_width_height.x, 0);
	}
	if (dist_z.z < nearest_z)
	{
		nearest_z = dist_z.z;
		nearest_tc = tc + float2(0, l1_inv_width_height.y);
	}
	if (dist_z.w < nearest_z)
	{
		nearest_z = dist_z.w;
		nearest_tc = tc + l1_inv_width_height;
	}

	return float3(nearest_tc, all(dist_z < threshold) ? 1 : -1);
}
		]]>
	</shader>
</effect>
