<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>

	<parameter type="float2" name="inv_width_height"/>
	<parameter type="texture2D" name="color_tex"/>
	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
// Return the luma, the estimation of luminance from rgb inputs.
// This approximates luma using one FMA instruction,
// skipping normalization and tossing out blue.
// FxaaLuma() will range 0.0 to 2.963210702.
float FxaaLuma(float3 rgb)
{
	return dot(rgb, float3(0.299f, 0.587f, 0.114f));
}

float3 DebugFxaaPixelShader(float2 pos)
{
	float3 rgbN = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+0, -1) * inv_width_height, 0).xyz;
	float3 rgbW = color_tex.SampleLevel(linear_sampler, pos.xy + float2(-1, +0) * inv_width_height, 0).xyz;
	float3 rgbM = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+0, +0) * inv_width_height, 0).xyz;
	float3 rgbE = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+1, +0) * inv_width_height, 0).xyz;
	float3 rgbS = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+0, +1) * inv_width_height, 0).xyz;
	float lumaN = FxaaLuma(rgbN);
	float lumaW = FxaaLuma(rgbW);
	float lumaM = FxaaLuma(rgbM);
	float lumaE = FxaaLuma(rgbE);
	float lumaS = FxaaLuma(rgbS);
	float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
	float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
	float range = rangeMax - rangeMin;
	if (range < max(1 / 24.0f, rangeMax / 8))
	{
		return lumaM / (1.0 + (0.587f / 0.299f));
	}

	float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25f;
	float rangeL = abs(lumaL - lumaM);
	float blendL = saturate((rangeL / range) - 0.25f) / 0.75f;
	blendL = min(0.75f, blendL);

	float3 rgbNW = color_tex.SampleLevel(linear_sampler, pos.xy + float2(-1, -1) * inv_width_height, 0).xyz;
	float3 rgbNE = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+1, -1) * inv_width_height, 0).xyz;
	float3 rgbSW = color_tex.SampleLevel(linear_sampler, pos.xy + float2(-1, +1) * inv_width_height, 0).xyz;
	float3 rgbSE = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+1, +1) * inv_width_height, 0).xyz;
	float lumaNW = FxaaLuma(rgbNW);
	float lumaNE = FxaaLuma(rgbNE);
	float lumaSW = FxaaLuma(rgbSW);
	float lumaSE = FxaaLuma(rgbSE);
	float edgeVert = abs(lumaNW + (-2 * lumaN) + lumaNE)
		+ 2 * abs(lumaW  + (-2 * lumaM) + lumaE )
		+ abs(lumaSW + (-2 * lumaS) + lumaSE);
	float edgeHorz = abs(lumaNW + (-2 * lumaW) + lumaSW)
		+ 2 * abs(lumaN  + (-2 * lumaM) + lumaS )
		+ abs(lumaNE + (-2 * lumaE) + lumaSE);
	bool horzSpan = edgeHorz >= edgeVert;
	if (horzSpan)
	{
		return float3(1.0f, 0.75f, 0.0f);
	}
	else
	{
		return float3(0.0f, 0.50f, 1.0f);
	}
}

float3 FxaaPixelShader(float2 pos)
{
	float3 rgbN = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+0, -1) * inv_width_height, 0).xyz;
	float3 rgbW = color_tex.SampleLevel(linear_sampler, pos.xy + float2(-1, +0) * inv_width_height, 0).xyz;
	float3 rgbM = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+0, +0) * inv_width_height, 0).xyz;
	float3 rgbE = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+1, +0) * inv_width_height, 0).xyz;
	float3 rgbS = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+0, +1) * inv_width_height, 0).xyz;
	float lumaN = FxaaLuma(rgbN);
	float lumaW = FxaaLuma(rgbW);
	float lumaM = FxaaLuma(rgbM);
	float lumaE = FxaaLuma(rgbE);
	float lumaS = FxaaLuma(rgbS);
	float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
	float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
	float range = rangeMax - rangeMin;
	if (range < max(1 / 24.0f, rangeMax / 8))
	{
		return rgbM;
	}
	
	float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25f;
	float rangeL = abs(lumaL - lumaM);
	float blendL = saturate((rangeL / range) - 0.25f) / 0.75f;
	blendL = min(0.75f, blendL);

	float3 rgbNW = color_tex.SampleLevel(linear_sampler, pos.xy + float2(-1, -1) * inv_width_height, 0).xyz;
	float3 rgbNE = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+1, -1) * inv_width_height, 0).xyz;
	float3 rgbSW = color_tex.SampleLevel(linear_sampler, pos.xy + float2(-1, +1) * inv_width_height, 0).xyz;
	float3 rgbSE = color_tex.SampleLevel(linear_sampler, pos.xy + float2(+1, +1) * inv_width_height, 0).xyz;
	float lumaNW = FxaaLuma(rgbNW);
	float lumaNE = FxaaLuma(rgbNE);
	float lumaSW = FxaaLuma(rgbSW);
	float lumaSE = FxaaLuma(rgbSE);
	
	float edgeVert = abs(lumaNW + (-2 * lumaN) + lumaNE)
		+ 2 * abs(lumaW  + (-2 * lumaM) + lumaE )
		+ abs(lumaSW + (-2 * lumaS) + lumaSE);
	float edgeHorz = abs(lumaNW + (-2 * lumaW) + lumaSW)
		+ 2 * abs(lumaN  + (-2 * lumaM) + lumaS )
		+ abs(lumaNE + (-2 * lumaE) + lumaSE);
	bool horzSpan = edgeHorz >= edgeVert;
	float lengthSign = horzSpan ? -inv_width_height.y : -inv_width_height.x;
	if (!horzSpan)
	{
		lumaN = lumaW;
	}
	if (!horzSpan)
	{
		lumaS = lumaE;
	}
	float gradientN = abs(lumaN - lumaM);
	float gradientS = abs(lumaS - lumaM);
	lumaN = (lumaN + lumaM) * 0.5f;
	lumaS = (lumaS + lumaM) * 0.5f;

	bool pairN = gradientN >= gradientS;
	if (!pairN)
	{
		lumaN = lumaS;
		gradientN = gradientS;
		lengthSign *= -1;
	}
	float2 posN;
	posN.x = pos.x + (horzSpan ? 0 : lengthSign * 0.5f);
	posN.y = pos.y + (horzSpan ? lengthSign * 0.5f : 0);

	gradientN *= 0.25f;

	float2 posP = posN;
	float2 offNP = horzSpan ? float2(inv_width_height.x, 0) : float2(0, inv_width_height.y); 
	float lumaEndN;
	float lumaEndP;
	bool doneN = false;
	bool doneP = false;
	posN -= offNP * 1.5f;
	posP += offNP * 1.5f;
	for (int i = 0; i < 6; ++ i)
	{
		lumaEndN = FxaaLuma(color_tex.SampleLevel(linear_sampler, posN.xy, 0).xyz);
		lumaEndP = FxaaLuma(color_tex.SampleLevel(linear_sampler, posP.xy, 0).xyz);
		bool doneN2 = abs(lumaEndN - lumaN) >= gradientN;
		bool doneP2 = abs(lumaEndP - lumaN) >= gradientN;
		if (doneN2 && !doneN)
		{
			posN += offNP;
		}
		if (doneP2 && !doneP)
		{
			posP -= offNP;
		}
		if (doneN2 && doneP2)
		{
			break;
		}
		doneN = doneN2;
		doneP = doneP2;
		if (!doneN)
		{
			posN -= offNP * 2;
		}
		if (!doneP)
		{
			posP += offNP * 2;
		}
	}

	float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;
	float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;
	bool directionN = dstN < dstP;
	lumaEndN = directionN ? lumaEndN : lumaEndP;

	if ((lumaM - lumaN < 0) == (lumaEndN - lumaN < 0)) 
	{
		lengthSign = 0.0f;
	}

	float spanLength = (dstP + dstN);
	dstN = directionN ? dstN : dstP;
	float subPixelOffset = 0.5f + (dstN * (-1 / spanLength));
	subPixelOffset += blendL * 0.125f;
	subPixelOffset *= lengthSign;
	float3 rgbF = color_tex.SampleLevel(linear_sampler, float2(
		pos.x + (horzSpan ? 0 : subPixelOffset),
		pos.y + (horzSpan ? subPixelOffset : 0)), 0).xyz;

	float lumaF = FxaaLuma(rgbF) + 1 / (65536.0f * 256);
	float lumaB = lerp(lumaF, lumaL, blendL);
	float scale = min(4, lumaB / lumaF);
	rgbF *= scale;
	return rgbF;
}

float4 FXAAPS(float2 tc0 : TEXCOORD0) : SV_Target
{
	return float4(FxaaPixelShader(tc0), 1.0f);
}

float4 DebugFXAAPS(float2 tc0 : TEXCOORD0) : SV_Target
{
	return float4(DebugFxaaPixelShader(tc0), 1.0f);
}
		]]>
	</shader>

	<technique name="FXAA">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="FXAAPS()"/>
		</pass>
	</technique>

	<technique name="FXAAShowEdge">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="DebugFXAAPS()"/>
		</pass>
	</technique>
</effect>
