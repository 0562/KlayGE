<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="sampler" name="src_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	<parameter type="int2" name="src_tex_dim"/>
	<parameter type="int2" name="dst_tex_dim"/>

	<parameter type="float4" name="tex_coord_offset" array_size="2"/>

	<parameter type="float" name="frame_delta"/>

	<parameter type="structured_buffer" elem_type="float" name="src_buff"/>
	<parameter type="rw_structured_buffer" elem_type="float" name="out_buff"/>

	<shader>
		<![CDATA[
groupshared float shared_l[256];

[numthreads(256, 1, 1)]
void SumLum4x4LogCS(uint3 tid : SV_DispatchThreadID, uint GI : SV_GroupIndex, uint3 group_id : SV_GroupID)
{
	float2 addr;
	addr.y = tid.x / dst_tex_dim.x;
	addr.x = tid.x - addr.y * dst_tex_dim.x;
	
	float2 faddr = (addr + 0.5f) / dst_tex_dim;

	const float3 RGB_TO_LUM = float3(0.27, 0.67, 0.06);
	
	shared_l[GI] = log(dot(src_tex.SampleLevel(src_sampler, faddr, 0).rgb, RGB_TO_LUM) + 0.001f);
	for (uint step = 128; step > 16; step >>= 1)
	{
		GroupMemoryBarrierWithGroupSync();
		if (GI < step)
		{
			shared_l[GI] += shared_l[GI + step];
		}
	}
	if (GI < 16)
	{
		shared_l[GI] += shared_l[GI + 16];
	}
	if (GI < 8)
	{
		shared_l[GI] += shared_l[GI + 8];
	}
	if (GI < 4)
	{
		shared_l[GI] += shared_l[GI + 4];
	}
	if (GI < 2)
	{
		shared_l[GI] += shared_l[GI + 2];
	}
	if (GI < 1)
	{
		out_buff[group_id.x] = (shared_l[GI] + shared_l[GI + 1]) / 256;
	}
}

[numthreads(1, 1, 1)]
void AdaptedLumCS(uint3 tid : SV_DispatchThreadID, uint GI : SV_GroupIndex, uint3 group_id : SV_GroupID)
{
	float adapted_lum = out_buff[0];
	float current_lum = exp((src_buff[0] + src_buff[1] + src_buff[2] + src_buff[3]) * 0.25f);

	out_buff[0] = adapted_lum + (current_lum - adapted_lum) * (1 - pow(0.98f, 50 * frame_delta));
}
		]]>
	</shader>
	
	<technique name="SumLumLog">
		<pass name="p0">
			<state name="compute_shader" value="SumLum4x4LogCS()"/>
		</pass>
	</technique>

	<technique name="AdaptedLum">
		<pass name="p0">
			<state name="compute_shader" value="AdaptedLumCS()"/>
		</pass>
	</technique>
</effect>
