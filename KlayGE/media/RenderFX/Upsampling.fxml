<?xml version="1.0" encoding="utf-8"?>

<effect>
	<include name="PostProcess.fxml"/>
  
	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="float2" name="kernel" array_size="4">
		<value>
			<![CDATA[
				0,  0,  1, 0,  0, 1,  1, 1
			]]>
		</value>
	</parameter>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="float4" name="delta"/>
	<parameter type="int2" name="cur_lower_level"/>

	<shader>
		<![CDATA[
float4 UpsamplingPS(float2 tc : TEXCOORD0) : SV_Target
{
	float3 color0 = src_tex.SampleLevel(point_sampler, tc, cur_lower_level.y).xyz;
	float3 color1 = src_tex.SampleLevel(point_sampler, tc, cur_lower_level.x).xyz;
  
	return float4(color0 + color1, 1);
}

float4 UpsamplingInterpolatePS(float2 tc : TEXCOORD0) : SV_Target
{
	float4 finer = src_tex.SampleLevel(point_sampler, tc, cur_lower_level.y);
	float4 coarse = src_tex.SampleLevel(point_sampler, tc, cur_lower_level.x);
	if (coarse.a > 0)
	{	
		float2 coords = tc * delta.xy;
		float2 t0 = floor(coords - 0.5f) + 0.5f;	
		float4 wxy;
		wxy.xy = coords - t0;
		wxy.zw = 1 - wxy.xy;

		float weight[4];
		weight[0] = wxy.z * wxy.w;
		weight[1] = wxy.x * wxy.w;
		weight[2] = wxy.z * wxy.y;
		weight[3] = wxy.x * wxy.y;
	
		float4 total_color = 0;
		for (int i = 0; i < 4; ++ i)
		{
			float2 ntc = (t0 + kernel[i]) * delta.zw;
			float4 color = src_tex.SampleLevel(point_sampler, ntc, cur_lower_level.x);
 			total_color += float4(color.rgb, 1) * weight[i] * color.a;
		}

		finer += float4(total_color.rgb / max(total_color.a, 0.001f), 1);
	}
	
	return finer;
}
		]]>
	</shader>

	<technique name="Upsampling">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="UpsamplingInterpolatePS()"/>
		</pass>
	</technique>
</effect>
