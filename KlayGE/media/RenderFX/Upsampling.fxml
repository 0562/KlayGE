<?xml version="1.0" encoding="utf-8"?>

<effect>
	<include name="PostProcess.fxml"/>
  
	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="float3" name="kernel" array_size="9">
		<value>
			<![CDATA[
				0,  0,     1,     -1,  0,   0.5,    -1,  1, 0.25,
				0,  1,   0.5,      1,  1,  0.25,     1,  0,  0.5,
				1, -1,  0.25,      0, -1,   0.5,    -1, -1, 0.25
			]]>
		</value>
	</parameter>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="float4" name="delta"/>
	<parameter type="int2" name="cur_lower_level"/>

	<shader>
		<![CDATA[
float4 UpsamplingPS(float2 tc : TEXCOORD0) : SV_Target
{
	float3 color0 = src_tex.SampleLevel(point_sampler, tc, cur_lower_level.y).xyz;
	float3 color1 = src_tex.SampleLevel(point_sampler, tc, cur_lower_level.x).xyz;
  
	return float4(color0 + color1, 1);
}
    
float4 UpsamplingInterpolatePS(float2 tc : TEXCOORD0) : SV_Target
{
	float4 color[9];
	float weight[9];
	for (int i = 0; i < 9; ++ i)
	{
		float2 ntc0 = tc + kernel[i].xy * delta.xy;
		float2 ntc1 = tc + kernel[i].xy * delta.zw;
    
		float4 color0 = src_tex.SampleLevel(point_sampler, ntc0, cur_lower_level.y);
		float4 color1 = src_tex.SampleLevel(point_sampler, ntc1, cur_lower_level.x);
   
		color[i] = color0 + (1 - color0.a) * color1;
		weight[i] = color[i].a * kernel[i].z;
	}

	weight[2] *= color[1].a * color[3].a;
	weight[4] *= color[3].a * color[5].a;
	weight[6] *= color[5].a * color[7].a;
	weight[8] *= color[7].a * color[1].a;

	float tot_weight = weight[0] + weight[1] + weight[2] 
					+ weight[3] + weight[4] + weight[5] 
					+ weight[6] + weight[7] + weight[8] + 0.001;

	float4 tot_color = color[0] * weight[0] + color[1] * weight[1] + color[2] * weight[2]
					+ color[3] * weight[3] + color[4] * weight[4] + color[5] * weight[5]
					+ color[6] * weight[6] + color[7] * weight[7] + color[8] * weight[8];

	return color[0].a * float4(tot_color.rgb / tot_weight, 1);
}
		]]>
	</shader>

	<technique name="Upsampling">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="UpsamplingInterpolatePS()"/>
		</pass>
	</technique>
</effect>
