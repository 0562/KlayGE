<?xml version="1.0" encoding="utf-8"?>

<effect>
	<include name="PostProcess.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="Quaternion.fxml"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="trilinear_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="float4x4" name="ls_to_es"/>
	<parameter type="float" name="mip_level"/>
	<parameter type="float4" name="vpl_params"/>
	<parameter type="float4" name="light_color"/>
	<parameter type="float4" name="light_cos_out_inner"/>
	<parameter type="float3" name="light_falloff"/>
	<parameter type="float4x4" name="inv_view"/>

	<parameter type="float3" name="upper_left"/>
	<parameter type="float3" name="x_dir"/>
	<parameter type="float3" name="y_dir"/>
	<parameter type="int2" name="is_not_bottom_top_level"/>
	<parameter type="float2" name="depth_normal_threshold"/>
	<parameter type="float" name="smaller_level"/>

	<parameter type="texture2D" name="albedo_tex"/>
	<parameter type="texture2D" name="normal_es_tex"/>
	<parameter type="texture2D" name="depth_tex" />
	<parameter type="texture2D" name="depth_derivate_tex" />
	<parameter type="texture2D" name="normal_cone_tex" />
	<parameter type="texture2D" name="vpl_tex" />

	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return upper_left + x_dir * tex.x + y_dir * tex.y;
}

float4 RSM2VPLsSpot(float2 tc, float2 rsm_tc)
{
	float4 albedo_spec = albedo_tex.SampleLevel(point_sampler, rsm_tc, mip_level);
	float3 albedo = albedo_spec.xyz;
	float specular_level = albedo_spec.w;
	float4 normal_shininess = normal_es_tex.SampleLevel(point_sampler, rsm_tc, mip_level);
	float3 normal_ls = normal_shininess.xyz * 2 - 1;
	float shininess = normal_shininess.w * 256.0f;
	float3 normal_es = mul(float4(normal_ls, 0), ls_to_es).xyz;
	float depth_ls = depth_tex.Sample(point_sampler, rsm_tc).x;

	float3 view_dir = texcoord_to_view(float2(rsm_tc.x, KLAYGE_FLIPPING < 0 ? rsm_tc.y : 1 - rsm_tc.y));
	float3 pos_ls = view_dir * (depth_ls / view_dir.z);

	if (tc.y < 1 / 4.0f)
	{
		float4 light = 0;
		float spot = spot_lighting(float3(0, 0, 0), float3(0, 0, 1), light_cos_out_inner.xy, pos_ls);
		if (spot > 0)
		{
			float n_dot_l = -normal_ls.z;
			if (n_dot_l > 0)
			{
				float atten = n_dot_l * spot * attenuation_term(float3(0, 0, 0), pos_ls, light_falloff);
				light = float4(albedo, atten);
			}
		}

		return light;
	}
	else if (tc.y < 2 / 4.0f)
	{
		return float4(normal_es, specular_level);
	}
	else if (tc.y < 3 / 4.0f)
	{
		float4 pos_es = mul(float4(pos_ls, 1), ls_to_es);
		pos_es /= pos_es.w;
		return float4(pos_es.xyz, shininess);
	}
	else
	{
		return normalize(unit_axis_to_unit_axis(float3(0, 1, 0), mul(normal_es, (float3x3)inv_view)));
	}
}

float4 RSM2VPLsSpotPS(float2 tc : TEXCOORD0) : SV_Target
{
	float vpl_id = tc.x * vpl_params.x;
	float j = floor(vpl_id / vpl_params.y);
	float i = vpl_id - j * vpl_params.y;
	float2 rsm_tc = float2(i, j) * vpl_params.z + vpl_params.w;

	return RSM2VPLsSpot(tc, rsm_tc);
}

float4 RSM2VPLsSpotPSNew(float2 tc : TEXCOORD0) : SV_Target
{
	float vpl_id = tc.x * vpl_params.x - vpl_params.y;

	if ((vpl_id < 0) || (vpl_id >= vpl_params.z * vpl_params.z))
	{
		return vpl_tex.SampleLevel(point_sampler, tc, 0);
	}

	float j = floor(vpl_id / vpl_params.z);
	float i = vpl_id - j * vpl_params.z;
	float2 rsm_tc = float2(i, j) / vpl_params.z + vpl_params.w;
	float cur_level = smaller_level - 1;

	if (is_not_bottom_top_level.x)
	{
		float depth_deriv = depth_derivate_tex.SampleLevel(point_sampler, rsm_tc, cur_level).r;  
		float4 normal_cone = normal_cone_tex.SampleLevel(point_sampler, rsm_tc, cur_level);
		normal_cone.xy -= normal_cone.zw;
		float normal_deriv = max(normal_cone.x, normal_cone.y);
		if (any(float2(depth_deriv, normal_deriv) > depth_normal_threshold))
		{
			return -1;
		}
	}
	if (is_not_bottom_top_level.y)
	{
		float depth_deriv = depth_derivate_tex.SampleLevel(point_sampler, rsm_tc, smaller_level).r;
		float4 normal_cone = normal_cone_tex.SampleLevel(point_sampler, rsm_tc, smaller_level);
		normal_cone.xy -= normal_cone.zw;
		float normal_deriv = max(normal_cone.x, normal_cone.y);
		if (all(float2(depth_deriv, normal_deriv) <= depth_normal_threshold))
		{
			return -1;
		}
	}

	return RSM2VPLsSpot(tc, rsm_tc);
}
		]]>
	</shader>

	<technique name="RSM2VPLsSpot">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="RSM2VPLsSpotPS()"/>
		</pass>
	</technique>

	<technique name="RSM2VPLsSpotNew">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="RSM2VPLsSpotPSNew()"/>
		</pass>
	</technique>
</effect>
