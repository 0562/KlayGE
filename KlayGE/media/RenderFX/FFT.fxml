<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="real_tex"/>
	<parameter type="texture2D" name="imag_tex"/>
	<parameter type="texture2D" name="lookup_i_wr_wi"/>

	<parameter type="float" name="scale"/>

	<shader>
		<![CDATA[
void FFTUnit(float2 r1, float2 r2, float wr, float wi,
				out float4 oReal, out float4 oImag)
{
	float4 input_r1 = real_tex.Sample(point_sampler, r1);
	float4 input_i1 = imag_tex.Sample(point_sampler, r1);

	float4 input_r2 = real_tex.Sample(point_sampler, r2);
	float4 input_i2 = imag_tex.Sample(point_sampler, r2);

	float4 res_r = wr * input_r2 - wi * input_i2;
	float4 res_i = wi * input_r2 + wr * input_i2;

	oReal = input_r1 + res_r;
	oImag = input_i1 + res_i;
}

void FFTXPS(float2 tc : TEXCOORD0,
				out float4 oReal : SV_Target0,
				out float4 oImag : SV_Target1)
{
	float4 i_wr_wi = lookup_i_wr_wi.Sample(point_sampler, tc);
	
	float2 r1 = float2(i_wr_wi.x, tc.y);
	float2 r2 = float2(i_wr_wi.y, tc.y);

	FFTUnit(r1, r2, i_wr_wi.z, i_wr_wi.w,
		oReal, oImag);
}

void FFTYPS(float2 tc : TEXCOORD0,
				out float4 oReal : SV_Target0,
				out float4 oImag : SV_Target1)
{
	float4 i_wr_wi = lookup_i_wr_wi.Sample(point_sampler, tc);
	
	float2 r1 = float2(tc.x, i_wr_wi.x);
	float2 r2 = float2(tc.x, i_wr_wi.y);

	FFTUnit(r1, r2, i_wr_wi.z, i_wr_wi.w,
		oReal, oImag);
	
	if (scale > 0)
	{
		oReal *= scale;
		oImag *= scale;
	}
}
		]]>
	</shader>

	<technique name="FFTX">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="FFTXPS()"/>
		</pass>
	</technique>

	<technique name="FFTY">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="FFTYPS()"/>
		</pass>
	</technique>


	<macro name="COS_PI_4_16" value="0.70710678118654752440084436210485"/>
	<macro name="COHERENCY_GRANULARITY" value="128"/>
	<macro name="BLOCK_SIZE_X" value="16"/>
	<macro name="BLOCK_SIZE_Y" value="16"/>

	<parameter type="int" name="forward"/>

	<parameter type="uint2" name="width_height"/>
	<parameter type="uint4" name="addr_offset"/>

	<parameter type="rw_structured_buffer" elem_type="float2" name="output_buf"/>

	<shader type="compute_shader" version="4">
		<![CDATA[
[numthreads(BLOCK_SIZE_X, BLOCK_SIZE_Y, 1)]
void Tex2BufCS(uint3 thread_id : SV_DispatchThreadID)
{
	int out_index = thread_id.y * width_height.x + thread_id.x;
	float4 real = real_tex.Load(int3(thread_id.xy, 0));
	float4 imag = imag_tex.Load(int3(thread_id.xy, 0));
	output_buf[out_index + addr_offset.x] = float2(real.x, imag.x);
	output_buf[out_index + addr_offset.y] = float2(real.y, imag.y);
	output_buf[out_index + addr_offset.z] = float2(real.z, imag.z);
	output_buf[out_index + addr_offset.w] = float2(real.w, imag.w);	
}
		]]>
	</shader>

	<technique name="Tex2Buf">
		<pass name="p0">
			<state name="compute_shader" value="Tex2BufCS()"/>
		</pass>
	</technique>


	<parameter type="structured_buffer" elem_type="float2" name="input_buf"/>

	<shader>
		<![CDATA[
void QuadVS(float3 vPos : POSITION,
		out float2 TexCoord : TEXCOORD0,
		out float4 Position : SV_Position)
{
	Position = float4(vPos, 1);
	TexCoord.x = 0.5f + vPos.x * 0.5f;
	TexCoord.y = 0.5f - vPos.y * 0.5f;
	if (!forward)
	{
		TexCoord = 1 - TexCoord;
	}
}

void Buf2TexPS(float2 TexCoord : TEXCOORD0,
		out float4 oReal : SV_Target0,
		out float4 oImag : SV_Target1)
{
	uint index_x = (uint)(TexCoord.x * width_height.x);
	uint index_y = (uint)(TexCoord.y * width_height.y);
	uint in_index = index_y * width_height.x + index_x;
	
	float2 c0 = input_buf[in_index + addr_offset.x];
	float2 c1 = input_buf[in_index + addr_offset.y];
	float2 c2 = input_buf[in_index + addr_offset.z];
	float2 c3 = input_buf[in_index + addr_offset.w];

	oReal = float4(c0.x, c1.x, c2.x, c3.x);
	oImag = float4(c0.y, c1.y, c2.y, c3.y);
}
		]]>
	</shader>

	<technique name="Buf2Tex">
		<pass name="p0">
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="QuadVS()"/>
			<state name="pixel_shader" value="Buf2TexPS()"/>
		</pass>
	</technique>


	<cbuffer name="per_frame">
		<parameter type="uint" name="thread_count"/>
		<parameter type="uint" name="ostride"/>
		<parameter type="uint" name="istride"/>
		<parameter type="uint" name="pstride"/>
		<parameter type="float" name="phase_base"/>
	</cbuffer>

	<parameter type="structured_buffer" elem_type="float2" name="src_data"/>
	<parameter type="rw_structured_buffer" elem_type="float2" name="dst_data"/>

	<shader type="compute_shader" version="4">
		<![CDATA[
void FT2(inout float2 a, inout float2 b)
{
	float2 t = a;
	a += b;
	b = t - b;
}

void CMUL_forward(inout float2 a, float bx, float by)
{
	float t = a.x;
	a.x = t * bx - a.y * by;
	a.y = t * by + a.y * bx;
}

void UPD_forward(inout float2 a, inout float2 b)
{
	float A = a.x;
	float B = b.y;

	a.x += b.y;
	b.y = a.y + b.x;
	a.y -= b.x;
	b.x = A - B;
}

void FFT_forward_4(inout float2 D[8])
{
	FT2(D[0], D[2]);
	FT2(D[1], D[3]);
	FT2(D[0], D[1]);

	UPD_forward(D[2], D[3]);
}

void FFT_forward_8(inout float2 D[8])
{
	FT2(D[0], D[4]);
	FT2(D[1], D[5]);
	FT2(D[2], D[6]);
	FT2(D[3], D[7]);

	UPD_forward(D[4], D[6]);
	UPD_forward(D[5], D[7]);

	CMUL_forward(D[5], COS_PI_4_16, -COS_PI_4_16);
	CMUL_forward(D[7], -COS_PI_4_16, -COS_PI_4_16);

	FFT_forward_4(D);
	FT2(D[4], D[5]);
	FT2(D[6], D[7]);
}

void TWIDDLE(inout float2 d, float phase)
{
	float tx, ty;

	sincos(phase, ty, tx);
	float t = d.x;
	d.x = t * tx - d.y * ty;
	d.y = t * ty + d.y * tx;
}

void TWIDDLE_8(inout float2 D[8], float phase)
{
	TWIDDLE(D[4], 1 * phase);
	TWIDDLE(D[2], 2 * phase);
	TWIDDLE(D[6], 3 * phase);
	TWIDDLE(D[1], 4 * phase);
	TWIDDLE(D[5], 5 * phase);
	TWIDDLE(D[3], 6 * phase);
	TWIDDLE(D[7], 7 * phase);
}


[numthreads(COHERENCY_GRANULARITY, 1, 1)]
void Radix008ACS(uint3 thread_id : SV_DispatchThreadID)
{
	if (thread_id.x < thread_count)
	{
		// Fetch 8 complex numbers
		float2 D[8];

		uint imod = thread_id.x & (istride - 1);
		uint iaddr = ((thread_id.x - imod) << 3) + imod;
		for (uint i = 0; i < 8; i++)
		{
			D[i] = src_data[iaddr + i * istride];
		}

		// Math
		FFT_forward_8(D);
		uint p = thread_id.x & (istride - pstride);
		float phase = phase_base * p;
		TWIDDLE_8(D, phase);

		// Store the result
		uint omod = thread_id.x & (ostride - 1);
		uint oaddr = ((thread_id.x - omod) << 3) + omod;
		dst_data[oaddr + 0 * ostride] = D[0];
		dst_data[oaddr + 1 * ostride] = D[4];
		dst_data[oaddr + 2 * ostride] = D[2];
		dst_data[oaddr + 3 * ostride] = D[6];
		dst_data[oaddr + 4 * ostride] = D[1];
		dst_data[oaddr + 5 * ostride] = D[5];
		dst_data[oaddr + 6 * ostride] = D[3];
		dst_data[oaddr + 7 * ostride] = D[7];
	}
}

[numthreads(COHERENCY_GRANULARITY, 1, 1)]
void Radix008AFinalCS(uint3 thread_id : SV_DispatchThreadID)
{
	if (thread_id.x < thread_count)
	{
		// Fetch 8 complex numbers
		float2 D[8];
		uint iaddr = thread_id.x << 3;
		for (uint i = 0; i < 8; i++)
		{
			D[i] = src_data[iaddr + i];
		}

		// Math
		FFT_forward_8(D);
		
		if (!forward)
		{
			for (uint i = 0; i < 8; i++)
			{
				D[i] *= scale;
			}
		}

		// Store the result
		uint omod = thread_id.x & (ostride - 1);
		uint oaddr = ((thread_id.x - omod) << 3) + omod;
		dst_data[oaddr + 0 * ostride] = D[0];
		dst_data[oaddr + 1 * ostride] = D[4];
		dst_data[oaddr + 2 * ostride] = D[2];
		dst_data[oaddr + 3 * ostride] = D[6];
		dst_data[oaddr + 4 * ostride] = D[1];
		dst_data[oaddr + 5 * ostride] = D[5];
		dst_data[oaddr + 6 * ostride] = D[3];
		dst_data[oaddr + 7 * ostride] = D[7];
	}
}
		]]>
	</shader>

	<technique name="FFTRadix008A">
		<pass name="p0">
			<state name="compute_shader" value="Radix008ACS()"/>
		</pass>
	</technique>

	<technique name="FFTRadix008AFinal">
		<pass name="p0">
			<state name="compute_shader" value="Radix008AFinalCS()"/>
		</pass>
	</technique>
</effect>
