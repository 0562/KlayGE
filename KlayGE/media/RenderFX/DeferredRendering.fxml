<?xml version='1.0'?>

<effect>
	<include name="DeferredRenderingUtil.fxml"/>
	<include name="Lighting.fxml"/>

	<macro name="LT_Ambient" value="0"/>
	<macro name="LT_Point" value="1"/>
	<macro name="LT_Directional" value="2"/>
	<macro name="LT_Spot" value="3"/>

	<macro name="LSA_NoShadow" value="1"/>
	<macro name="LSA_NoDiffuse" value="2"/>
	<macro name="LSA_NoSpecular" value="4"/>
	<macro name="LSA_IndirectLighting" value="8"/>
	
	<cbuffer name="per_frame">
		<parameter type="float3" name="depth_near_far_invfar"/>
		<parameter type='int' name='flipping'/>
	</cbuffer>

	<parameter type="float" name="min_variance" value="0.3"/>
	<parameter type="float" name="bleeding_reduce" value="0.75"/>

	<cbuffer name="light_sources">
		<parameter type="float4x4" name="light_view_proj"/>
		<parameter type="float4x4" name="light_volume_mv"/>
		<parameter type="float4x4" name="light_volume_mvp"/>
		<parameter type="float4x4" name="view_to_light_model"/>
		<parameter type="float4" name="light_color"/>
		<parameter type="float4" name="light_pos_es"/>
		<parameter type="float4" name="light_dir_es"/>
		<parameter type="float3" name="light_falloff"/>
		<parameter type="int" name="light_attrib"/>
	</cbuffer>

	<parameter type="texture2D" name="shadow_map_tex"/>
	<parameter type="textureCUBE" name="shadow_map_cube_tex"/>

	<parameter type="texture2D" name="shadowing_tex"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	
	<shader>
		<![CDATA[
float linstep(float min, float max, float v)
{
	return saturate((v - min) / (max - min));
}
		]]>
	</shader>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="bilinear_wrap_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float2" name="inv_width_height"/>
	<parameter type="texture2D" name="g_buffer_tex"/>

	<shader>
		<![CDATA[
#ifdef KLAYGE_D3D11
#define NOPERSPECTIVE_SUPPORT
#define INTEGER_SUPPORT
#endif

float4 CalcColor(float n_dot_l, float spec, float atten)
{
	float2 ds = n_dot_l * atten * float2(1, spec);
#ifndef INTEGER_SUPPORT
	if (((light_attrib / LSA_NoDiffuse) % 2) != 0)
#else
	if ((light_attrib & LSA_NoDiffuse) != 0)
#endif
	{
		ds.x = 0;
	}
#ifndef INTEGER_SUPPORT
	if (((light_attrib / LSA_NoSpecular) % 2) != 0)
#else
	if ((light_attrib & LSA_NoSpecular) != 0)
#endif
	{
		ds.y = 0;
	}

	ds = max(ds, 0);
	return ds.xxxy * light_color;
}

float Calc_VSM(float2 moments, float len)
{
	float p = (len < moments.x);
	// Variance shadow mapping
	float variance = moments.y - moments.x * moments.x;
	variance = max(variance, min_variance);
	float m_d = moments.x - len;
	float p_max = variance / (variance + m_d * m_d);
	p_max = linstep(bleeding_reduce, 1, p_max);

	return max(p, p_max);
}

float VSM_Omnidirectional(float3 dir_ls, float len)
{
	float shadow = 1;
#ifndef INTEGER_SUPPORT
	if (0 == ((light_attrib / LSA_NoShadow) % 2))
#else
	if (0 == (light_attrib & LSA_NoShadow))
#endif
	{
		float2 moments = shadow_map_cube_tex.Sample(linear_sampler,
			float3(dir_ls.x, -flipping * dir_ls.y, dir_ls.z)).xy;
		shadow = Calc_VSM(moments, len);
	}
	
	return shadow;
}

float VSM_Directional(float3 pos_es, float len)
{
	float shadow = 1;
#ifndef INTEGER_SUPPORT
	if (0 == ((light_attrib / LSA_NoShadow) % 2))
#else
	if (0 == (light_attrib & LSA_NoShadow))
#endif
	{
		float4 light_proj_pos = mul(float4(pos_es, 1), light_view_proj);
		light_proj_pos /= light_proj_pos.w;
		light_proj_pos.y *= flipping;
		light_proj_pos.xy = light_proj_pos.xy / 2 + 0.5f;
	
		float2 moments = shadow_map_tex.Sample(linear_sampler, light_proj_pos.xy).xy;
		shadow = Calc_VSM(moments, len);
	}
	
	return shadow;
}

float4 NearestDepthUpsamplingShadow(float2 tc)
{
	float2 l1_inv_width_height = inv_width_height * 2;
	float2 tc0 = tc - inv_width_height;
	float z00 = GetDepth(g_buffer_tex.SampleLevel(point_sampler, tc0, 1));
	float z10 = GetDepth(g_buffer_tex.SampleLevel(point_sampler, tc0 + float2(l1_inv_width_height.x, 0), 1));
	float z01 = GetDepth(g_buffer_tex.SampleLevel(point_sampler, tc0 + float2(0, l1_inv_width_height.y), 1));
	float z11 = GetDepth(g_buffer_tex.SampleLevel(point_sampler, tc0 + l1_inv_width_height, 1));
	float z_full = GetDepth(g_buffer_tex.Sample(point_sampler, tc));
	float threshold = 0.25f * depth_near_far_invfar.z;

	float3 ndus = NearestDepthUpsampling(tc0, float4(z00, z10, z01, z11), z_full, l1_inv_width_height, threshold);
	if (ndus.z > 0)
	{
		return shadowing_tex.Sample(linear_sampler, tc);
	}
	else
	{
		return shadowing_tex.Sample(point_sampler, ndus.xy);
	}
}

void DeferredRenderingDepthOnlyVS(float4 pos : POSITION,
				out float4 oPos : SV_Position)
{
	oPos = mul(float4(pos.xyz, 1), light_volume_mvp);
}

float4 DeferredRenderingDepthOnlyPS() : SV_Target
{
	return 0;
}

void DeferredRenderingVS(float4 pos : POSITION,
#ifdef NOPERSPECTIVE_SUPPORT
				out noperspective float2 oTc : TEXCOORD0,
				out float3 oViewDir : TEXCOORD1,
#else
				out float2 oTc : TEXCOORD0,
				out float3 oViewDir : TEXCOORD1,
				out float oW : TEXCOORD2,
#endif
				out float4 oPos : SV_Position)
{
	oPos = mul(pos, light_volume_mvp);

	oViewDir = mul(pos, light_volume_mv).xyz;
	oTc = oPos.xy / oPos.w * 0.5f;
	oTc.y *= flipping;
	oTc += 0.5f;

#ifndef NOPERSPECTIVE_SUPPORT
	oW = oPos.w;
	oTc *= oW;
#endif
}

float4 DeferredRenderingPointPS(
#ifdef NOPERSPECTIVE_SUPPORT
	noperspective float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1
#else
	float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1, float w : TEXCOORD2
#endif
	) : SV_Target
{
#ifndef NOPERSPECTIVE_SUPPORT
	tc /= w;
#endif

	float4 ndc = g_buffer_tex.Sample(point_sampler, tc);
	float4 final_clr = 0;

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * ((GetDepth(ndc) * depth_near_far_invfar.y) / view_dir.z);
	float3 dir = normalize(light_pos_es.xyz - pos_es);
	float3 normal = GetNormal(ndc);
	float n_dot_l = dot(normal, dir);
	if (n_dot_l > 0)
	{
		float spec = roughness_term(GetSpecular(ndc) * 0.01f, dir, normalize(dir - view_dir), normal, GetShininess(ndc)).x;
		float shadow = NearestDepthUpsamplingShadow(tc).r;
		float atten = shadow * attenuation_term(light_pos_es.xyz, pos_es.xyz, light_falloff);
		final_clr = CalcColor(n_dot_l, spec, atten);
	}

	return final_clr;
}

float4 DeferredRenderingSpotPS(
#ifdef NOPERSPECTIVE_SUPPORT
	noperspective float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1
#else
	float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1, float w : TEXCOORD2
#endif
	) : SV_Target
{
#ifndef NOPERSPECTIVE_SUPPORT
	tc /= w;
#endif

	float4 ndc = g_buffer_tex.Sample(point_sampler, tc);
	float4 final_clr = 0;
	
	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * ((GetDepth(ndc) * depth_near_far_invfar.y) / view_dir.z);
	float spot = spot_lighting(light_pos_es.xyz, light_dir_es.xyz,
				float2(light_pos_es.w, light_dir_es.w), pos_es.xyz);
	if (spot > 0)
	{
		float3 dir = normalize(light_pos_es.xyz - pos_es);
		float3 normal = GetNormal(ndc);
		float n_dot_l = dot(normal, dir);
		if (n_dot_l > 0)
		{
			float spec = roughness_term(GetSpecular(ndc) * 0.01f, dir, normalize(dir - view_dir), normal, GetShininess(ndc)).x;
			float shadow = NearestDepthUpsamplingShadow(tc).r;
			float atten = spot * shadow * attenuation_term(light_pos_es.xyz, pos_es.xyz, light_falloff);
			final_clr = CalcColor(n_dot_l, spec, atten);
		}
	}

	return final_clr;
}

float4 DeferredRenderingDirectionalPS(
#ifdef NOPERSPECTIVE_SUPPORT
	noperspective float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1
#else
	float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1, float w : TEXCOORD2
#endif
	) : SV_Target
{
#ifndef NOPERSPECTIVE_SUPPORT
	tc /= w;
#endif
	
	float4 ndc = g_buffer_tex.Sample(point_sampler, tc);
	float4 final_clr = 0;
	
	view_dir = normalize(view_dir);

	float3 dir = light_dir_es.xyz;
	float3 normal = GetNormal(ndc);
	float n_dot_l = dot(normal, dir);
	if (n_dot_l > 0)
	{
		float spec = roughness_term(GetSpecular(ndc) * 0.01f, dir, normalize(dir - view_dir), normal, GetShininess(ndc)).x;
		final_clr = CalcColor(n_dot_l, spec, 1);
	}

	return final_clr;
}

float4 DeferredRenderingAmbientPS(
#ifdef NOPERSPECTIVE_SUPPORT
	noperspective float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1
#else
	float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1, float w : TEXCOORD2
#endif
	) : SV_Target
{
	return CalcColor(0.1f, 0, 1);
}

float4 DeferredShadowingPointPS(
#ifdef NOPERSPECTIVE_SUPPORT
	noperspective float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1
#else
	float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1, float w : TEXCOORD2
#endif
	) : SV_Target
{
#ifndef NOPERSPECTIVE_SUPPORT
	tc /= w;
#endif

	float4 ndc = g_buffer_tex.SampleLevel(point_sampler, tc - inv_width_height * 0.5f, 0);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * ((GetDepth(ndc) * depth_near_far_invfar.y) / view_dir.z);
	float3 dir = light_pos_es.xyz - pos_es;
	float len = length(dir);
	float3 dir_ls = mul(-dir, (float3x3)view_to_light_model);
	return VSM_Omnidirectional(dir_ls, len);
}

float4 DeferredShadowingSpotPS(
#ifdef NOPERSPECTIVE_SUPPORT
	noperspective float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1
#else
	float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1, float w : TEXCOORD2
#endif
	) : SV_Target
{
#ifndef NOPERSPECTIVE_SUPPORT
	tc /= w;
#endif

	float4 ndc = g_buffer_tex.SampleLevel(point_sampler, tc - inv_width_height * 0.5f, 0);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * ((GetDepth(ndc) * depth_near_far_invfar.y) / view_dir.z);
	float len = length(light_pos_es.xyz - pos_es);
	return VSM_Directional(pos_es, len);
}

float4 DeferredShadowingDirectionalPS() : SV_Target
{
	return 1;
}

float4 DeferredShadowingAmbientPS() : SV_Target
{
	return 1;
}
		]]>
	</shader>

	<technique name="DeferredRenderingLightDepthOnly">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="color_write_mask" value="0"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="DeferredRenderingDepthOnlyVS()"/>
			<state name="pixel_shader" value="DeferredRenderingDepthOnlyPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingLightStencil">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="less"/>
			<state name="depth_write_mask" value="false"/>

			<state name="color_write_mask" value="0"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="none"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="equal"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_depth_fail" value="decr_wrap"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="equal"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_depth_fail" value="incr_wrap"/>

			<state name="vertex_shader" value="DeferredRenderingDepthOnlyVS()"/>
			<state name="pixel_shader" value="DeferredRenderingDepthOnlyPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingPoint">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="less"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="front_stencil_read_mask" value="127"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="less"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_pass" value="keep"/>
			<state name="back_stencil_read_mask" value="127"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredRenderingPointPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingSpot">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="less"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="front_stencil_read_mask" value="127"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="less"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_pass" value="keep"/>
			<state name="back_stencil_read_mask" value="127"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredRenderingSpotPS()"/>
		</pass>
	</technique>
				
	<technique name="DeferredRenderingDirectional">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="equal"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="front_stencil_read_mask" value="127"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="equal"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_pass" value="keep"/>
			<state name="back_stencil_read_mask" value="127"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredRenderingDirectionalPS()"/>
		</pass>
	</technique>
			
	<technique name="DeferredRenderingAmbient">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="equal"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="front_stencil_read_mask" value="127"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="equal"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_pass" value="keep"/>
			<state name="back_stencil_read_mask" value="127"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredRenderingAmbientPS()"/>
		</pass>
	</technique>

	<technique name="DeferredShadowingPoint">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredShadowingPointPS()"/>
		</pass>
	</technique>

	<technique name="DeferredShadowingSpot">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredShadowingSpotPS()"/>
		</pass>
	</technique>

	<technique name="DeferredShadowingDirectional">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredShadowingDirectionalPS()"/>
		</pass>
	</technique>

	<technique name="DeferredShadowingAmbient">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredShadowingAmbientPS()"/>
		</pass>
	</technique>


	<shader>
		<![CDATA[
void ClearStencilVS(float4 pos : POSITION,
				out float4 oPos : SV_Position)
{
	oPos = float4(pos.xyz, 1);
}

float4 ClearStencilPS() : SV_Target
{
	return 1;
}
		]]>
	</shader>

	<technique name="ClearStencil">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
			
			<state name="color_write_mask" value="0"/>

			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="greater"/>
			<state name="front_stencil_ref" value="128"/>
			<state name="front_stencil_pass" value="replace"/>
			<state name="front_stencil_write_mask" value="127"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="greater"/>
			<state name="back_stencil_ref" value="128"/>
			<state name="back_stencil_pass" value="replace"/>
			<state name="back_stencil_write_mask" value="127"/>

			<state name="vertex_shader" value="ClearStencilVS()"/>
			<state name="pixel_shader" value="ClearStencilPS()"/>
		</pass>
	</technique>

	<parameter type="texture2D" name="lighting_tex"/>
	<parameter type="texture2D" name="g_buffer_1_tex"/>
	<parameter type="texture2D" name="ssvo_tex"/>
	<parameter type="int" name="ssvo_enabled"/>

	<shader>
		<![CDATA[
void ShadingVS(float4 pos : POSITION,
			out float2 oTexCoord : TEXCOORD0,
			out float4 oPos : SV_Position)
{
	oPos = pos;

	oTexCoord = pos.xy / 2;
	oTexCoord.y *= flipping;
	oTexCoord += 0.5f;
}

float4 ShadingPS(float2 tc : TEXCOORD0) : SV_Target
{
	float ssvo = 1;
	if (ssvo_enabled)
	{
		ssvo = ssvo_tex.Sample(point_sampler, tc).x;
	}
	
	float4 lighting = lighting_tex.Sample(point_sampler, tc);
	float4 diffuse = g_buffer_1_tex.Sample(point_sampler, tc);
	float3 diff_lighting = lighting.rgb;
	float3 spec_lighting = lighting.a / (dot(lighting.rgb, float3(0.2126f, 0.7152f, 0.0722f)) + 1e-6f) * lighting.rgb;
	return float4(max((diff_lighting * diffuse.rgb + specular_normalize_factor(diffuse.a * 256) * spec_lighting) * ssvo, 0), 1);
}
		]]>
	</shader>

	<technique name="Shading">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShadingVS()"/>
			<state name="pixel_shader" value="ShadingPS()"/>
		</pass>
	</technique>
</effect>
