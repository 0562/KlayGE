<?xml version='1.0'?>

<effect>
	<parameter type="texture2DArray" name="juda_tex_cache"/>
	<parameter type="texture2D" name="juda_tex_cache_0"/>
	<parameter type="texture2D" name="juda_tex_cache_1"/>
	<parameter type="texture2D" name="juda_tex_cache_2"/>
	<parameter type="texture2D" name="juda_tex_cache_3"/>
	<parameter type="texture2D" name="juda_tex_cache_4"/>
	<parameter type="texture2D" name="juda_tex_cache_5"/>
	<parameter type="texture2D" name="juda_tex_cache_6"/>
	<parameter type="texture2D" name="juda_tex_cache_7"/>
	<parameter type="texture2D" name="juda_tex_cache_8"/>
	<parameter type="texture2D" name="juda_tex_cache_9"/>
	<parameter type="texture2D" name="juda_tex_cache_10"/>
	<parameter type="texture2D" name="juda_tex_cache_11"/>
	<parameter type="texture2D" name="juda_tex_cache_12"/>
	<parameter type="texture2D" name="juda_tex_cache_13"/>
	<parameter type="texture2D" name="juda_tex_cache_14"/>
	<parameter type="texture2D" name="juda_tex_cache_15"/>

	<parameter type="texture2D" name="juda_tex_indirect"/>

	<parameter type="float3" name="tile_size"/>
	<parameter type="float2" name="inv_juda_tex_cache_size"/>
	<parameter type="float2" name="inv_juda_tex_indirect_size"/>

	<parameter type="sampler" name="jdt_point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	<parameter type="sampler" name="jdt_aniso_sampler">
		<state name="filtering" value="anisotropic"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
		<state name="max_anisotropy" value="4"/>
	</parameter>

	<shader>
		<![CDATA[
void calc_wrap(out int2 real_tile_xy, out float2 in_tile_coord, int4 tile_bb, float2 texcoord)
{
	texcoord = frac(texcoord);
	float2 part_coord = texcoord * tile_bb.zw;
	real_tile_xy = tile_bb.xy + int2(part_coord);
	in_tile_coord = frac(part_coord);
}

void calc_clamp(out int2 real_tile_xy, out float2 in_tile_coord, int4 tile_bb, float2 texcoord)
{
	texcoord = saturate(texcoord);
	float2 part_coord = texcoord * tile_bb.zw;
	real_tile_xy = tile_bb.xy + int2(part_coord);
	in_tile_coord = frac(part_coord);
}

void calc_mirror(out int2 real_tile_xy, out float2 in_tile_coord, int4 tile_bb, float2 texcoord)
{
	float2 selection_coord = floor(texcoord);
	texcoord = (fmod(selection_coord, 2)) ? 1 + selection_coord - texcoord : texcoord - selection_coord;
	texcoord = saturate(texcoord);
	float2 part_coord = texcoord * tile_bb.zw;
	real_tile_xy = tile_bb.xy + int2(part_coord);
	in_tile_coord = frac(part_coord);
}


void decode_tile_id(out int2 tile_xy, float4 tile_id)
{
	tile_id.xyz *= 255;
	tile_xy.y = floor(tile_id.y / 16);
	tile_xy.x = (tile_id.y - tile_xy.y * 16) * 256 + tile_id.x;
	tile_xy.y += tile_id.z * 16;
}

float4 judatex2d(int2 tile_xy, float2 in_tile_coord)
{
	float3 cache_addr = juda_tex_indirect.Sample(jdt_point_sampler, float2(tile_xy) * inv_juda_tex_indirect_size).rgb * 255;
	cache_addr.xy = cache_addr.xy * tile_size.y + tile_size.z;
	float2 tc = float2((cache_addr.xy + in_tile_coord * tile_size.x) * inv_juda_tex_cache_size);
#if KLAYGE_MAX_TEX_ARRAY_LEN > 1
	return juda_tex_cache.Sample(jdt_aniso_sampler, float3(tc, cache_addr.z));
#else
	int index = cache_addr.z;
	float4 ret;
	switch (index)
	{
	case 0:
		ret = juda_tex_cache_0.Sample(jdt_aniso_sampler, tc);
		break;

	case 1:
		ret = juda_tex_cache_1.Sample(jdt_aniso_sampler, tc);
		break;

	case 2:
		ret = juda_tex_cache_2.Sample(jdt_aniso_sampler, tc);
		break;

	case 3:
		ret = juda_tex_cache_3.Sample(jdt_aniso_sampler, tc);
		break;

	case 4:
		ret = juda_tex_cache_4.Sample(jdt_aniso_sampler, tc);
		break;

	case 5:
		ret = juda_tex_cache_5.Sample(jdt_aniso_sampler, tc);
		break;

	case 6:
		ret = juda_tex_cache_6.Sample(jdt_aniso_sampler, tc);
		break;

	case 7:
		ret = juda_tex_cache_7.Sample(jdt_aniso_sampler, tc);
		break;

	case 8:
		ret = juda_tex_cache_8.Sample(jdt_aniso_sampler, tc);
		break;

	case 9:
		ret = juda_tex_cache_9.Sample(jdt_aniso_sampler, tc);
		break;

	case 10:
		ret = juda_tex_cache_10.Sample(jdt_aniso_sampler, tc);
		break;

	case 11:
		ret = juda_tex_cache_11.Sample(jdt_aniso_sampler, tc);
		break;

	case 12:
		ret = juda_tex_cache_12.Sample(jdt_aniso_sampler, tc);
		break;

	case 13:
		ret = juda_tex_cache_13.Sample(jdt_aniso_sampler, tc);
		break;

	case 14:
		ret = juda_tex_cache_14.Sample(jdt_aniso_sampler, tc);
		break;

	default:
		ret = juda_tex_cache_15.Sample(jdt_aniso_sampler, tc);
		break;
	}
	return ret;
#endif
}


float4 judatex2d_clamp(int4 tile_bb, float2 texcoord)
{
	int2 tile_xy;
	float2 in_tile_coord;
	calc_clamp(tile_xy, in_tile_coord, tile_bb, texcoord);
	return judatex2d(tile_xy, in_tile_coord);
}

float4 judatex2d_wrap(int4 tile_bb, float2 texcoord)
{
	int2 tile_xy;
	float2 in_tile_coord;
	calc_wrap(tile_xy, in_tile_coord, tile_bb, texcoord);
	return judatex2d(tile_xy, in_tile_coord);
}

float4 judatex2d_mirror(int4 tile_bb, float2 texcoord)
{
	int2 tile_xy;
	float2 in_tile_coord;
	calc_mirror(tile_xy, in_tile_coord, tile_bb, texcoord);
	return judatex2d(tile_xy, in_tile_coord);
}
		]]>
	</shader>
</effect>
