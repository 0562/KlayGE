<?xml version='1.0'?>

<effect>
	<shader>
		<![CDATA[
float2 get_xy_channel(float4 v)
{
#ifdef KLAYGE_BC5_AS_AG
	return v.ag;
#else
#ifdef KLAYGE_BC5_AS_GA
	return v.ga;
#else
#ifdef KLAYGE_BC5_AS_GR
	return v.gr;
#else
	return v.rg;
#endif
#endif
#endif
}

float3 restore_normal(float2 normal_xy)
{
	float3 normal;
	normal.xy = normal_xy;
	normal.z = sqrt(max(0.0f, 1 - dot(normal.xy, normal.xy)));
	return normalize(normal);
}

float3 decompress_normal(float4 comp_normal)
{
	return restore_normal(get_xy_channel(comp_normal) * 2 - 1);
}

float4 decode_hdr_yc(float y, float4 c)
{
	float Y = exp2(y * 65536 / 2048 - 16);
	float2 C = get_xy_channel(c);
	C *= C;
	
	return float4(Y * float3(C.g, (1 - C.g - C.r), C.r) / float3(0.2126f, 0.7152f, 0.0722f), 1);
}

float mipmap_level(float2 uv, float2 texture_size)
{
#ifdef KLAYGE_OPENGLES2
	float2 dx = ddx(uv * texture_size.x);
	float2 dy = ddy(uv * texture_size.y);
	float d = max(dot(dx, dx), dot(dy, dy));

	return log2(sqrt(d));
#else
	return 0;
#endif
}

float non_linear_depth_to_linear(float depth, float near_mul_q, float q)
{
	return near_mul_q / (q - depth);
}

float linear_depth_to_non_linear(float depth, float near_mul_q, float q)
{
	return (depth * q - near_mul_q) / depth;
}
		]]>
	</shader>
</effect>
