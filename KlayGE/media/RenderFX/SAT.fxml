<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>

	<parameter type="float3" name="addr_offset"/>
	<parameter type="int" name="length"/>
	<parameter type="float" name="scale"/>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="texture2D" name="child_tex"/>

	<parameter type="sampler" name="tex_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>

	<shader>
		<![CDATA[
float4 SATScanXUpSweepPS(float2 tex_coord0 : TEXCOORD0) : SV_Target
{
	float tar_x = tex_coord0.x * scale;
	return src_tex.SampleLevel(tex_sampler, float2(tar_x - addr_offset.y, tex_coord0.y), 0)
				+ src_tex.SampleLevel(tex_sampler, float2(tar_x - addr_offset.x, tex_coord0.y), 0)
				+ src_tex.SampleLevel(tex_sampler, float2(tar_x + addr_offset.x, tex_coord0.y), 0)
				+ src_tex.SampleLevel(tex_sampler, float2(tar_x + addr_offset.y, tex_coord0.y), 0);
}

float4 SATScanXDownSweepPS(float2 tex_coord0 : TEXCOORD0) : SV_Target
{
	float4 clr;
	float x = floor(tex_coord0.x * length);
	int r = fmod(x, 4);
	if (3 == r)
	{
		clr = src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x * scale, tex_coord0.y), 0);
	}
	else
	{
		clr = child_tex.SampleLevel(tex_sampler, tex_coord0, 0);
		if (x > 3)
		{
			clr += src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x * scale - addr_offset.x, tex_coord0.y), 0);
		}
		if (r >= 1)
		{
			clr += child_tex.SampleLevel(tex_sampler, tex_coord0 - float2(addr_offset.y, 0), 0);
		}
		if (r >= 2)
		{
			clr += child_tex.SampleLevel(tex_sampler, tex_coord0 - float2(addr_offset.z, 0), 0);
		}
	}
	return clr;
}

float4 SATScanYUpSweepPS(float2 tex_coord0 : TEXCOORD0) : SV_Target
{
	float tar_y = tex_coord0.y * scale;
	return src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x, tar_y - addr_offset.y), 0)
				+ src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x, tar_y - addr_offset.x), 0)
				+ src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x, tar_y + addr_offset.x), 0)
				+ src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x, tar_y + addr_offset.y), 0);
}

float4 SATScanYDownSweepPS(float2 tex_coord0 : TEXCOORD0) : SV_Target
{
	float4 clr;
	float y = floor(tex_coord0.y * length);
	int r = fmod(y, 4);
	if (3 == r)
	{
		clr = src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x, tex_coord0.y * scale), 0);
	}
	else
	{
		clr = child_tex.SampleLevel(tex_sampler, tex_coord0, 0);
		if (y > 3)
		{
			clr += src_tex.SampleLevel(tex_sampler, float2(tex_coord0.x, tex_coord0.y * scale - addr_offset.x), 0);
		}
		if (r >= 1)
		{
			clr += child_tex.SampleLevel(tex_sampler, tex_coord0 - float2(0, addr_offset.y), 0);
		}
		if (r >= 2)
		{
			clr += child_tex.SampleLevel(tex_sampler, tex_coord0 - float2(0, addr_offset.z), 0);
		}
	}
	return clr;
}
		]]>
	</shader>
	<technique name="SATScanXUpSweep">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="0"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="SATScanXUpSweepPS()"/>
		</pass>
	</technique>
	<technique name="SATScanXDownSweep">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="0"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="SATScanXDownSweepPS()"/>
		</pass>
	</technique>	

	<technique name="SATScanYUpSweep">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="0"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="SATScanYUpSweepPS()"/>
		</pass>
	</technique>

	<technique name="SATScanYDownSweep">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="0"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="SATScanYDownSweepPS()"/>
		</pass>
	</technique>

	<macro name="BLOCK_SIZE" value="128"/>
	<parameter type="rw_texture2D" elem_type="float4" name="out_tex"/>
	<parameter type="rw_texture2D" elem_type="float4" name="out_sum_tex"/>
	<parameter type="texture2D" name="in_tex"/>
	<parameter type="texture2D" name="in_sum_tex"/>

	<shader type="compute_shader" version="5">
		<![CDATA[
groupshared float4 shared_forscan[BLOCK_SIZE];

float4 InclusiveScanWarp(uint GI)
{
	uint lane = GI & 31;
	[unroll]
	for (uint i = 1; i < 32; i *= 2)
	{
		if (lane >= i)
		{
			shared_forscan[GI] += shared_forscan[GI - i];
		}
	}
	return shared_forscan[GI];
}

float4 ExclusiveScanWarp(uint GI)
{
	InclusiveScanWarp(GI);
	uint lane = GI & 31;
	return (lane > 0) ? shared_forscan[GI - 1] : 0;
}

float4 InclusiveScanBlock(uint GI, float4 input)
{
	uint lane = GI & 31;
	uint warp_id = GI >> 5;
	
	shared_forscan[GI] = input;

	float4 val = InclusiveScanWarp(GI);
	GroupMemoryBarrierWithGroupSync();
	
	if (31 == lane)
	{
		shared_forscan[warp_id] = shared_forscan[GI];
	}
	GroupMemoryBarrierWithGroupSync();

	if (0 == warp_id)
	{
		ExclusiveScanWarp(GI);
	}
	GroupMemoryBarrierWithGroupSync();
	
	if (warp_id > 0)
	{
		val += shared_forscan[warp_id - 1];
	}
	
	return val;
}

[numthreads(BLOCK_SIZE, 1, 1)]
void InclusiveScanXCS(uint3 gid : SV_GroupID, 
				uint3 dtid : SV_DispatchThreadID, 
				uint GI : SV_GroupIndex)
{
	float4 val = InclusiveScanBlock(GI, in_tex[dtid.xy]);
	out_tex[dtid.xy] = val;
	if (BLOCK_SIZE - 1 == GI)
	{
		out_sum_tex[gid.xy] = val;
	}
}

[numthreads(1, BLOCK_SIZE, 1)]
void InclusiveScanYCS(uint3 gid : SV_GroupID, 
				uint3 dtid : SV_DispatchThreadID, 
				uint GI : SV_GroupIndex)
{
	float4 val = InclusiveScanBlock(GI, in_tex[dtid.xy]);
	out_tex[dtid.xy] = val;
	if (BLOCK_SIZE - 1 == GI)
	{
		out_sum_tex[gid.xy] = val;
	}
}


[numthreads(BLOCK_SIZE, 1, 1)]
void InclusiveAddSumXCS(uint3 gid : SV_GroupID, 
				uint3 dtid : SV_DispatchThreadID, 
				uint GI : SV_GroupIndex)
{
	if (0 == GI)
	{
		shared_forscan[0] = in_sum_tex[int2(gid.x - 1, gid.y)];
	}
	GroupMemoryBarrierWithGroupSync();
	
	out_tex[dtid.xy] = in_tex[dtid.xy] + shared_forscan[0];
}

[numthreads(1, BLOCK_SIZE, 1)]
void InclusiveAddSumYCS(uint3 gid : SV_GroupID, 
				uint3 dtid : SV_DispatchThreadID, 
				uint GI : SV_GroupIndex)
{
	if (0 == GI)
	{
		shared_forscan[0] = in_sum_tex[int2(gid.x, gid.y - 1)];
	}
	GroupMemoryBarrierWithGroupSync();
	
	out_tex[dtid.xy] = in_tex[dtid.xy] + shared_forscan[0];
}
		]]>
	</shader>

	<technique name="SATScanXCS">
		<pass name="p0">
			<state name="compute_shader" value="InclusiveScanXCS()"/>
		</pass>
	</technique>
	<technique name="SATScanYCS">
		<pass name="p0">
			<state name="compute_shader" value="InclusiveScanYCS()"/>
		</pass>
	</technique>
	
	<technique name="SATAddSumXCS">
		<pass name="p0">
			<state name="compute_shader" value="InclusiveAddSumXCS()"/>
		</pass>
	</technique>
	<technique name="SATAddSumYCS">
		<pass name="p0">
			<state name="compute_shader" value="InclusiveAddSumYCS()"/>
		</pass>
	</technique>
</effect>
