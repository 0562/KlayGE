<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>
	<include name="DeferredRenderingUtil.fxml"/>
	<include name="BilateralBlur.fxml"/>
	
	<cbuffer name="never_changes">
		<parameter type="float2" name="sphere_xy" array_size="2">
			<value>
				<![CDATA[
					0.66667, 0,
					0, 0.33333
				]]>
			</value>
		</parameter>
	</cbuffer>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="proj"/>
		<parameter type="float4x4" name="inv_proj"/>
	</cbuffer>

	<cbuffer name="vo_params">
		<parameter type="float" name="vo_intensity" value="2.14"/>
	</cbuffer>
	<parameter type="sampler" name="bilinear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="g_buffer_tex"/>
	<parameter type="texture2D" name="depth_tex"/>

	<shader>
		<![CDATA[
float CalcObscurance(float2 tc, float3 pos_es, float3 x_dir, float3 y_dir, float3 normal, float radius)
{
	float sqr_radius = radius * radius;
	float obscurance = 0;
	float total_weight = 0;
	for (int i = 0; i < 2; ++ i)
	{
		float2 sxy = sphere_xy[i];
		for (int j = 0; j < 2; ++ j)
		{
			float3 sample_point_offset = (sxy.x * x_dir + sxy.y * y_dir) * radius;
			float3 sample_point = pos_es + sample_point_offset;
			float4 sample_point_ss = mul(float4(sample_point, 1), proj);
		
			float2 tc_sample = TexCoordFromPos(sample_point_ss / sample_point_ss.w);
			float depth_sample = depth_tex.Sample(bilinear_sampler, tc_sample).r;

			float3 view_dir_sample = normalize(sample_point);
			float v = dot(pos_es, view_dir_sample);
			float disc = sqr_radius - (dot(pos_es, pos_es) - v * v);
			float intersect_t = v - sqrt(disc);

			float zs;
			if (depth_sample <= intersect_t * view_dir_sample.z)
			{
				float3 pos_es_sample = view_dir_sample * intersect_t;
				zs = dot(pos_es_sample - pos_es, normal);
				obscurance += zs;
			}
			else
			{
				float3 pos_es_sample = view_dir_sample * (depth_sample / view_dir_sample.z);
				float3 pos_sphere_sample = mul(float3x3(x_dir, y_dir, normal), pos_es_sample - pos_es);
				zs = sqrt(sqr_radius - dot(pos_sphere_sample.xy, pos_sphere_sample.xy));
				obscurance += clamp(pos_sphere_sample.z, 0, zs);
			}
			total_weight += zs;

			sxy = -sxy;
		}
	}

	return (total_weight > 1e-6f) ? obscurance / total_weight : 0;
}

float CalcAlchemyObscurance(float2 tc, float3 pos_es, float3 x_dir, float3 y_dir, float3 normal, float radius){
	float sqr_radius = radius * radius;
	float obscurance = 0;
	float total_weight = 0;
	for (int i = 0; i < 2; ++ i)
	{
		float2 sxy = sphere_xy[i];
		for (int j = 0; j < 2; ++ j)
		{
			float3 sample_point_offset = (sxy.x * x_dir + sxy.y * y_dir) * radius;
			float3 sample_point = pos_es + sample_point_offset;
			float4 sample_point_ss = mul(float4(sample_point, 1), proj);
		
			float2 tc_sample = TexCoordFromPos(sample_point_ss / sample_point_ss.w);
			float depth_sample = depth_tex.Sample(bilinear_sampler, tc_sample).r;

			float3 view_dir_sample = normalize(sample_point);
			float3 pos_es_sample = view_dir_sample * (depth_sample / view_dir_sample.z);
			float3 dir_es_sample = pos_es_sample - pos_es;

			float epsilon = 0.0001f;
			float beta = 0.002f;
			float r_sqr = 1.0f;
	
			float dist_sqr = dot( dir_es_sample, dir_es_sample );
			if( dist_sqr < r_sqr ){
				obscurance += max( 0.0f, dot(dir_es_sample, normal) - depth_sample * beta ) / ( dist_sqr + epsilon );
				total_weight += 1.0f;
			}
			
			sxy = -sxy;
		}
	}

	float delta = 1.0f;
	return (total_weight > 1e-6f) ? 2.0f * delta * obscurance / total_weight : 0;
}

void SSVOVS(float4 pos : POSITION,
					out float2 oTex : TEXCOORD0,
					out float3 oViewDir : TEXCOORD1,
					out float4 oPos : SV_Position)
{
	oTex = TexCoordFromPos(pos);
	oPos = pos;
	oViewDir = mul(pos, inv_proj).xyz;
}

float4 SSVOPS(float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float radius = 0.5f;
	float obscurance = 1;
	
	float depth = depth_tex.Sample(point_sampler, tc).r;
	float3 normal = GetNormal(g_buffer_tex.Sample(point_sampler, tc));
	
	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth / view_dir.z);

	float3 y_dir = cross(normal, float3(0, 0, 1));
	float3 x_dir = cross(y_dir, normal);

	// obscurance = CalcObscurance(tc, pos_es, x_dir, y_dir, normal, radius);
	// return float4(1 - saturate(vo_intensity * obscurance), depth, 0, 0);
	
	obscurance = CalcAlchemyObscurance(tc, pos_es, x_dir, y_dir, normal, radius);
	return float4( max(0.0, 1.0 - obscurance), depth, 0, 0 );
}
		]]>
	</shader>

	<technique name="SSVO">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="SSVOVS()"/>
			<state name="pixel_shader" value="SSVOPS()"/>
		</pass>
	</technique>

	<technique name="SSVOBlurX">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="0"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="BlurXPS()"/>
		</pass>
	</technique>

	<technique name="SSVOBlurY">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="0"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="dst_color"/>
			<state name="dest_blend" value="zero"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="dst_alpha"/>
			<state name="dest_blend_alpha" value="zero"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="BlurYPS()"/>
		</pass>
	</technique>
</effect>
