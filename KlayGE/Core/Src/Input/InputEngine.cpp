// InputEngine.cpp
// KlayGE 输入引擎类 实现文件
// Ver 2.5.0
// 版权所有(C) 龚敏敏, 2003-2005
// Homepage: http://klayge.sourceforge.net
//
// 2.5.0
// 增加了Action map id (2005.4.3)
//
// 2.1.3
// 用算法代替手写循环 (2004.10.16)
//
// 2.0.0
// 初次建立 (2003.8.29)
//
// 修改记录
/////////////////////////////////////////////////////////////////////////////////

#include <KlayGE/KlayGE.hpp>
#include <KlayGE/MapVector.hpp>

#include <vector>

#include <boost/assert.hpp>
#include <boost/bind.hpp>

#include <KlayGE/Input.hpp>

namespace KlayGE
{
	// 析构函数
	//////////////////////////////////////////////////////////////////////////////////
	InputEngine::~InputEngine()
	{
		this->UnacquireDevices();
	}

	// 设置动作格式
	//////////////////////////////////////////////////////////////////////////////////
	uint32_t InputEngine::ActionMap(InputActionMap const & actionMap, bool reenumerate)
	{
		uint32_t id = 0;

		// 保存新的动作格式
		if (!actionMaps_.empty())
		{
			id = actionMaps_.rbegin()->first + 1;
		}
		actionMaps_[id] = actionMap;

		// 只有当调用时指定要重枚举才销毁并重枚举设备
		// 设备列表有可能在循环中使用，如果这时枚举设备有可能造成问题
		if (reenumerate)
		{
			// 清除以前枚举的设备
			devices_.clear();

			// 重新枚举合适的设备
			this->EnumDevices();
		}
		else // 应用新的动作映射
		{
			// 在新的动作映射设置前设备必须全部被释放
			this->UnacquireDevices();
		}

		// 对当前设备应用新的动作映射
		std::for_each(devices_.begin(), devices_.end(),
			boost::bind(&InputDevice::ActionMap, _1, actionMaps_));

		return id;
	}

	// 获取输入设备个数
	//////////////////////////////////////////////////////////////////////////////////
	size_t InputEngine::NumDevice() const
	{
		return devices_.size();
	}

	// 刷新输入状态
	//////////////////////////////////////////////////////////////////////////////////
	InputActionsType InputEngine::Update(uint32_t id)
	{
		typedef MapVector<uint16_t, long> ActionSetType;
		ActionSetType actions;

		// 访问所有设备
		for (InputDevicesType::iterator iter = devices_.begin(); iter != devices_.end(); ++ iter)
		{
			InputActionsType const theAction((*iter)->Update(id));

			// 去掉重复的动作
			for (InputActionsType::const_iterator i = theAction.begin(); i != theAction.end(); ++ i)
			{
				if (actions.find(i->first) == actions.end())
				{
					actions.insert(*i);
				}
			}
		}

		// 添加到动作列表
		return InputActionsType(actions.begin(), actions.end());
	}

	// 释放所有设备
	//////////////////////////////////////////////////////////////////////////////////
	void InputEngine::UnacquireDevices()
	{
		std::for_each(devices_.begin(), devices_.end(),
			boost::bind(&InputDevice::Unacquire, _1));
	}

	// 获取设备接口
	//////////////////////////////////////////////////////////////////////////////////
	InputDevicePtr InputEngine::Device(size_t index) const
	{
		BOOST_ASSERT(index < this->NumDevice());

		return devices_[index];
	}
}
