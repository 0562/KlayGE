<?xml version='1.0'?>

<effect>
	<parameter type="texture2D" name="perm_tex">
		<annotation type="string" name="SasResourceAddress" value="noise_perm.dds"/>
	</parameter>
	<parameter type="texture2D" name="perm_2d_tex">
		<annotation type="string" name="SasResourceAddress" value="noise_perm_2d.dds"/>
	</parameter>
	<parameter type="texture2D" name="grad3_perm_tex">
		<annotation type="string" name="SasResourceAddress" value="noise_grad3_perm.dds"/>
	</parameter>
	<parameter type="texture2D" name="grad4_perm_tex">
		<annotation type="string" name="SasResourceAddress" value="noise_grad4_perm.dds"/>
	</parameter>

	<parameter type="sampler" name="perlin_point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
// From "Implementing Improved Perlin Noise" in GPU Gems 2, Chapter 26

void setup(float i, out float b, out float r)
{
	float x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = x - floor(x);
}

void setup(float2 i, out float2 b, out float2 r)
{
	float2 x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = x - floor(x);
}

void setup(float3 i, out float3 b, out float3 r)
{
	float3 x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = x - floor(x);
}

void setup(float4 i, out float4 b, out float4 r)
{
	float4 x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = x - floor(x);
}

float fade(float t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float2 fade(float2 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float3 fade(float3 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float4 fade(float4 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float perm(float x)
{
	return perm_tex.SampleLevel(perlin_point_sampler, float2((x + 0.01f) / 256, 0.5f), 0).r * 256;
}

float4 perm2d(float2 xy)
{
	return perm_2d_tex.SampleLevel(perlin_point_sampler, (xy + 0.01f) / 256, 0) * 256;
}

float grad_perm(float x, float3 p)
{
	return dot(grad3_perm_tex.SampleLevel(perlin_point_sampler, float2((x + 0.01f) / 256, 0.5f), 0).xyz * 2 - 1, p);
}

float grad_perm(float x, float4 p)
{
	return dot(grad4_perm_tex.SampleLevel(perlin_point_sampler, float2((x + 0.01f) / 256, 0.5f), 0) * 2 - 1, p);
}

float grad_perm(float x, float2 p)
{
	return grad_perm(x, float3(p, 0));
}

float grad_perm(float x, float p)
{
	return grad_perm(x, float2(p, 0));
}

float perlin_noise(float p)
{
	float b;
	float r;
	setup(p, b, r);
	float f = fade(r);

	float4 AA = perm2d(float2(b, 0));

	return lerp(grad_perm(AA.x, r),
					grad_perm(AA.z, r - 1), f);
}

float perlin_noise(float2 p)
{
	float2 b;
	float2 r;
	setup(p, b, r);
	float2 f = fade(r);

	float4 AA = perm2d(b);

	return lerp(lerp(grad_perm(AA.x, r),
						grad_perm(AA.z, r + float2(-1, 0)), f.x),
					lerp(grad_perm(AA.y, r + float2(0, -1)),
						grad_perm(AA.w, r +  + float2(-1, -1)), f.x), f.y);
}
			
float perlin_noise(float3 p)
{
	float3 b;
	float3 r;
	setup(p, b, r);
	float3 f = fade(r);

	float4 AA = perm2d(b.xy) + b.z;

	return lerp(lerp(lerp(grad_perm(AA.x, r),
						grad_perm(AA.z, r + float3(-1, 0, 0)), f.x),
					lerp(grad_perm(AA.y, r + float3(0, -1, 0)),
						grad_perm(AA.w, r + float3(-1, -1, 0)), f.x), f.y),
				lerp(lerp(grad_perm(AA.x + 1, r + float3(0, 0, -1)),
						grad_perm(AA.z + 1, r + float3(-1, 0, -1)), f.x),
					lerp(grad_perm(AA.y + 1, r + float3(0, -1, -1)),
						grad_perm(AA.w + 1, r + float3(-1, -1, -1)), f.x), f.y), f.z);
}

float perlin_noise(float4 p)
{
	float4 b;
	float4 r;
	setup(p, b, r);
	float4 f = fade(r);
	
	float4 AA = perm2d(b.xy) + b.z;

	float AAA = perm(AA.x) + b.w;
    float ABA = perm(AA.y) + b.w;
    float BAA = perm(AA.z) + b.w;
    float BBA = perm(AA.w) + b.w;
	float AAB = perm(AA.x + 1) + b.w;
	float ABB = perm(AA.y + 1) + b.w;
	float BAB = perm(AA.z + 1) + b.w;
	float BBB = perm(AA.w + 1) + b.w;

	return lerp(lerp(lerp(lerp(grad_perm(AAA, r),  
							grad_perm(BAA, r + float4(-1, 0, 0, 0)), f.x),
						lerp(grad_perm(ABA, r + float4(0, -1, 0, 0)),
							grad_perm(BBA, r + float4(-1, -1, 0, 0)), f.x), f.y),
					lerp(lerp(grad_perm(AAB, r + float4(0, 0, -1, 0)),
							grad_perm(BAB, r + float4(-1, 0, -1, 0)), f.x),
						lerp(grad_perm(ABB, r + float4(0, -1, -1, 0)),
							grad_perm(BBB, r + float4(-1, -1, -1, 0)), f.x), f.y), f.z),
  					lerp(lerp(lerp(grad_perm(AAA + 1, r + float4(0, 0, 0, -1)),
							grad_perm(BAA + 1, r + float4(-1, 0, 0, -1)), f.x),
						lerp(grad_perm(ABA + 1, r + float4(0, -1, 0, -1)),
							grad_perm(BBA + 1, r + float4(-1, -1, 0, -1)), f.x), f.y),
					lerp(lerp(grad_perm(AAB + 1, r + float4(0, 0, -1, -1)),
							grad_perm(BAB + 1, r + float4(-1, 0, -1, -1)), f.x),
						lerp(grad_perm(ABB + 1, r + float4(0, -1, -1, -1)),
							grad_perm(BBB + 1, r + float4(-1, -1, -1, -1)), f.x), f.y), f.z), f.w);
}

// calculate gradient of noise (expensive!)
float3 perlin_noise_gradient(float3 p, float d)
{
	float f0 = perlin_noise(p);
	float fx = perlin_noise(p + float3(d, 0, 0));
	float fy = perlin_noise(p + float3(0, d, 0));
	float fz = perlin_noise(p + float3(0, 0, d));
	return float3(fx - f0, fy - f0, fz - f0) / d;
}

// fractal sum
float fBm(float2 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float sum = 0;	
	float freq = 1, amp = 0.5f;
	for (int i = 0; i < octaves; ++ i)
	{
		sum += perlin_noise(p * freq) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float fBm(float3 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float sum = 0;	
	float freq = 1, amp = 0.5f;
	for (int i = 0; i < octaves; ++ i)
	{
		sum += perlin_noise(p * freq) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float fBm(float4 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float sum = 0;	
	float freq = 1, amp = 0.5f;
	for (int i = 0; i < octaves; ++ i)
	{
		sum += perlin_noise(p * freq) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float turbulence(float2 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float sum = 0;
	float freq = 1, amp = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		sum += abs(perlin_noise(p * freq)) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float turbulence(float3 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float sum = 0;
	float freq = 1, amp = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		sum += abs(perlin_noise(p * freq)) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float turbulence(float4 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float sum = 0;
	float freq = 1, amp = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		sum += abs(perlin_noise(p * freq)) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

// Ridged multifractal
// See "Texturing & Modeling, A Procedural Approach", Chapter 12
float ridge(float h, float offset)
{
    h = abs(h);
    h = offset - h;
    h = h * h;
    return h;
}

float ridgedmf(float2 p, int octaves, float lacunarity = 2.0, float gain = 0.5, float offset = 1.0)
{
	float sum = 0;
	float freq = 1, amp = 0.5f;
	float prev = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		float n = ridge(perlin_noise(p * freq), offset);
		sum += n * amp * prev;
		prev = n;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float ridgedmf(float3 p, int octaves, float lacunarity = 2.0, float gain = 0.5, float offset = 1.0)
{
	float sum = 0;
	float freq = 1, amp = 0.5f;
	float prev = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		float n = ridge(perlin_noise(p * freq), offset);
		sum += n * amp * prev;
		prev = n;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float ridgedmf(float4 p, int octaves, float lacunarity = 2.0, float gain = 0.5, float offset = 1.0)
{
	float sum = 0;
	float freq = 1, amp = 0.5f;
	float prev = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		float n = ridge(perlin_noise(p * freq), offset);
		sum += n * amp * prev;
		prev = n;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}
		]]>
	</shader>
</effect>
