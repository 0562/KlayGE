<?xml version='1.0'?>

<effect>
	<parameter type="texture2D" name="perm_2d_tex"/>
	<parameter type="texture2D" name="grad_perm_tex"/>

	<parameter type="sampler" name="perlin_point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
// From "Implementing Improved Perlin Noise" in GPU Gems 2, Chapter 26

void setup(float i, out float b, out float r)
{
	float x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = frac(x);
}

void setup(float2 i, out float2 b, out float2 r)
{
	float2 x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = frac(x);
}

void setup(float3 i, out float3 b, out float3 r)
{
	float3 x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = frac(x);
}

float fade(float t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float2 fade(float2 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float3 fade(float3 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float4 perm2d(float2 xy)
{
	return perm_2d_tex.Sample(perlin_point_sampler, xy / 256.0) * 256;
}

float grad_perm(float x, float3 p)
{
	return dot(grad_perm_tex.Sample(perlin_point_sampler, x / 256.0).xyz, p);
}

float grad_perm(float x, float2 p)
{
	return grad_perm(x, float3(p, 0));
}

float grad_perm(float x, float p)
{
	return grad_perm(x, float2(p, 0));
}

float perlin_noise(float p)
{
	float b;
	float r;
	setup(p, b, r);
	float f = fade(r);

	float4 AA = perm2d(float2(b, 0));

	return lerp(grad_perm(AA.x, r),
					grad_perm(AA.z, r - 1), f);
}

float perlin_noise(float2 p)
{
	float2 b;
	float2 r;
	setup(p, b, r);
	float2 f = fade(r);

	float4 AA = perm2d(b.xy);

	return lerp(lerp(grad_perm(AA.x, r),
						grad_perm(AA.z, r + float2(-1, 0)), f.x),
					lerp(grad_perm(AA.y, r + float2(0, -1)),
						grad_perm(AA.w, r +  + float2(-1, -1)), f.x), f.y);
}
			
float perlin_noise(float3 p)
{
	float3 b;
	float3 r;
	setup(p, b, r);
	float3 f = fade(r);

	float4 AA = perm2d(b.xy) + b.z;

	return lerp(lerp(lerp(grad_perm(AA.x, r),
						grad_perm(AA.z, r + float3(-1, 0, 0)), f.x),
					lerp(grad_perm(AA.y, r + float3(0, -1, 0)),
						grad_perm(AA.w, r + float3(-1, -1, 0)), f.x), f.y),
				lerp(lerp(grad_perm(AA.x + 1, r + float3(0, 0, -1)),
						grad_perm(AA.z + 1, r + float3(-1, 0, -1)), f.x),
					lerp(grad_perm(AA.y + 1, r + float3(0, -1, -1)),
						grad_perm(AA.w + 1, r + float3(-1, -1, -1)), f.x), f.y), f.z);
}

// calculate gradient of noise (expensive!)
float3 perlin_noise_gradient(float3 p, float d)
{
	float f0 = perlin_noise(p);
	float fx = perlin_noise(p + float3(d, 0, 0));	
	float fy = perlin_noise(p + float3(0, d, 0));
	float fz = perlin_noise(p + float3(0, 0, d));
	return float3(fx - f0, fy - f0, fz - f0) / d;
}

// fractal sum
float fBm(float3 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float freq = 1, amp = 0.5f;
	float sum = 0;	
	for (int i = 0; i < octaves; ++ i)
	{
		sum += perlin_noise(p * freq) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

float turbulence(float3 p, int octaves, float lacunarity = 2.0, float gain = 0.5)
{
	float sum = 0;
	float freq = 1, amp = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		sum += abs(perlin_noise(p * freq)) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

// Ridged multifractal
// See "Texturing & Modeling, A Procedural Approach", Chapter 12
float ridge(float h, float offset)
{
    h = abs(h);
    h = offset - h;
    h = h * h;
    return h;
}

float ridgedmf(float3 p, int octaves, float lacunarity = 2.0, float gain = 0.5, float offset = 1.0)
{
	float sum = 0;
	float freq = 1, amp = 0.5f;
	float prev = 1;
	for (int i = 0; i < octaves; ++ i)
	{
		float n = ridge(perlin_noise(p * freq), offset);
		sum += n * amp * prev;
		prev = n;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}
		]]>
	</shader>
</effect>
