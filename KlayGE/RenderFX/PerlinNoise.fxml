<?xml version='1.0'?>

<effect>
	<parameter type="texture2D" name="perm_2d_tex"/>
	<parameter type="texture2D" name="grad_perm_tex"/>

	<parameter type="sampler" name="perlin_point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
void setup(float i, out float b, out float r)
{
	float x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = frac(x);
}

void setup(float2 i, out float2 b, out float2 r)
{
	float2 x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = frac(x);
}

void setup(float3 i, out float3 b, out float3 r)
{
	float3 x = i + 0x1000;
	b = fmod(floor(x), 256);
	r = frac(x);
}

float fade(float t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float2 fade(float2 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float3 fade(float3 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}

float4 perm2d(float2 xy)
{
	return perm_2d_tex.Sample(perlin_point_sampler, xy / 256.0) * 256;
}

float grad_perm(float x, float3 p)
{
	return dot(grad_perm_tex.Sample(perlin_point_sampler, x / 256.0).xyz, p);
}

float grad_perm(float x, float2 p)
{
	return grad_perm(x, float3(p, 0));
}

float grad_perm(float x, float p)
{
	return grad_perm(x, float2(p, 0));
}

float perlin_noise(float p)
{
	float b;
	float r;
	setup(p, b, r);
	float f = fade(r);

	float4 AA = perm2d(float2(b, 0));

	return lerp(grad_perm(AA.x, r),
					grad_perm(AA.z, r - 1), f);
}

float perlin_noise(float2 p)
{
	float2 b;
	float2 r;
	setup(p, b, r);
	float2 f = fade(r);

	float4 AA = perm2d(b.xy);

	return lerp(lerp(grad_perm(AA.x, r),
						grad_perm(AA.z, r + float2(-1, 0)), f.x),
					lerp(grad_perm(AA.y, r + float2(0, -1)),
						grad_perm(AA.w, r +  + float2(-1, -1)), f.x), f.y);
}
			
float perlin_noise(float3 p)
{
	float3 b;
	float3 r;
	setup(p, b, r);
	float3 f = fade(r);

	float4 AA = perm2d(b.xy) + b.z;

	return lerp(lerp(lerp(grad_perm(AA.x, r),
						grad_perm(AA.z, r + float3(-1, 0, 0)), f.x),
					lerp(grad_perm(AA.y, r + float3(0, -1, 0)),
						grad_perm(AA.w, r + float3(-1, -1, 0)), f.x), f.y),
				lerp(lerp(grad_perm(AA.x + 1, r + float3(0, 0, -1)),
						grad_perm(AA.z + 1, r + float3(-1, 0, -1)), f.x),
					lerp(grad_perm(AA.y + 1, r + float3(0, -1, -1)),
						grad_perm(AA.w + 1, r + float3(-1, -1, -1)), f.x), f.y), f.z);
}

float turbulence(int octaves, float3 p, float lacunarity, float gain)
{	
	float sum = 0;
	float scale = 1;
	float total_gain = 1;
	for(int i = 0; i < octaves; ++ i)
	{
		sum += total_gain * perlin_noise(p * scale);
		scale *= lacunarity;
		total_gain *= gain;
	}
	return abs(sum);
}
		]]>
	</shader>
</effect>
