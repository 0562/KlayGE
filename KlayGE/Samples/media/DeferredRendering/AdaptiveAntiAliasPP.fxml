<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>
	<include name="DeferredRenderingUtil.fxml"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="bilinear_clamp_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="texture2D" name="color_tex"/>
	<parameter type="float2" name="inv_width_height"/>

	<shader>
		<![CDATA[
float GetEdgeWeight(float2 tc0, float4 tc1, float4 tc2, float4 tc3, float4 tc4)
{
	float4 nd[9];
	// Retrieve normal and depth data for all neighbors.
	nd[0] = src_tex.Sample(point_sampler, tc0);
	nd[1] = src_tex.Sample(point_sampler, tc1.xy);
	nd[2] = src_tex.Sample(point_sampler, tc1.zw);
	nd[3] = src_tex.Sample(point_sampler, tc2.xy);
	nd[4] = src_tex.Sample(point_sampler, tc2.zw);
	nd[5] = src_tex.Sample(point_sampler, tc3.xy);
	nd[6] = src_tex.Sample(point_sampler, tc3.zw);
	nd[7] = src_tex.Sample(point_sampler, tc4.xy);
	nd[8] = src_tex.Sample(point_sampler, tc4.zw);

	// Compute Deltas in Depth.
	float4 Deltas1;
	float4 Deltas2;
	float depth0 = GetDepth(nd[0]);
	Deltas1.x = GetDepth(nd[1]);
	Deltas1.y = GetDepth(nd[2]);
	Deltas1.z = GetDepth(nd[3]);
	Deltas1.w = GetDepth(nd[4]);
	Deltas2.x = GetDepth(nd[5]);
	Deltas2.y = GetDepth(nd[6]);
	Deltas2.z = GetDepth(nd[7]);
	Deltas2.w = GetDepth(nd[8]);
	// Compute andbsolute gradients from center.
	Deltas1 = abs(Deltas1 - depth0);
	Deltas2 = abs(depth0 - Deltas2);
	// Find min and max gradient, ensuring min != 0
	float4 maxDeltas = max(Deltas1, Deltas2);
	float4 minDeltas = max(min(Deltas1, Deltas2), 0.00001);
	// Compare change in gradients, flagging ones that change
	// significantly.
	// How severe the change must be to get flagged is a function of the
	// minimum gradient. It is not resolution dependent. The constant
	// number here would change based on how the depth values are stored
	// and how sensitive the edge detection should be.
	float4 depthResults = step(minDeltas * 18.0, maxDeltas);
	// Compute change in the cosine of the angle between normals.
	float3 normal0 = GetNormal(nd[0]);
	Deltas1.x = dot(GetNormal(nd[1]), normal0);
	Deltas1.y = dot(GetNormal(nd[2]), normal0);
	Deltas1.z = dot(GetNormal(nd[3]), normal0);
	Deltas1.w = dot(GetNormal(nd[4]), normal0);
	Deltas2.x = dot(GetNormal(nd[5]), normal0);
	Deltas2.y = dot(GetNormal(nd[6]), normal0);
	Deltas2.z = dot(GetNormal(nd[7]), normal0);
	Deltas2.w = dot(GetNormal(nd[8]), normal0);
	Deltas1 = abs(Deltas1 - Deltas2);
	// Compare change in the cosine of the angles, flagging changes
	// above some constant threshold. The cosine of the angle is not a
	// linear function of the angle, so to have the flagging be
	// independent of the angles involved, an arccos function would be
	// required.
	float4 normalResults = step(0.4, Deltas1);
	normalResults = max(normalResults, depthResults);
	return dot(normalResults, 0.25);
}

void AdaptiveAntiAliasVS(float4 pos : POSITION,
				out float2 oTc0 : TEXCOORD0, // center
				out float4 oTc1 : TEXCOORD1, // left top / top
				out float4 oTc2 : TEXCOORD2, // right top / right
				out float4 oTc3 : TEXCOORD3, // right bottom / bottom
				out float4 oTc4 : TEXCOORD4, // left bottom / left
				out float4 oPos : SV_Position)
{
	PostProcessVS(pos, oTc0, oPos);

	oTc1 = oTc0.xyxy + inv_width_height.xyxy * float4(-1, -1, +0, -1);
	oTc2 = oTc0.xyxy + inv_width_height.xyxy * float4(+1, -1, +1, +0);
	oTc3 = oTc0.xyxy + inv_width_height.xyxy * float4(+1, +1, +0, +1);
	oTc4 = oTc0.xyxy + inv_width_height.xyxy * float4(-1, +1, -1, +0);
}

float4 AdaptiveAntiAliasPS(float2 tc0 : TEXCOORD0,
				float4 tc1 : TEXCOORD1,
				float4 tc2 : TEXCOORD2,
				float4 tc3 : TEXCOORD3,
				float4 tc4 : TEXCOORD4) : SV_Target
{
	float2 offset = GetEdgeWeight(tc0, tc1, tc2, tc3, tc4) * inv_width_height;
	return (color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(-offset.x, -offset.y))
			+ color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(+offset.x, -offset.y))
			+ color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(-offset.x, +offset.y))
			+ color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(+offset.x, +offset.y))) * 0.25f;
}

float4 ShowEdgePS(float2 tc0 : TEXCOORD0,
				float4 tc1 : TEXCOORD1,
				float4 tc2 : TEXCOORD2,
				float4 tc3 : TEXCOORD3,
				float4 tc4 : TEXCOORD4) : SV_Target
{
	return GetEdgeWeight(tc0, tc1, tc2, tc3, tc4);
}
		]]>
	</shader>
	
	<technique name="AdaptiveAntiAlias">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="AdaptiveAntiAliasVS()"/>
			<state name="pixel_shader" value="AdaptiveAntiAliasPS()"/>
		</pass>
	</technique>

	<technique name="AdaptiveAntiAliasShowEdge">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="AdaptiveAntiAliasVS()"/>
			<state name="pixel_shader" value="ShowEdgePS()"/>
		</pass>
	</technique>
	
	
	<macro name="BLOCK_SIZE_X" value="16"/>
	<macro name="BLOCK_SIZE_Y" value="16"/>
	<macro name="BLOCK_SIZE" value="(BLOCK_SIZE_X * BLOCK_SIZE_Y)"/>
	<macro name="TILE_SIZE_X" value="(BLOCK_SIZE_X + 2)"/>
	<macro name="TILE_SIZE_Y" value="(BLOCK_SIZE_Y + 2)"/>
	<macro name="TILE_SIZE" value="(TILE_SIZE_X * TILE_SIZE_Y)"/>

	<parameter type="rw_texture2D" elem_type="float4" name="out_tex"/>
	
	<shader type="compute_shader" version="5">
		<![CDATA[
groupshared float4 shared_block[TILE_SIZE];

float GetEdgeWeightCS(uint GI : SV_GroupIndex, uint2 group_id : SV_GroupID, uint2 gtid : SV_GroupThreadID)
{
	int2 base_addr = int2(group_id.x * BLOCK_SIZE_X, group_id.y * BLOCK_SIZE_Y) - 1;
	for (uint s = 0; s < (TILE_SIZE + BLOCK_SIZE - 1) / BLOCK_SIZE; ++ s)
	{
		uint offset = GI + BLOCK_SIZE * s;
		if (offset < TILE_SIZE)
		{
			uint y = offset / TILE_SIZE_X;
			uint x = offset - y * TILE_SIZE_X;
			float4 texel = src_tex[base_addr + int2(x, y)];
			shared_block[offset] = float4(GetNormal(texel), GetDepth(texel));
		}
	}
	GroupMemoryBarrierWithGroupSync();
	
	// Compute Deltas in Depth.
	float4 Deltas1;
	float4 Deltas2;
	float depth0 = shared_block[(gtid.y + 1) * TILE_SIZE_X + (gtid.x + 1)].w;
	Deltas1.x = shared_block[(gtid.y + 0) * TILE_SIZE_X + (gtid.x + 0)].w;
	Deltas1.y = shared_block[(gtid.y + 0) * TILE_SIZE_X + (gtid.x + 1)].w;
	Deltas1.z = shared_block[(gtid.y + 0) * TILE_SIZE_X + (gtid.x + 2)].w;
	Deltas1.w = shared_block[(gtid.y + 1) * TILE_SIZE_X + (gtid.x + 2)].w;
	Deltas2.x = shared_block[(gtid.y + 2) * TILE_SIZE_X + (gtid.x + 2)].w;
	Deltas2.y = shared_block[(gtid.y + 2) * TILE_SIZE_X + (gtid.x + 1)].w;
	Deltas2.z = shared_block[(gtid.y + 2) * TILE_SIZE_X + (gtid.x + 0)].w;
	Deltas2.w = shared_block[(gtid.y + 1) * TILE_SIZE_X + (gtid.x + 0)].w;
	// Compute andbsolute gradients from center.
	Deltas1 = abs(Deltas1 - depth0);
	Deltas2 = abs(depth0 - Deltas2);
	// Find min and max gradient, ensuring min != 0
	float4 maxDeltas = max(Deltas1, Deltas2);
	float4 minDeltas = max(min(Deltas1, Deltas2), 0.00001);
	// Compare change in gradients, flagging ones that change
	// significantly.
	// How severe the change must be to get flagged is a function of the
	// minimum gradient. It is not resolution dependent. The constant
	// number here would change based on how the depth values are stored
	// and how sensitive the edge detection should be.
	float4 depthResults = step(minDeltas * 18.0, maxDeltas);
	// Compute change in the cosine of the angle between normals.
	float3 normal0 = shared_block[(gtid.y + 1) * TILE_SIZE_X + (gtid.x + 1)].xyz;
	Deltas1.x = dot(shared_block[(gtid.y + 0) * TILE_SIZE_X + (gtid.x + 0)].xyz, normal0);
	Deltas1.y = dot(shared_block[(gtid.y + 0) * TILE_SIZE_X + (gtid.x + 1)].xyz, normal0);
	Deltas1.z = dot(shared_block[(gtid.y + 0) * TILE_SIZE_X + (gtid.x + 2)].xyz, normal0);
	Deltas1.w = dot(shared_block[(gtid.y + 1) * TILE_SIZE_X + (gtid.x + 2)].xyz, normal0);
	Deltas2.x = dot(shared_block[(gtid.y + 2) * TILE_SIZE_X + (gtid.x + 2)].xyz, normal0);
	Deltas2.y = dot(shared_block[(gtid.y + 2) * TILE_SIZE_X + (gtid.x + 1)].xyz, normal0);
	Deltas2.z = dot(shared_block[(gtid.y + 2) * TILE_SIZE_X + (gtid.x + 0)].xyz, normal0);
	Deltas2.w = dot(shared_block[(gtid.y + 1) * TILE_SIZE_X + (gtid.x + 0)].xyz, normal0);
	Deltas1 = abs(Deltas1 - Deltas2);
	// Compare change in the cosine of the angles, flagging changes
	// above some constant threshold. The cosine of the angle is not a
	// linear function of the angle, so to have the flagging be
	// independent of the angles involved, an arccos function would be
	// required.
	float4 normalResults = step(0.4, Deltas1);
	normalResults = max(normalResults, depthResults);
	return dot(normalResults, 0.25);
}

[numthreads(BLOCK_SIZE_X, BLOCK_SIZE_Y, 1)]
void AdaptiveAntiAliasCS(uint3 tid : SV_DispatchThreadID, uint GI : SV_GroupIndex, uint3 group_id : SV_GroupID, uint3 gtid : SV_GroupThreadID)
{
	float2 tc0 = (tid.xy + 0.5f) * inv_width_height;
	float2 offset = GetEdgeWeightCS(GI, group_id.xy, gtid.xy) * inv_width_height;
	out_tex[tid.xy] = (color_tex.SampleLevel(bilinear_clamp_sampler, tc0 + float2(-offset.x, -offset.y), 0)
			+ color_tex.SampleLevel(bilinear_clamp_sampler, tc0 + float2(+offset.x, -offset.y), 0)
			+ color_tex.SampleLevel(bilinear_clamp_sampler, tc0 + float2(-offset.x, +offset.y), 0)
			+ color_tex.SampleLevel(bilinear_clamp_sampler, tc0 + float2(+offset.x, +offset.y), 0)) * 0.25f;
}
		]]>
	</shader>

	<technique name="AdaptiveAntiAliasCS">
		<pass name="p0">
			<state name="compute_shader" value="AdaptiveAntiAliasCS()"/>
		</pass>
	</technique>
</effect>
