<?xml version='1.0'?>

<effect>
	<include name="../../../RenderFX/Lighting.fxml"/>
	<include name="../../../RenderFX/PerlinNoise.fxml"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="mvp" semantic="WORLDVIEWPROJECTION"/>
		<parameter type="float3" name="light_pos"/>
		<parameter type="float3" name="eye_pos"/>
	</cbuffer>

	<parameter type="float" name="freq"/>

	<shader>
		<![CDATA[
float4 wood(float3 tex_coord)
{
	float3 color1 = float3(0.66f, 0.33f, 0.13f);
	float3 color2 = float3(0.93f, 0.60f, 0.13f);

	float g = perlin_noise(tex_coord * 0.72f) * 16;
	float s = frac(g);

	return float4(lerp(color1, color2, s), 1);
}

float4 marble(float3 tex_coord)
{
	float3 color1 = float3(0.1f, 0.1f, 0.1f);
	float3 color2 = float3(0.8f, 0.8f, 0.8f);
	return float4(lerp(color1, color2, cos(tex_coord.x * 0.1f + 6 * turbulence(5, tex_coord, 2, 0.6f))), 1);
}

float4 cloud(float3 tex_coord)
{
	float3 color1 = float3(0.1f, 0.1f, 0.99f);
	float3 color2 = float3(0.8f, 0.8f, 0.8f);

	return float4(lerp(color1, color2, cos(tex_coord.z * 0.5f + 2 * turbulence(6, tex_coord, 2, 0.5f)) * 0.9f), 1);
}

void ProceduralTexVS(float4 pos			: POSITION,
					float3 normal		: NORMAL,
					out float4 oPos		: SV_Position,
					out float3 oPosOS	: TEXCOORD0,
					out float3 oNormalOS : TEXCOORD1,
					out float3 oTexCoord : TEXCOORD2)
{
	oPos = mul(pos, mvp);
	oPosOS = pos;
	oNormalOS = normal;
	oTexCoord = pos.xyz * freq;
}

float4 WoodPS(float4 pos_ss	: SV_Position,
					float3 pos_os : TEXCOORD0,
					float3 normal_os : TEXCOORD1,
					float3 tex_coord : TEXCOORD2) : SV_Target
{
	float3 light_os = light_pos - pos_os;
	float3 view_os = eye_pos - pos_os;
	float3 halfway_os = light_pos + view_os;
	
	light_os = normalize(light_os);
	view_os = normalize(view_os);
	halfway_os = normalize(halfway_os);
	
	return wood(tex_coord) * diffuse_term(light_os, normal_os) * 0.7f
		+ specular_term(halfway_os, normal_os, 32) * 0.6f;
}

float4 MarblePS(float4 pos_ss	: SV_Position,
					float3 pos_os : TEXCOORD0,
					float3 normal_os : TEXCOORD1,
					float3 tex_coord : TEXCOORD2) : SV_Target
{
	float3 light_os = light_pos - pos_os;
	float3 view_os = eye_pos - pos_os;
	float3 halfway_os = light_pos + view_os;
	
	light_os = normalize(light_os);
	view_os = normalize(view_os);
	halfway_os = normalize(halfway_os);
	
	return marble(tex_coord) * diffuse_term(light_os, normal_os) * 0.7f
		+ specular_term(halfway_os, normal_os, 32) * 0.6f;
}

float4 CloudPS(float4 pos_ss	: SV_Position,
					float3 pos_os : TEXCOORD0,
					float3 normal_os : TEXCOORD1,
					float3 tex_coord : TEXCOORD2) : SV_Target
{
	float3 light_os = light_pos - pos_os;
	float3 view_os = eye_pos - pos_os;
	float3 halfway_os = light_pos + view_os;
	
	light_os = normalize(light_os);
	view_os = normalize(view_os);
	halfway_os = normalize(halfway_os);
	
	return cloud(tex_coord) * diffuse_term(light_os, normal_os);
}
		]]>
	</shader>

	<technique name="ProceduralWoodTex">
		<pass name="p0">
			<state name="vertex_shader" value="ProceduralTexVS()"/>
			<state name="pixel_shader" value="WoodPS()"/>
		</pass>
	</technique>
	<technique name="ProceduralMarbleTex">
		<pass name="p0">
			<state name="vertex_shader" value="ProceduralTexVS()"/>
			<state name="pixel_shader" value="MarblePS()"/>
		</pass>
	</technique>
	<technique name="ProceduralCloudTex">
		<pass name="p0">
			<state name="vertex_shader" value="ProceduralTexVS()"/>
			<state name="pixel_shader" value="CloudPS()"/>
		</pass>
	</technique>
</effect>
