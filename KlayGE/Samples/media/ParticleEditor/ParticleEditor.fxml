<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>
	<include name="2D.fxml"/>

	<parameter type="float" name="point_radius"/>
	<parameter type="float" name="init_life"/>

	<parameter type="float2" name="size_over_life" array_size="8"/>
	<parameter type="int" name="num_size_over_life"/>

	<parameter type="float2" name="weight_over_life" array_size="8"/>
	<parameter type="int" name="num_weight_over_life"/>

	<parameter type="float2" name="transparency_over_life" array_size="8"/>
	<parameter type="int" name="num_transparency_over_life"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="View"/>
		<parameter type="float4x4" name="Proj"/>

		<parameter type="float3" name="upper_left"/>
		<parameter type="float3" name="upper_right"/>
		<parameter type="float3" name="lower_left"/>
		<parameter type="float3" name="lower_right"/>

		<parameter type="float" name="depth_min"/>
		<parameter type="float" name="inv_depth_range"/>

		<parameter type="float2" name="offset"/>
		<parameter type="int" name="flip"/>
	</cbuffer>
	<parameter type="texture2D" name="particle_tex"/>
	<parameter type="sampler" name="particle_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>
	<parameter type="texture2D" name="scene_tex"/>
	<parameter type="sampler" name="scene_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return lerp(lerp(upper_left, upper_right, tex.x),
				lerp(lower_left, lower_right, tex.x),
				tex.y);
}

float GetSizeOverLife(float p)
{
	p /= init_life;
	for (int i = 0; (i < 7) && (i < num_size_over_life - 1); ++ i)
	{
		if (size_over_life[i + 1].x >= p)
		{
			float s = (p - size_over_life[i].x) / (size_over_life[i + 1].x - size_over_life[i].x);
			return 1 - (size_over_life[i].y + (size_over_life[i + 1].y - size_over_life[i].y) * s);
		}
	}
	return 0;
}

float GetTransparencyOverLife(float p)
{
	p /= init_life;
	for (int i = 0; (i < 7) && (i < num_transparency_over_life - 1); ++ i)
	{
		if (transparency_over_life[i + 1].x >= p)
		{
			float s = (p - transparency_over_life[i].x) / (transparency_over_life[i + 1].x - transparency_over_life[i].x);
			return 1 - (transparency_over_life[i].y + (transparency_over_life[i + 1].y - transparency_over_life[i].y) * s);
		}
	}
	return 0;
}
		]]>
	</shader>

	<shader>
		<![CDATA[
struct VS_TO_GS
{
	float4 CenterView_Life : SV_Position;
	float radius : TEXCOORD0;
	float spin : TEXCOORD1;
};

struct PS_IN
{
	float4 pos : SV_Position;
	float4 clr : COLOR0;
	float4 PosSS : TEXCOORD0;
	float4 CenterView : TEXCOORD1;
	float4 view_dir : TEXCOORD2;
	float2 tex : TEXCOORD3;
};

void ParticleVS(float4 pos : TEXCOORD0,
					float spin : TEXCOORD1,
					float2 tex : POSITION,
					out PS_IN vs_out)
{
	float radius = point_radius * GetSizeOverLife(init_life - pos.w) * 2;

	vs_out.CenterView = mul(float4(pos.xyz, 1), View);
	float4 view_pos = vs_out.CenterView;
	float2 offset = tex * radius;
	float cz = cos(spin);
	float sz = sin(spin);
	view_pos.xy += float2(offset.x * cz - offset.y * sz, offset.x * sz + offset.y * cz);
	vs_out.pos = mul(view_pos, Proj);
	vs_out.clr = float4(1, 0.45f, 0.25f, GetTransparencyOverLife(init_life - pos.w));
	vs_out.PosSS = vs_out.pos / vs_out.pos.w;
	vs_out.view_dir.xyz = texcoord_to_view(float2(vs_out.PosSS.x, -vs_out.PosSS.y) / 2 + 0.5f);
	vs_out.view_dir.w = radius;
	vs_out.tex = float2(tex.x, -tex.y) / 2 + 0.5f;
}

void ParticleVS2(float4 pos : POSITION,
					float spin : TEXCOORD0,
					out VS_TO_GS vs_out)
{
	vs_out.CenterView_Life = float4(mul(float4(pos.xyz, 1), View).xyz, pos.w);
	vs_out.radius = point_radius * GetSizeOverLife(init_life - pos.w) * 2;
	vs_out.spin = spin;
}

#ifdef KLAYGE_OPENGL
POINT TRIANGLE_OUT void ParticleGS(AttribArray<float4> input0 : SV_Position, AttribArray<float> input1 : TEXCOORD0, AttribArray<float> input2 : TEXCOORD1)
{
	float4 CenterView_Life = input0[0];
	float radius = input1[0];
	float spin = input2[0];
#else
[maxvertexcount(4)]
void ParticleGS(point VS_TO_GS input[1], inout TriangleStream<PS_IN> out_stream)
{
	float4 CenterView_Life = input[0].CenterView_Life;
	float radius = input[0].radius;
	float spin = input[0].spin;
#endif
	PS_IN gs_out;

	for (int i = 0; i < 4; ++ i)
	{
		float2 tex;
		if (0 == i)
		{
			tex = float2(-1, 1);
		}
		if (1 == i)
		{
			tex = float2(1, 1);
		}
		if (2 == i)
		{
			tex = float2(-1, -1);
		}
		if (3 == i)
		{
			tex = float2(1, -1);
		}
		
		float4 view_pos = float4(CenterView_Life.xyz, 1);
		gs_out.CenterView = view_pos;
		float2 offset = tex * radius;
		float cz = cos(spin);
		float sz = sin(spin);
		view_pos.xy += float2(offset.x * cz - offset.y * sz, offset.x * sz + offset.y * cz);
		gs_out.pos = mul(view_pos, Proj);
		gs_out.clr = float4(1, 0.45f, 0.25f, GetTransparencyOverLife(init_life - CenterView_Life.w));
		gs_out.PosSS = gs_out.pos / gs_out.pos.w;
		gs_out.view_dir.xyz = texcoord_to_view(float2(gs_out.PosSS.x, -gs_out.PosSS.y) / 2 + 0.5f);
		gs_out.view_dir.w = radius;
		gs_out.tex = float2(tex.x, -tex.y) / 2 + 0.5f;

#ifdef KLAYGE_OPENGL
		emitVertex(gs_out.pos : POSITION, gs_out.clr : COLOR0, gs_out.PosSS : TEXCOORD0,
			gs_out.CenterView : TEXCOORD1, gs_out.view_dir : TEXCOORD2, gs_out.tex : TEXCOORD3);
#else
		out_stream.Append(gs_out);
#endif
	}
	
#ifdef KLAYGE_OPENGL
	restartStrip();
#else
	out_stream.RestartStrip();
#endif
}

float4 ParticlePS(PS_IN ps_in) : SV_Target
{
	ps_in.CenterView /= ps_in.CenterView.w;
	float dir = ps_in.view_dir.z;
	ps_in.view_dir.xyz = normalize(ps_in.view_dir.xyz);
	
	float4 clr = ps_in.clr;
	
	float v = dot(ps_in.CenterView.xyz, ps_in.view_dir.xyz);
	float disc = ps_in.view_dir.w * ps_in.view_dir.w - (dot(ps_in.CenterView.xyz, ps_in.CenterView.xyz) - v * v);
	if (disc < 0)
	{
		clip(-1);
	}
	else
	{
		float2 tex_coord = ps_in.PosSS.xy + offset;
		tex_coord.y *= flip;
		tex_coord = tex_coord / 2 + 0.5f;

		float depth = scene_tex.SampleLevel(scene_sampler, tex_coord, 0).a;

		float3 intersect = (v - sqrt(disc)) * ps_in.view_dir.xyz;
		clr.a *= particle_tex.SampleLevel(particle_sampler, ps_in.tex, 0).r;
		clr.a *= saturate((dir * depth - intersect.z) * 5);
		clip(clr.a - 0.03f);
	}

	return clr;
}
		]]>
	</shader>

	<technique name="Particle">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="one"/>

			<state name="vertex_shader" value="ParticleVS()"/>
			<state name="pixel_shader" value="ParticlePS()"/>
		</pass>
	</technique>

	<technique name="ParticleWithGS">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="one"/>

			<state name="vertex_shader" value="ParticleVS2()"/>
			<state name="geometry_shader" value="ParticleGS()"/>
			<state name="pixel_shader" value="ParticlePS()"/>
		</pass>
	</technique>

	<parameter type="float3" name="LightPos" x="0" y="10" z="3"/>
	<parameter type="texture2D" name="grass_tex"/>
	<parameter type="texture2D" name="logo_tex">
		<annotation type="string" name="SasResourceAddress" value="klayge_logo_sm.dds"/>
	</parameter>
	<parameter type="sampler" name="grass_sampler">
		<state name="filtering" value="anisotropic"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
		<state name="max_anisotropy" value="8"/>
	</parameter>

	<shader>
		<![CDATA[
void TerrainVS(float4 Position : POSITION,
					out float4 oTex0 : TEXCOORD0,
					out float3 oPosOS : TEXCOORD1,
					out float3 oNormal : TEXCOORD2,
					out float2 oDepth : TEXCOORD3,
					out float4 oPos : SV_Position)
{
	float4 pos_es = mul(Position, View);
	oPos = mul(pos_es, Proj);
	oNormal = float3(0, 1, 0);
	oPosOS = Position.xyz;
	oDepth = pos_es.zw;
	oTex0 = Position.xzxz * float4(1, 1, 0.5, -0.8f);
}

float4 TerrainPS(float4 tex0 : TEXCOORD0,
					float3 pos_os : TEXCOORD1,
					float3 normal : TEXCOORD2,
					float2 depth : TEXCOORD3) : SV_Target 
{
	float4 logo = logo_tex.Sample(grass_sampler, tex0.zw);
	float4 clr = float4(grass_tex.Sample(grass_sampler, tex0.xy).rgb * dot(normalize(LightPos - pos_os), normal),
				(depth.x / depth.y - depth_min) * inv_depth_range);
	return float4(lerp(clr.rgb, logo.rgb, 0.3f), 1);
}
		]]>
	</shader>

	<technique name="Terrain">
		<pass name="p0">
			<state name="vertex_shader" value="TerrainVS()"/>
			<state name="pixel_shader" value="TerrainPS()"/>
		</pass>
	</technique>
</effect>
