<?xml version='1.0'?>

<effect>
	<include name="DeferredRenderingUtil.fxml"/>
	<include name="util.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="Quaternion.fxml"/>
	<include name="GBuffer.fxml"/>

	<parameter type="float4" name="joint_reals" array_size="NUM_JOINTS"/>
	<parameter type="float4" name="joint_duals" array_size="NUM_JOINTS"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float4" name="ambient_clr"/>
	<parameter type="float4" name="specular_clr"/>

	<cbuffer name="less_freq">
		<parameter type="int" name="vertex_usage"/>
		<parameter type="int" name="vertex_usage_index"/>
		<parameter type="int" name="texture_slot"/>
	</cbuffer>

	<shader>
		<![CDATA[
void Skinned(float3 pos,
			float3 normal,
			float3 tangent,
			float4 blend_weights,
			int4 blend_indices,
			out float3 result_pos,
			out float3 result_normal,
			out float3 result_tangent)
{
	float4 dp0 = joint_reals[blend_indices[0]];
	
	float4 blend_real = 0;
	float4 blend_dual = 0;
	for (int i = 0; i < 4; ++ i)
	{
		float4 joint_real = joint_reals[blend_indices[i]];
		float4 joint_dual = joint_duals[blend_indices[i]];

		float weight = blend_weights[i];
		
		if (dot(dp0, joint_real) < 0)
		{
			joint_real = -joint_real;
			joint_dual = -joint_dual;
		}

		blend_real += joint_real * weight;
		blend_dual += joint_dual * weight;
	}

	float inv_len = 1 / length(blend_real);
	blend_real *= inv_len;
	blend_dual *= inv_len;

	result_pos = pos + 2 * cross(blend_real.xyz, cross(blend_real.xyz, pos) + blend_real.w * pos);
	float3 trans = 2 * (blend_real.w * blend_dual.xyz - blend_dual.w * blend_real.xyz + cross(blend_real.xyz, blend_dual.xyz));
	result_pos += trans;

	result_normal = normal + 2 * cross(blend_real.xyz, cross(blend_real.xyz, normal) + blend_real.w * normal);
	result_tangent = tangent + 2 * cross(blend_real.xyz, cross(blend_real.xyz, tangent) + blend_real.w * tangent);
}

void CalcMesh(float2 tex0,
				float4 pos,
				float3 N,
				float4 T,

				out float2 oTex,
				out float3 oPos,
				out float3 oNormal,
				out float3 oTangent,
				out float3 oBinormal)
{
	N = N * 2 - 1;
	T = T * 2 - 1;
	
	oPos = pos.xyz;
	oTangent = T.xyz;
	oNormal = N;

	oNormal = normalize(oNormal);
	oTangent = normalize(oTangent);
	oBinormal = cross(oNormal, oTangent) * T.w;

	oTex = tex0;
}

void CalcSkinnedMesh(float2 tex0,
				float4 pos,
				float4 blend_weights,
				int4 blend_indices,
				float3 N,
				float4 T,

				out float2 oTex,
				out float3 oPos,
				out float3 oNormal,
				out float3 oTangent,
				out float3 oBinormal)
{
	N = N * 2 - 1;
	T = T * 2 - 1;
	
	Skinned(pos.xyz, N, T.xyz, blend_weights, blend_indices, oPos, oNormal, oTangent);
	
	oNormal = normalize(oNormal);
	oTangent = normalize(oTangent);
	oBinormal = cross(oNormal, oTangent) * T.w;

	oTex = tex0;
}

void CalcPosLH(float3 pos,
				float3x3 obj_to_ts,
				out float4 oPos,
				out float2 oTsToView0_2xy,
				out float4 oTsToView0_2z,
				out float4 oTsToView1_Depth,
#ifdef NOPERSPECTIVE_SUPPORT
				out noperspective float2 oScreenTc
#else
				out float3 oScreenTc
#endif
				)
{
	oPos = mul(float4(pos, 1), mvp);

	float3x3 ts_to_view = mul(obj_to_ts, (float3x3)model_view);
	oTsToView0_2z.xyz = ts_to_view[0];
	oTsToView1_Depth.xyz = ts_to_view[1];
	oTsToView0_2xy.xy = ts_to_view[2].xy;
	oTsToView0_2z.w = ts_to_view[2].z;
	
	oTsToView1_Depth.w = oPos.w;
	
	oScreenTc.xy = oPos.xy / oPos.w * 0.5f;
	oScreenTc.y *= flipping;
	oScreenTc.xy += 0.5f;
	
#ifndef NOPERSPECTIVE_SUPPORT
	oScreenTc.z = oPos.w;
	oScreenTc.xy *= oScreenTc.z;
#endif
}

float4 VisualizeVertex(float3 pos, float3 tangent, float3 binormal, float3 normal,
						float4 blend_weights, int4 blend_indices, float2 tex)
{
	float4 oClr;
	if (0 == vertex_usage)
	{
		oClr = float4(pos, 1);
	}
	else if (1 == vertex_usage)
	{
		oClr = float4(normal / 2 + 0.5f, 1);
	}
	else if (4 == vertex_usage)
	{
		oClr = blend_weights;
	}
	else if (5 == vertex_usage)
	{
		oClr = blend_indices / 255.0f;
	}
	else if (6 == vertex_usage)
	{
		oClr = float4(tex, 0, 1);
	}
	else if (7 == vertex_usage)
	{
		oClr = float4(tangent / 2 + 0.5f, 1);
	}
	else// if (8 == vertex_usage)
	{
		oClr = float4(binormal / 2 + 0.5f, 1);
	}

	return oClr;
}



void MeshVS(float2 texcoord : TEXCOORD0,
			float4 pos : POSITION,
			float3 normal : NORMAL,
			float4 tangent : TANGENT,
			out float4 oTexCoord_2xy : TEXCOORD0,
			out float4 oTsToView0_2z : TEXCOORD1,
			out float4 oTsToView1_Depth : TEXCOORD2,
#ifdef NOPERSPECTIVE_SUPPORT
			out noperspective float2 oScreenTc : TEXCOORD3,
#else
			out float3 oScreenTc : TEXCOORD3,
#endif
			out float4 oPos : SV_Position)
{
	float3 result_pos;
	float3x3 obj_to_ts;
	CalcMesh(texcoord, pos,
				normal, tangent,
				oTexCoord_2xy.xy, result_pos,
				obj_to_ts[2], obj_to_ts[0], obj_to_ts[1]);
				
	CalcPosLH(result_pos, obj_to_ts,
				oPos, oTexCoord_2xy.zw, oTsToView0_2z, oTsToView1_Depth,
				oScreenTc);
}

void SkinnedMeshVS(float2 texcoord : TEXCOORD0,
			float4 pos : POSITION,
			float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
			float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
			float4 blend_indices_f : BLENDINDICES,
#else
			uint4 blend_indices : BLENDINDICES,
#endif
#endif
			float3 normal : NORMAL,
			float4 tangent : TANGENT,
			out float4 oTexCoord_2xy : TEXCOORD0,
			out float4 oTsToView0_2z : TEXCOORD1,
			out float4 oTsToView1_Depth : TEXCOORD2,
#ifdef NOPERSPECTIVE_SUPPORT
			out noperspective float2 oScreenTc : TEXCOORD3,
#else
			out float3 oScreenTc : TEXCOORD3,
#endif
			out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos;
	float3x3 obj_to_ts;
	CalcSkinnedMesh(texcoord, pos,
				blend_weights, blend_indices,
				normal, tangent,
				oTexCoord_2xy.xy, result_pos,
				obj_to_ts[2], obj_to_ts[0], obj_to_ts[1]);
				
	CalcPosLH(result_pos, obj_to_ts,
				oPos, oTexCoord_2xy.zw, oTsToView0_2z, oTsToView1_Depth,
				oScreenTc);
}

void VisualizeVertexVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float4 oClr : COLOR,
				out float4 oPos : SV_Position)
{
	float3 result_pos;
	float3x3 obj_to_ts;
	float2 oTex;
	CalcMesh(tex0, pos,
				N, T,
				oTex, result_pos,
				obj_to_ts[2], obj_to_ts[0], obj_to_ts[1]);

	oPos = mul(float4(result_pos, 1), mvp);
	oClr = VisualizeVertex(result_pos, obj_to_ts[0], obj_to_ts[1], obj_to_ts[2], 0, 0, oTex);
}


void VisualizeVertexSkinnedVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				uint4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float4 oClr : COLOR,
				out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos;
	float3x3 obj_to_ts;
	float2 oTex;
	CalcSkinnedMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				oTex, result_pos,
				obj_to_ts[2], obj_to_ts[0], obj_to_ts[1]);

	oPos = mul(float4(result_pos, 1), mvp);
	oClr = VisualizeVertex(result_pos, obj_to_ts[0], obj_to_ts[1], obj_to_ts[2], blend_weights, blend_indices, oTex);
}

void VisualizeVertexPS(float4 clr : COLOR,
				out float4 mrt_0 : SV_Target0, out float4 mrt_1 : SV_Target1)
{
	mrt_0 = 0;
	mrt_1 = clr;
}

void VisualizeTexturePS(float2 tex0 : TEXCOORD0,
				out float4 mrt_0 : SV_Target0, out float4 mrt_1 : SV_Target1)
{
	mrt_0 = 0;
	if (0 == texture_slot)
	{
		if (diffuse_clr.w > 0.5f)
		{
			mrt_1 = float4(diffuse_tex.Sample(linear_sampler, tex0).rgb, 1);
		}
		else
		{
			mrt_1 = float4(diffuse_clr.rgb, 1);
		}
	}
	else if (1 == texture_slot)
	{
		if (specular_level.w > 0.5f)
		{
			mrt_1 = float4(specular_tex.Sample(linear_sampler, tex0).rgb, 1);
		}
		else
		{
			mrt_1 = float4(specular_level.rgb, 1);
		}
	}
	else if (2 == texture_slot)
	{
		if (normal_map_enabled)
		{
			mrt_1 = float4(decompress_normal(normal_tex.Sample(linear_sampler, tex0)).rgb, 1);
		}
		else
		{
			mrt_1 = float4(0, 0, 1, 1);
		}
	}
	else if (3 == texture_slot)
	{
		if (emit_clr.w > 0.5f)
		{
			mrt_1 = float4(emit_tex.Sample(linear_sampler, tex0).rgb, 1);
		}
		else
		{
			mrt_1 = float4(emit_clr.rgb, 1);
		}
	}
	else //if (4 == texture_slot)
	{
		if (opacity_map_enabled)
		{
			mrt_1 = diffuse_tex.Sample(linear_sampler, tex0).a;
		}
		else
		{
			mrt_1 = opacity_clr;
		}
	}
}
		]]>
	</shader>

	<technique name="GBufferFillMRTTech" inherit="GBufferMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="MeshVS()"/>
		</pass>
	</technique>
	
	<technique name="GBufferFillSkinnedMRTTech" inherit="GBufferMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="SkinnedMeshVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillAlphaTestMRTTech" inherit="GBufferAlphaTestMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="MeshVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedAlphaTestMRTTech" inherit="GBufferMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="SkinnedMeshVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillBlendBackMRTTech" inherit="GBufferAlphaBlendBackMRTTech">
		<pass name="p0">			
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="MeshVS()"/>
		</pass>
	</technique>
	<technique name="GBufferFillBlendFrontMRTTech" inherit="GBufferAlphaBlendFrontMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="MeshVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedBlendBackMRTTech" inherit="GBufferAlphaBlendBackMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="SkinnedMeshVS()"/>
		</pass>
	</technique>
	<technique name="GBufferFillSkinnedBlendFrontMRTTech" inherit="GBufferAlphaBlendFrontMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="vertex_shader" value="SkinnedMeshVS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="always_pass"/>
			<state name="front_stencil_ref" value="128"/>
			<state name="front_stencil_pass" value="replace"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="always_pass"/>
			<state name="back_stencil_ref" value="128"/>
			<state name="back_stencil_pass" value="replace"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSkinnedMRTTech" inherit="VisualizeVertexFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="VisualizeVertexSkinnedVS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="always_pass"/>
			<state name="front_stencil_ref" value="128"/>
			<state name="front_stencil_pass" value="replace"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="always_pass"/>
			<state name="back_stencil_ref" value="128"/>
			<state name="back_stencil_pass" value="replace"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSkinnedMRTTech" inherit="VisualizeTextureFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SkinnedMeshVS()"/>
		</pass>
	</technique>

	<technique name="GBufferLineMRTTech" inherit="GBufferFillMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedMRTTech" inherit="GBufferFillSkinnedMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineAlphaTestMRTTech" inherit="GBufferFillAlphaTestMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedAlphaTestMRTTech" inherit="GBufferFillSkinnedAlphaTestMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineBlendBackMRTTech" inherit="GBufferFillBlendBackMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	<technique name="GBufferLineBlendFrontMRTTech" inherit="GBufferFillBlendFrontMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedBlendBackMRTTech" inherit="GBufferFillSkinnedBlendBackMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	<technique name="GBufferLineSkinnedBlendFrontMRTTech" inherit="GBufferFillSkinnedBlendFrontMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineMRTTech" inherit="VisualizeVertexFillMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSkinnedMRTTech" inherit="VisualizeVertexFillSkinnedMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineMRTTech" inherit="VisualizeTextureFillMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSkinnedMRTTech" inherit="VisualizeTextureFillSkinnedMRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>


	<parameter type="bool" name="adaptive_tess"/>
	<parameter type="float4" name="tess_factors"/>

	<shader>
		<![CDATA[
float3 PhongProject(float3 p, float3 c, float3 n)
{
	return p - dot(p - c, n) * n;
}

void InterpolatePhongAttrs(float3 bc_coords,
				float3 pos0, float3 pos1, float3 pos2,
				float2 tex0, float2 tex1, float2 tex2,
				float3 normal0, float3 normal1, float3 normal2,
				float3 tangent0, float3 tangent1, float3 tangent2,
				float3 binormal0, float3 binormal1, float3 binormal2,
				
				out float3 oPos, out float2 oTex,
				out float3 oNormal, out float3 oTangent, out float3 oBinormal)
{
	// The barycentric coordinates
	float u = bc_coords.x;
	float v = bc_coords.y;
	float w = bc_coords.z;
	
	float alpha = 0.75f;

	float3 p = w * pos0 + u * pos1 + v * pos2;
	float3 c0 = PhongProject(p, pos0, normal0);
	float3 c1 = PhongProject(p, pos1, normal1);
	float3 c2 = PhongProject(p, pos2, normal2);
	float3 q = w * c0 + u * c1 + v * c2;
	oPos = lerp(p, q, alpha);

	// Compute normal from quadratic control points and barycentric coords
	oNormal = normal0 * w
					+ normal1 * u
					+ normal2 * v;
	oNormal = normalize(oNormal);

	// Linearly interpolate the tangent
	oTangent = tangent0 * w
					+ tangent1 * u
					+ tangent2 * v;
	oTangent = normalize(oTangent);

	// Linearly interpolate the binormal
	oBinormal = binormal0 * w
					+ binormal1 * u
					+ binormal2 * v;
	oBinormal = normalize(oBinormal);

	// Linearly interpolate the texture coords
	oTex = tex0 * w + tex1 * u + tex2 * v;
}
		]]>
	</shader>

	<shader version="5">
		<![CDATA[
struct CONTROL_POINT
{
	float3 Pos : POSITION;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
	float3 Tangent : TEXCOORD2;
	float3 Binormal : TEXCOORD3;
};

CONTROL_POINT SmoothVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float3 N	: NORMAL,
				float4 T	: TANGENT)
{
	CONTROL_POINT output;

	CalcMesh(tex0, pos,
				N, T,
				output.Texcoord0, output.Pos,
				output.Normal, output.Tangent, output.Binormal);

	return output;
}


CONTROL_POINT SmoothSkinnedVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				uint4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,
				float4 T	: TANGENT)
{
	CONTROL_POINT output;
	
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	CalcSkinnedMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				output.Texcoord0, output.Pos,
				output.Normal, output.Tangent, output.Binormal);

	return output;
}
		
struct HS_CONSTANT_DATA_OUTPUT
{
	// Tess factor for the FF HW block
	float edges[3]	: SV_TessFactor;
	float inside	: SV_InsideTessFactor;
};

//--------------------------------------------------------------------------------------
// Constant data function for the SmoothHS.  This is executed once per patch.
//--------------------------------------------------------------------------------------
HS_CONSTANT_DATA_OUTPUT SmoothConstantsHS(InputPatch<CONTROL_POINT, 3> ip)
{	
	HS_CONSTANT_DATA_OUTPUT output;
    
	if (adaptive_tess)
	{
		// Calculate the tessellation factor per edge, based on distance from camera
		float dist;
		float3 mid_point;
		// Edge 0
		mid_point = mul(float4((ip[2].Pos + ip[0].Pos) / 2, 1), model_view).xyz;
		dist = length(mid_point) - tess_factors.z;
		output.edges[0] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 1
		mid_point = mul(float4((ip[0].Pos + ip[1].Pos) / 2, 1), model_view).xyz;
		dist = length(mid_point) - tess_factors.z;
		output.edges[1] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 2
		mid_point = mul(float4((ip[1].Pos + ip[2].Pos) / 2, 1), model_view).xyz;
		dist = length(mid_point) - tess_factors.z;
		output.edges[2] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Inside
		output.inside = (output.edges[0] + output.edges[1] + output.edges[2]) / 3;
	}
	else
	{
		// Simply output the tessellation factors from constant space 
		// for use by the FF tessellation unit
		output.edges[0] = output.edges[1] = output.edges[2] = tess_factors.x;
		output.inside = tess_factors.y;
	}

	return output;
}

[domain("tri")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(3)]
[patchconstantfunc("SmoothConstantsHS")]
CONTROL_POINT SmoothHS(InputPatch<CONTROL_POINT, 3> p, 
								uint i : SV_OutputControlPointID)
{
	CONTROL_POINT output;
	output.Pos = p[i].Pos;
	output.Texcoord0 = p[i].Texcoord0;
	output.Normal = p[i].Normal;
	output.Tangent = p[i].Tangent;
	output.Binormal = p[i].Binormal;
	return output;
}

[domain("tri")]
void SmoothDS(HS_CONSTANT_DATA_OUTPUT HSConstantData, 
							float3 bc_coords : SV_DomainLocation,
							const OutputPatch<CONTROL_POINT, 3> patch,

							out float4 oTexCoord_2xy : TEXCOORD0,
							out float4 oTsToView0_2z : TEXCOORD1,
							out float4 oTsToView1_Depth : TEXCOORD2,
#ifdef NOPERSPECTIVE_SUPPORT
							out noperspective float2 oScreenTc : TEXCOORD3,
#else
							out float3 oScreenTc : TEXCOORD3,
#endif
							out float4 oPos : SV_Position)
{
	float3 pos;
	float3x3 obj_to_ts;
	InterpolatePhongAttrs(bc_coords,
				patch[0].Pos, patch[1].Pos, patch[2].Pos,
				patch[0].Texcoord0, patch[1].Texcoord0, patch[2].Texcoord0,
				patch[0].Normal, patch[1].Normal, patch[2].Normal,
				patch[0].Tangent, patch[1].Tangent, patch[2].Tangent,
				patch[0].Binormal, patch[1].Binormal, patch[2].Binormal,
				
				pos, oTexCoord_2xy.xy,
				obj_to_ts[2], obj_to_ts[0], obj_to_ts[1]);

	CalcPosLH(pos, obj_to_ts,
				oPos, oTexCoord_2xy.zw, oTsToView0_2z, oTsToView1_Depth,
				oScreenTc);
}
		]]>
	</shader>

	<technique name="GBufferFillSmooth5MRTTech" inherit="GBufferFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedSmooth5MRTTech" inherit="GBufferFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothSkinnedVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillAlphaTestSmooth5MRTTech" inherit="GBufferFillAlphaTestMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedAlphaTestSmooth5MRTTech" inherit="GBufferFillAlphaTestMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothSkinnedVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillBlendBackSmooth5MRTTech" inherit="GBufferFillBlendBackMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>
	<technique name="GBufferFillBlendFrontSmooth5MRTTech" inherit="GBufferFillBlendFrontMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedBlendBackSmooth5MRTTech" inherit="GBufferFillSkinnedBlendBackMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothSkinnedVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>
	<technique name="GBufferFillSkinnedBlendFrontSmooth5MRTTech" inherit="GBufferFillSkinnedBlendFrontMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothSkinnedVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth5MRTTech" inherit="VisualizeVertexFillMRTTech">
		<pass name="p0">
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSkinnedSmooth5MRTTech" inherit="VisualizeVertexFillSkinnedMRTTech">
		<pass name="p0">
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth5MRTTech" inherit="VisualizeTextureFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSkinnedSmooth5MRTTech" inherit="VisualizeTextureFillSkinnedMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="SmoothSkinnedVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
		</pass>
	</technique>

	<technique name="GBufferLineSmooth5MRTTech" inherit="GBufferFillSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedSmooth5MRTTech" inherit="GBufferFillSkinnedSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineAlphaTestSmooth5MRTTech" inherit="GBufferFillAlphaTestSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedAlphaTestSmooth5MRTTech" inherit="GBufferFillSkinnedAlphaTestSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineBlendBackSmooth5MRTTech" inherit="GBufferFillBlendBackSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	<technique name="GBufferLineBlendFrontSmooth5MRTTech" inherit="GBufferFillBlendFrontSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedBlendBackSmooth5MRTTech" inherit="GBufferFillSkinnedBlendBackSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	<technique name="GBufferLineSkinnedBlendFrontSmooth5MRTTech" inherit="GBufferFillSkinnedBlendFrontSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	
	<technique name="VisualizeVertexLineSmooth5MRTTech" inherit="VisualizeVertexFillSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSkinnedSmooth5MRTTech" inherit="VisualizeVertexFillSkinnedSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth5MRTTech" inherit="VisualizeTextureFillSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSkinnedSmooth5MRTTech" inherit="VisualizeTextureFillSkinnedSmooth5MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>


	<parameter type="buffer" elem_type="float4" name="skinned_pos_buf"/>
	<parameter type="buffer" elem_type="float2" name="skinned_tex_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_normal_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_tangent_buf"/>
	<parameter type="buffer" elem_type="uint" name="index_buf"/>
	<parameter type="int" name="start_index_loc"/>
	<parameter type="int" name="base_vertex_loc"/>

	<shader type="vertex_shader" version="4">
		<![CDATA[
void SkinnedStreamOutVS(float3 pos : POSITION,
					float2 texcoord0 : TEXCOORD0,
					float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
					float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
					float4 blend_indices_f : BLENDINDICES,
#else
					uint4 blend_indices : BLENDINDICES,
#endif
#endif
					float3 N : NORMAL,
					float4 T : Tangent,

					out float4 oPosOS : SV_Position,
					out float2 oTex0 : TEXCOORD0,
					out float4 oNormal : NORMAL,
					out float4 oTangent : TANGENT)
{
	float3 result_pos, result_normal, result_tangent, result_binormal;
	CalcSkinnedMesh(texcoord0, float4(pos, 1),
				blend_weights, blend_indices,
				N, T,
				oTex0, result_pos,
				result_normal, result_tangent, result_binormal);

	oPosOS = float4(result_pos, 1);
	oNormal = float4(result_normal / 2 + 0.5f, 0);
	oTangent = float4(result_tangent / 2 + 0.5f, T.w);
}


void CalcInstTessSmooth(float2 barycentric,
					uint instance_id,
					out float2 oTex0,
					out float3 oPos,
					out float3 oNormal,
					out float3 oTangent,
					out float3 oBinormal)
{
	uint index0 = index_buf.Load(instance_id * 3 + 0);
	float3 pos_os0 = skinned_pos_buf.Load(index0).xyz;
	float2 tex0 = skinned_tex_buf.Load(index0).xy;
	float3 normal0 = skinned_normal_buf.Load(index0).xyz * 2 - 1;
	float4 tangent0 = skinned_tangent_buf.Load(index0) * 2 - 1;
	float3 binormal0 = cross(normal0, tangent0.xyz) * tangent0.w;
	uint index1 = index_buf.Load(instance_id * 3 + 1);
	float3 pos_os1 = skinned_pos_buf.Load(index1).xyz;
	float2 tex1 = skinned_tex_buf.Load(index1).xy;
	float3 normal1 = skinned_normal_buf.Load(index1).xyz * 2 - 1;
	float4 tangent1 = skinned_tangent_buf.Load(index1) * 2 - 1;
	float3 binormal1 = cross(normal1.xyz, tangent1.xyz) * tangent1.w;
	uint index2 = index_buf.Load(instance_id * 3 + 2);
	float3 pos_os2 = skinned_pos_buf.Load(index2).xyz;
	float2 tex2 = skinned_tex_buf.Load(index2).xy;
	float3 normal2 = skinned_normal_buf.Load(index2).xyz * 2 - 1;
	float4 tangent2 = skinned_tangent_buf.Load(index2) * 2 - 1;
	float3 binormal2 = cross(normal2.xyz, tangent2.xyz) * tangent2.w;

	InterpolatePhongAttrs(float3(barycentric, 1 - barycentric.x - barycentric.y),
				pos_os0, pos_os1, pos_os2,
				tex0, tex1, tex2,
				normal0, normal1, normal2,
				tangent0.xyz, tangent1.xyz, tangent2.xyz,
				binormal0, binormal1, binormal2,
				
				oPos, oTex0,
				oNormal, oTangent, oBinormal);
}

void InstTessSmoothVS(float2 barycentric : TEXCOORD1,

					uint instance_id : SV_InstanceID,
					
					out float4 oTexCoord_2xy : TEXCOORD0,
					out float4 oTsToView0_2z : TEXCOORD1,
					out float4 oTsToView1_Depth : TEXCOORD2,
#ifdef NOPERSPECTIVE_SUPPORT
					out noperspective float2 oScreenTc : TEXCOORD3,
#else
					out float3 oScreenTc : TEXCOORD3,
#endif
					out float4 oPos : SV_Position)
{
	float3 pos;
	float3x3 obj_to_ts;
	CalcInstTessSmooth(barycentric, instance_id,
					oTexCoord_2xy.xy, pos, obj_to_ts[2], obj_to_ts[0], obj_to_ts[1]);

	CalcPosLH(pos, obj_to_ts,
				oPos, oTexCoord_2xy.zw, oTsToView0_2z, oTsToView1_Depth,
				oScreenTc);
}

void InstTessSmoothVisualizeVertexVS(float2 barycentric : TEXCOORD1,

					uint instance_id : SV_InstanceID,
					
					out float4 oClr : COLOR,
					out float4 oPos : SV_Position)
{
	float2 tex0;
	float3 pos, normal, tangent, binormal;
	CalcInstTessSmooth(barycentric, instance_id,
					tex0, pos, normal, tangent, binormal);

	oPos = mul(float4(pos, 1), mvp);
	oClr = VisualizeVertex(pos, tangent, binormal, normal, 0, 0, tex0);
}
		]]>
	</shader>

	<technique name="SkinnedStreamOut">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="SkinnedStreamOutVS()">
				<stream_output>
					<slot usage="POSITION" component="xyzw"/>
					<slot usage="TEXCOORD" usage_index="0" component="xy"/>
					<slot usage="NORMAL" component="xyzw"/>
					<slot usage="TANGENT" component="xyzw"/>
				</stream_output>
			</state>
		</pass>
	</technique>



	<technique name="GBufferFillSmooth4MRTTech" inherit="GBufferFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedSmooth4MRTTech" inherit="GBufferFillSkinnedMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillAlphaTestSmooth4MRTTech" inherit="GBufferFillAlphaTestMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedAlphaTestSmooth4MRTTech" inherit="GBufferFillSkinnedAlphaTestMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillBlendBackSmooth4MRTTech" inherit="GBufferFillBlendBackMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>
	<technique name="GBufferFillBlendFrontSmooth4MRTTech" inherit="GBufferFillBlendFrontMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="GBufferFillSkinnedBlendBackSmooth4MRTTech" inherit="GBufferFillSkinnedBlendBackMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>
	<technique name="GBufferFillSkinnedBlendFrontSmooth4MRTTech" inherit="GBufferFillSkinnedBlendFrontMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth4MRTTech" inherit="VisualizeVertexFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVisualizeVertexVS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSkinnedSmooth4MRTTech" inherit="VisualizeVertexFillSkinnedMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVisualizeVertexVS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth4MRTTech" inherit="VisualizeTextureFillMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSkinnedSmooth4MRTTech" inherit="VisualizeTextureFillSkinnedMRTTech">
		<pass name="p0">
			<state name="vertex_shader" value="InstTessSmoothVS()"/>
		</pass>
	</technique>

	<technique name="GBufferLineSmooth4MRTTech" inherit="GBufferFillSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedSmooth4MRTTech" inherit="GBufferFillSkinnedSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineAlphaTestSmooth4MRTTech" inherit="GBufferFillAlphaTestSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedAlphaTestSmooth4MRTTech" inherit="GBufferFillSkinnedAlphaTestSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineBlendBackSmooth4MRTTech" inherit="GBufferFillBlendBackSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	<technique name="GBufferLineBlendFrontSmooth4MRTTech" inherit="GBufferFillBlendFrontSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="GBufferLineSkinnedBlendBackSmooth4MRTTech" inherit="GBufferFillSkinnedBlendBackSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	<technique name="GBufferLineSkinnedBlendFrontSmooth4MRTTech" inherit="GBufferFillSkinnedBlendFrontSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSmooth4MRTTech" inherit="VisualizeVertexFillSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSkinnedSmooth4MRTTech" inherit="VisualizeVertexFillSkinnedSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth4MRTTech" inherit="VisualizeTextureFillSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSkinnedSmooth4MRTTech" inherit="VisualizeTextureFillSkinnedSmooth4MRTTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
</effect>
