<?xml version='1.0'?>

<effect>
	<include name="util.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="Quaternion.fxml"/>

	<parameter type="float4" name="joint_rots" array_size="NUM_JOINTS"/>
	<parameter type="float4" name="joint_poss" array_size="NUM_JOINTS"/>

	<parameter type="float4x4" name="worldviewproj" semantic="WORLDVIEWPROJECTION"/>
	<parameter type="float3" name="light_pos"/>
	<parameter type="float3" name="eye_pos"/>

	<parameter type="int" name="has_skinned"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float4" name="ambient_clr"/>
	<parameter type="float4" name="diffuse_clr"/>
	<parameter type="float4" name="specular_clr"/>
	<parameter type="float4" name="emit_clr"/>
	<parameter type="float4" name="opacity_clr"/>

	<parameter type="float" name="specular_level"/>
	<parameter type="float" name="shininess"/>
	
	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="texture2D" name="normal_tex"/>
	<parameter type="texture2D" name="specular_tex"/>
	<parameter type="texture2D" name="emit_tex"/>
	<parameter type="texture2D" name="opacity_tex"/>

	<cbuffer name="less_freq">
		<parameter type="int" name="vertex_usage"/>
		<parameter type="int" name="vertex_usage_index"/>
		<parameter type="int" name="texture_slot"/>
	</cbuffer>

	<shader>
		<![CDATA[
void Skinned(float3 pos,
			float3 normal,
			float3 tangent,
			float4 blend_weights,
			int4 blend_indices,
			out float3 result_pos,
			out float3 result_normal,
			out float3 result_tangent)
{
	result_pos = float3(0, 0, 0);
	result_normal = float3(0, 0, 0);
	result_tangent = float3(0, 0, 0);
	for (int i = 0; i < 4; ++ i)
	{
		float4 joint_rot = joint_rots[blend_indices[i]];
		float4 joint_pos = joint_poss[blend_indices[i]];
		float weight = blend_weights[i];

		result_pos += (mul_quat(pos, joint_rot) + joint_pos.xyz) * weight;
		result_normal += mul_quat(normal, joint_rot) * weight;
		result_tangent += mul_quat(tangent, joint_rot) * weight;
	}
}

void MeshVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				int4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float2 oTex0 : TEXCOORD0,
				out float3 oL	: TEXCOORD1,	// in tangent space
				out float3 oH	: TEXCOORD2,	// in tangent space
				out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	N = N * 2 - 1;
	T = T * 2 - 1;
	
	float4 result_pos;
	float3x3 obj2tan;
	if (has_skinned)
	{
		result_pos = float4(0, 0, 0, 1);
		obj2tan = 0;
		Skinned(pos.xyz, N, T.xyz, blend_weights, blend_indices, result_pos.xyz, obj2tan[2], obj2tan[0]);
		obj2tan[0] = normalize(obj2tan[0]);
		obj2tan[2] = normalize(obj2tan[2]);
		obj2tan[1] = cross(obj2tan[2], obj2tan[0]) * T.w;
	}
	else
	{
		result_pos = pos;
		obj2tan[0] = T.xyz;
		obj2tan[2] = N;
		obj2tan[1] = cross(obj2tan[2], obj2tan[0]) * T.w;
	}

	oTex0 = tex0;
	
	oPos = mul(result_pos, worldviewproj);

	float3 L = light_pos - result_pos.xyz;
	float3 V = eye_pos - result_pos.xyz;
	float3 H = normalize(L) + normalize(V);

	oL = mul(obj2tan, L);
	oH = mul(obj2tan, H);
}

float4 LightingPS(float2 uv : TEXCOORD0,
				float3 L	: TEXCOORD1,
				float3 H	: TEXCOORD2) : SV_Target
{
	float3 normal = decompress_normal(normal_tex.Sample(linear_sampler, uv)).rgb;

	float3 c_diff, c_spec, emit;
	float opacity;
	if (diffuse_clr.a > 0.5f)
	{
		c_diff = diffuse_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		c_diff = diffuse_clr.rgb;
	}
	if (specular_clr.a > 0.5f)
	{
		c_spec = specular_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		c_spec = specular_level;
	}
	if (emit_clr.a > 0.5f)
	{
		emit = emit_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		emit = emit_clr.rgb;
	}
	if (opacity_clr.a > 0.5f)
	{
		opacity = opacity_tex.Sample(linear_sampler, uv).a;
	}
	else
	{
		opacity = opacity_clr.r;
	}
	
	float3 clr = ambient_clr.rgb * c_diff + emit;

	float3 light_vec = normalize(L);
	float3 halfway = normalize(H);
	clr += calc_brdf(c_diff, c_spec, shininess, light_vec, halfway, normal);

	return float4(clr, opacity);
}

void VisualizeVertexVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices : BLENDINDICES,
#else
				int4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float4 oClr : COLOR,
				out float4 oPos : SV_Position)
{
	float2 oTex0;
	float3 oL, oH;
	MeshVS(tex0, pos, blend_weights, blend_indices, N, T,
				oTex0, oL, oH, oPos);

	if (0 == vertex_usage)
	{
		oClr = pos;
	}
	else if (1 == vertex_usage)
	{
		oClr = float4(N, 1);
	}
	else if (4 == vertex_usage)
	{
		oClr = blend_weights;
	}
	else if (5 == vertex_usage)
	{
		oClr = blend_indices / 255.0f;
	}
	else if (6 == vertex_usage)
	{
		oClr = float4(tex0, 0, 1);
	}
	else if (7 == vertex_usage)
	{
		oClr = float4(T.xyz, 1);
	}
	else// if (8 == vertex_usage)
	{
		N = N * 2 - 1;
		T = T * 2 - 1;
		oClr = float4(cross(N, T.xyz) * T.w / 2 + 0.5f, 1);
	}
}

float4 VisualizeVertexPS(float4 clr : COLOR) : SV_Target
{
	return clr;
}

float4 VisualizeTexturePS(float2 tex0 : TEXCOORD0) : SV_Target
{
	if (0 == texture_slot)
	{
		return diffuse_tex.Sample(linear_sampler, tex0);
	}
	else if (1 == texture_slot)
	{
		return specular_tex.Sample(linear_sampler, tex0);
	}
	else if (2 == texture_slot)
	{
		return float4(decompress_normal(normal_tex.Sample(linear_sampler, tex0)).rgb, 1);
	}
	else if (3 == texture_slot)
	{
		return emit_tex.Sample(linear_sampler, tex0);
	}
	else //if (4 == texture_slot)
	{
		return opacity_tex.Sample(linear_sampler, tex0);
	}
}
		]]>
	</shader>

	<technique name="LightingLineTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>


	<parameter type="bool" name="adaptive_tess"/>
	<parameter type="float4" name="tess_factors"/>

	<shader version="5">
		<![CDATA[
struct VS_CONTROL_POINT_OUTPUT
{
	float3 Pos : POSITION;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
	float3 Tangent : TEXCOORD2;
	float3 Binormal : TEXCOORD3;
};

VS_CONTROL_POINT_OUTPUT PNTrianglesVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				int4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL
				float4 T	: TANGENT)
{
	VS_CONTROL_POINT_OUTPUT output;
	
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	N = N * 2 - 1;
	T = T * 2 - 1;
	
	float3 result_pos;
	float3 result_normal;
	float3 result_tangent;
	if (has_skinned)
	{
		Skinned(pos.xyz, N, T.xyz, blend_weights, blend_indices, result_pos.xyz, result_normal, result_tangent);
		result_normal = normalize(result_normal);
		result_tangent = normalize(result_tangent);
	}
	else
	{
		result_pos = pos.xyz;
		result_normal = N;
		result_tangent = T.xyz;
	}
	float3 result_binormal = cross(result_normal, result_tangent) * T.w;

	output.Pos = result_pos;
	output.Texcoord0 = texcoord0;
	output.Normal = result_normal;
	output.Tangent = result_tangent;
	output.Binormal = result_binormal;

	return output;
}
		
struct HS_CONSTANT_DATA_OUTPUT
{
	// Tess factor for the FF HW block
	float edges[3]	: SV_TessFactor;
	float inside	: SV_InsideTessFactor;

	// Geometry cubic generated control points
	float3 b210	: POSITION3;
	float3 b120	: POSITION4;
	float3 b021	: POSITION5;
	float3 b012	: POSITION6;
	float3 b102	: POSITION7;
	float3 b201	: POSITION8;
	float3 b111	: CENTER;

	// Normal quadratic generated control points
	float3 n110	: NORMAL3;
	float3 n011	: NORMAL4;
	float3 n101	: NORMAL5;

	float3 t110	: TANGENT3;
	float3 t011	: TANGENT4;
	float3 t101	: TANGENT5;

	float3 bn110 : BINORMAL3;
	float3 bn011 : BINORMAL4;
	float3 bn101 : BINORMAL5;
};

//--------------------------------------------------------------------------------------
// Constant data function for the PNTrianglesHS.  This is executed once per patch.
//--------------------------------------------------------------------------------------
HS_CONSTANT_DATA_OUTPUT PNTrianglesConstantsHS(InputPatch<VS_CONTROL_POINT_OUTPUT, 3> ip)
{	
	HS_CONSTANT_DATA_OUTPUT output;
    
	if (adaptive_tess)
	{
		// Calculate the tessellation factor per edge, based on distance from camera
		float dist;
		float3 mid_point;
		// Edge 0
		mid_point = (ip[2].Pos + ip[0].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[0] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 1
		mid_point = (ip[0].Pos + ip[1].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[1] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 2
		mid_point = (ip[1].Pos + ip[2].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[2] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Inside
		output.inside = (output.edges[0] + output.edges[1] + output.edges[2]) / 3;
	}
	else
	{
		// Simply output the tessellation factors from constant space 
		// for use by the FF tessellation unit
		output.edges[0] = output.edges[1] = output.edges[2] = tess_factors.x;
		output.inside = tess_factors.y;
	}

	// Assign Positions
	float3 b003 = ip[0].Pos;
	float3 b030 = ip[1].Pos;
	float3 b300 = ip[2].Pos;
	// And Normals
	float3 n002 = ip[0].Normal;
	float3 n020 = ip[1].Normal;
	float3 n200 = ip[2].Normal;
	// And Tangents
	float3 t002 = ip[0].Tangent;
	float3 t020 = ip[1].Tangent;
	float3 t200 = ip[2].Tangent;
	// And Binormals
	float3 bn002 = ip[0].Binormal;
	float3 bn020 = ip[1].Binormal;
	float3 bn200 = ip[2].Binormal;
    
	// Compute the cubic geometry control points
	// Edge control points
	output.b210 = (2 * b003 + b030 - (dot(b030 - b003, n002) * n002)) / 3;
	output.b120 = (2 * b030 + b003 - (dot(b003 - b030, n020) * n020)) / 3;
	output.b021 = (2 * b030 + b300 - (dot(b300 - b030, n020) * n020)) / 3;
	output.b012 = (2 * b300 + b030 - (dot(b030 - b300, n200) * n200)) / 3;
	output.b102 = (2 * b300 + b003 - (dot(b003 - b300, n200) * n200)) / 3;
	output.b201 = (2 * b003 + b300 - (dot(b300 - b003, n002) * n002)) / 3;
	// Center control point
	float3 e = (output.b210 + output.b120 + output.b021 + output.b012 + output.b102 + output.b201) / 6;
	float3 v = (b003 + b030 + b300) / 3;
	output.b111 = lerp(e, v, 0.5f);

	// Compute the quadratic normal control points, and rotate into world space
	float v12 = 2 * dot(b030 - b003, n002 + n020) / dot(b030 - b003, b030 - b003);
	output.n110 = normalize(n002 + n020 - v12 * (b030 - b003));
	float v23 = 2 * dot(b300 - b030, n020 + n200) / dot(b300 - b030, b300 - b030);
	output.n011 = normalize(n020 + n200 - v23 * (b300 - b030));
	float v31 = 2 * dot(b003 - b300, n200 + n002) / dot(b003 - b300, b003 - b300);
	output.n101 = normalize(n200 + n002 - v31 * (b003 - b300));

	// Compute the quadratic tangent control points, and rotate into world space
	v12 = 2 * dot(b030 - b003, t002 + t020) / dot(b030 - b003, b030 - b003);
	output.t110 = normalize(t002 + t020 - v12 * (b030 - b003));
	v23 = 2 * dot(b300 - b030, t020 + t200) / dot(b300 - b030, b300 - b030);
	output.t011 = normalize(t020 + t200 - v23 * (b300 - b030));
	v31 = 2 * dot(b003 - b300, t200 + t002) / dot(b003 - b300, b003 - b300);
	output.t101 = normalize(t200 + t002 - v31 * (b003 - b300));

	// Compute the quadratic binormal control points, and rotate into world space
	v12 = 2 * dot(b030 - b003, bn002 + bn020) / dot(b030 - b003, b030 - b003);
	output.bn110 = normalize(bn002 + bn020 - v12 * (b030 - b003));
	v23 = 2 * dot(b300 - b030, bn020 + bn200) / dot(b300 - b030, b300 - b030);
	output.bn011 = normalize(bn020 + bn200 - v23 * (b300 - b030));
	v31 = 2 * dot(b003 - b300, bn200 + bn002) / dot(b003 - b300, b003 - b300);
	output.bn101 = normalize(bn200 + bn002 - v31 * (b003 - b300));

	return output;
}

struct HS_CONTROL_POINT
{
	float3 Pos : POSITION;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
	float3 Tangent : TEXCOORD2;
	float3 Binormal : TEXCOORD3;
};

[domain("tri")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(3)]
[patchconstantfunc("PNTrianglesConstantsHS")]
HS_CONTROL_POINT PNTrianglesHS(InputPatch<VS_CONTROL_POINT_OUTPUT, 3> p, 
										uint i : SV_OutputControlPointID)
{
	HS_CONTROL_POINT output;
	output.Pos = p[i].Pos;
	output.Texcoord0 = p[i].Texcoord0;
	output.Normal = p[i].Normal;
	output.Tangent = p[i].Tangent;
	output.Binormal = p[i].Binormal;
	return output;
}

[domain("tri")]
void PNTrianglesDS(HS_CONSTANT_DATA_OUTPUT HSConstantData, 
							float3 bc_coords : SV_DomainLocation,
							const OutputPatch<HS_CONTROL_POINT, 3> patch,

							out float2 oTex0 : TEXCOORD0,
							out float3 oL : TEXCOORD1,
							out float3 oH : TEXCOORD2,
							out float4 oPos : SV_Position)
{
	// The barycentric coordinates
	float u = bc_coords.x;
	float v = bc_coords.y;
	float w = bc_coords.z;

	// Precompute squares and squares * 3 
	float uu = u * u;
	float vv = v * v;
	float ww = w * w;
	float uu3 = uu * 3;
	float vv3 = vv * 3;
	float ww3 = ww * 3;

	// Compute position from cubic control points and barycentric coords
	float3 pos = patch[0].Pos * ww * w
					+ patch[1].Pos * uu * u
					+ patch[2].Pos * vv * v
					+ HSConstantData.b210 * ww3 * u
					+ HSConstantData.b120 * w * uu3
					+ HSConstantData.b201 * ww3 * v
					+ HSConstantData.b021 * uu3 * v
					+ HSConstantData.b102 * w * vv3
					+ HSConstantData.b012 * u * vv3
					+ HSConstantData.b111 * 6 * w * u * v;

	// Compute normal from quadratic control points and barycentric coords
	float3 normal = patch[0].Normal * ww
					+ patch[1].Normal * uu
					+ patch[2].Normal * vv
					+ HSConstantData.n110 * w * u
					+ HSConstantData.n011 * u * v
					+ HSConstantData.n101 * w * v;
	normal = normalize(normal);

	// Compute tangent from quadratic control points and barycentric coords
	float3 tangent = patch[0].Tangent * ww
					+ patch[1].Tangent * uu
					+ patch[2].Tangent * vv
					+ HSConstantData.t110 * w * u
					+ HSConstantData.t011 * u * v
					+ HSConstantData.t101 * w * v;
	tangent = normalize(tangent);

	// Compute binormal from quadratic control points and barycentric coords
	float3 binormal = patch[0].Binormal * ww
					+ patch[1].Binormal * uu
					+ patch[2].Binormal * vv
					+ HSConstantData.bn110 * w * u
					+ HSConstantData.bn011 * u * v
					+ HSConstantData.bn101 * w * v;
	binormal = normalize(binormal);

	// Linearly interpolate the texture coords
	oTex0 = patch[0].Texcoord0 * w + patch[1].Texcoord0 * u + patch[2].Texcoord0 * v;

	// Transform model position with view-projection matrix
	oPos = mul(float4(pos, 1), worldviewproj);

	float3x3 obj2tan;
	obj2tan[0] = tangent;
	obj2tan[1] = binormal;
	obj2tan[2] = normal;

	float3 L = light_pos - pos;
	float3 V = eye_pos - pos;
	float3 H = normalize(L) + normalize(V);

	oL = mul(obj2tan, L);
	oH = mul(obj2tan, H);
}
		]]>
	</shader>

	<technique name="LightingLineSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>


	<parameter type="buffer" elem_type="float4" name="skinned_pos_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_normal_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_tangent_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_binormal_buf"/>
	<parameter type="buffer" elem_type="uint" name="index_buf"/>
	<parameter type="int" name="start_index_loc"/>
	<parameter type="int" name="base_vertex_loc"/>

	<shader type="vertex_shader" version="4">
		<![CDATA[
void SkinnedStreamOutVS(float3 pos : POSITION,
					float2 texcoord0 : TEXCOORD0,
					float3 N : NORMAL,
					float4 T : Tangent,
					float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
					float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
					float4 blend_indices_f : BLENDINDICES,
#else
					int4 blend_indices : BLENDINDICES,
#endif
#endif

					out float4 oPosOS : SV_Position,
					out float4 oNormal : TEXCOORD0,
					out float4 oTangent : TEXCOORD1,
					out float4 oBinormal : TEXCOORD2)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	N = N * 2 - 1;
	T = T * 2 - 1;
	
	float3 result_pos;
	float3 result_normal;
	float3 result_tangent;
	if (has_skinned)
	{
		Skinned(pos.xyz, N, T.xyz, blend_weights, blend_indices, result_pos.xyz, result_normal, result_tangent);
		result_normal = normalize(result_normal);
		result_tangent = normalize(result_tangent);
	}
	else
	{
		result_pos = pos.xyz;
		result_normal = N;
		result_tangent = T.xyz;
	}
	float3 result_binormal = cross(result_normal, result_tangent) * T.w;

	oPosOS = float4(result_pos, texcoord0.x);
	oNormal = float4(result_normal, texcoord0.y);
	oTangent = float4(result_tangent, 0);
	oBinormal = float4(result_binormal, 0);
}

void InstTessPNTrianglesVS(float2 barycentric : TEXCOORD1,

					uint instance_id : SV_InstanceID,
					
					out float2 oTex0 : TEXCOORD0,
					out float3 oL : TEXCOORD1,
					out float3 oH : TEXCOORD2,
					out float4 oPos : SV_Position)
{
	uint index0 = index_buf.Load(start_index_loc + instance_id * 3 + 0);
	float4 pos_os0 = skinned_pos_buf.Load(index0);
	float4 normal0 = skinned_normal_buf.Load(index0);
	float4 tangent0 = skinned_tangent_buf.Load(index0);
	float4 binormal0 = skinned_binormal_buf.Load(index0);
	uint index1 = index_buf.Load(start_index_loc + instance_id * 3 + 1);
	float4 pos_os1 = skinned_pos_buf.Load(index1);
	float4 normal1 = skinned_normal_buf.Load(index1);
	float4 tangent1 = skinned_tangent_buf.Load(index1);
	float4 binormal1 = skinned_binormal_buf.Load(index1);
	uint index2 = index_buf.Load(start_index_loc + instance_id * 3 + 2);
	float4 pos_os2 = skinned_pos_buf.Load(index2);
	float4 normal2 = skinned_normal_buf.Load(index2);
	float4 tangent2 = skinned_tangent_buf.Load(index2);
	float4 binormal2 = skinned_binormal_buf.Load(index2);
	
	// Assign Positions
	float3 b003 = pos_os0.xyz;
	float3 b030 = pos_os1.xyz;
	float3 b300 = pos_os2.xyz;
	// And Normals
	float3 n002 = normal0.xyz;
	float3 n020 = normal1.xyz;
	float3 n200 = normal2.xyz;
	// And Tangents
	float3 t002 = tangent0.xyz;
	float3 t020 = tangent1.xyz;
	float3 t200 = tangent2.xyz;
	// And Binormals
	float3 bn002 = binormal0.xyz;
	float3 bn020 = binormal1.xyz;
	float3 bn200 = binormal2.xyz;
    
	// Compute the cubic geometry control points
	// Edge control points
	float3 b210 = (2 * b003 + b030 - (dot(b030 - b003, n002) * n002)) / 3;
	float3 b120 = (2 * b030 + b003 - (dot(b003 - b030, n020) * n020)) / 3;
	float3 b021 = (2 * b030 + b300 - (dot(b300 - b030, n020) * n020)) / 3;
	float3 b012 = (2 * b300 + b030 - (dot(b030 - b300, n200) * n200)) / 3;
	float3 b102 = (2 * b300 + b003 - (dot(b003 - b300, n200) * n200)) / 3;
	float3 b201 = (2 * b003 + b300 - (dot(b300 - b003, n002) * n002)) / 3;
	// Center control point
	float3 e = (b210 + b120 + b021 + b012 + b102 + b201) / 6;
	float3 v = (b003 + b030 + b300) / 3;
	float3 b111 = lerp(e, v, 0.5f);

	// Compute the quadratic normal control points, and rotate into world space
	float v12 = 2 * dot(b030 - b003, n002 + n020) / dot(b030 - b003, b030 - b003);
	float3 n110 = normalize(n002 + n020 - v12 * (b030 - b003));
	float v23 = 2 * dot(b300 - b030, n020 + n200) / dot(b300 - b030, b300 - b030);
	float3 n011 = normalize(n020 + n200 - v23 * (b300 - b030));
	float v31 = 2 * dot(b003 - b300, n200 + n002) / dot(b003 - b300, b003 - b300);
	float3 n101 = normalize(n200 + n002 - v31 * (b003 - b300));

	// Compute the quadratic tangent control points, and rotate into world space
	v12 = 2 * dot(b030 - b003, t002 + t020) / dot(b030 - b003, b030 - b003);
	float3 t110 = normalize(t002 + t020 - v12 * (b030 - b003));
	v23 = 2 * dot(b300 - b030, t020 + t200) / dot(b300 - b030, b300 - b030);
	float3 t011 = normalize(t020 + t200 - v23 * (b300 - b030));
	v31 = 2 * dot(b003 - b300, t200 + t002) / dot(b003 - b300, b003 - b300);
	float3 t101 = normalize(t200 + t002 - v31 * (b003 - b300));

	// Compute the quadratic binormal control points, and rotate into world space
	v12 = 2 * dot(b030 - b003, bn002 + bn020) / dot(b030 - b003, b030 - b003);
	float3 bn110 = normalize(bn002 + bn020 - v12 * (b030 - b003));
	v23 = 2 * dot(b300 - b030, bn020 + bn200) / dot(b300 - b030, b300 - b030);
	float3 bn011 = normalize(bn020 + bn200 - v23 * (b300 - b030));
	v31 = 2 * dot(b003 - b300, bn200 + bn002) / dot(b003 - b300, b003 - b300);
	float3 bn101 = normalize(bn200 + bn002 - v31 * (b003 - b300));

	float3 pos, normal, tangent, binormal;
	{
		// The barycentric coordinates
		float u = barycentric.x;
		float v = barycentric.y;
		float w = 1 - barycentric.x - barycentric.y;

		// Precompute squares and squares * 3 
		float uu = u * u;
		float vv = v * v;
		float ww = w * w;
		float uu3 = uu * 3;
		float vv3 = vv * 3;
		float ww3 = ww * 3;

		// Compute position from cubic control points and barycentric coords
		pos = pos_os0.xyz * ww * w
						+ pos_os1.xyz * uu * u
						+ pos_os2.xyz * vv * v
						+ b210 * ww3 * u
						+ b120 * w * uu3
						+ b201 * ww3 * v
						+ b021 * uu3 * v
						+ b102 * w * vv3
						+ b012 * u * vv3
						+ b111 * 6 * w * u * v;

		// Compute normal from quadratic control points and barycentric coords
		normal = normal0.xyz * ww
						+ normal1.xyz * uu
						+ normal2.xyz * vv
						+ n110 * w * u
						+ n011 * u * v
						+ n101 * w * v;
		normal = normalize(normal);

		// Compute tangent from quadratic control points and barycentric coords
		tangent = tangent0.xyz * ww
						+ tangent1.xyz * uu
						+ tangent2.xyz * vv
						+ t110 * w * u
						+ t011 * u * v
						+ t101 * w * v;
		tangent = normalize(tangent);

		// Compute binormal from quadratic control points and barycentric coords
		binormal = binormal0.xyz * ww
						+ binormal1.xyz * uu
						+ binormal2.xyz * vv
						+ bn110 * w * u	
						+ bn011 * u * v
						+ bn101 * w * v;
		binormal = normalize(binormal);
	
		oTex0 = float2(pos_os0.w, normal0.w) * w + float2(pos_os1.w, normal1.w) * u + float2(pos_os2.w, normal2.w) * v;
	}

	oPos = mul(float4(pos, 1), worldviewproj);

	float3x3 obj2tan;
	obj2tan[0] = tangent;
	obj2tan[1] = binormal;
	obj2tan[2] = normal;

	float3 L = light_pos - pos;
	float3 V = eye_pos - pos;
	float3 H = normalize(L) + normalize(V);

	oL = mul(obj2tan, L);
	oH = mul(obj2tan, H);
}
		]]>
	</shader>

	<technique name="SkinnedStreamOut">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="SkinnedStreamOutVS()">
				<stream_output>
					<slot usage="POSITION" component="xyzw"/>
					<slot usage="TEXCOORD" usage_index="0" component="xyzw"/>
					<slot usage="TEXCOORD" usage_index="1" component="xyzw"/>
					<slot usage="TEXCOORD" usage_index="2" component="xyzw"/>
				</stream_output>
			</state>
		</pass>
	</technique>

	<technique name="LightingLineSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>
</effect>
