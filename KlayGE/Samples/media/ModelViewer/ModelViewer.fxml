<?xml version='1.0'?>

<effect>
	<include name="util.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="Quaternion.fxml"/>

	<parameter type="float4" name="joint_reals" array_size="NUM_JOINTS"/>
	<parameter type="float4" name="joint_duals" array_size="NUM_JOINTS"/>

	<parameter type="float4x4" name="worldviewproj" semantic="WORLDVIEWPROJECTION"/>
	<parameter type="float3" name="light_pos"/>
	<parameter type="float3" name="eye_pos"/>

	<parameter type="int" name="has_skinned"/>
	<parameter type="int" name="has_normal_map"/>
	<parameter type="int" name="has_opacity_map"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float4" name="ambient_clr"/>
	<parameter type="float4" name="diffuse_clr"/>
	<parameter type="float4" name="specular_clr"/>
	<parameter type="float4" name="emit_clr"/>
	<parameter type="float" name="opacity_clr"/>

	<parameter type="float" name="specular_level"/>
	<parameter type="float" name="shininess"/>
	
	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="texture2D" name="normal_tex"/>
	<parameter type="texture2D" name="specular_tex"/>
	<parameter type="texture2D" name="emit_tex"/>

	<cbuffer name="less_freq">
		<parameter type="int" name="vertex_usage"/>
		<parameter type="int" name="vertex_usage_index"/>
		<parameter type="int" name="texture_slot"/>
	</cbuffer>

	<shader>
		<![CDATA[
void Skinned(float3 pos,
			float3 normal,
			float3 tangent,
			float4 blend_weights,
			int4 blend_indices,
			out float3 result_pos,
			out float3 result_normal,
			out float3 result_tangent)
{
	float4 dp0 = joint_reals[blend_indices[0]];
	
	float4 blend_real = 0;
	float4 blend_dual = 0;
	for (int i = 0; i < 4; ++ i)
	{
		float4 joint_real = joint_reals[blend_indices[i]];
		float4 joint_dual = joint_duals[blend_indices[i]];

		float weight = blend_weights[i];
		
		if (dot(dp0, joint_real) < 0)
		{
			joint_real = -joint_real;
			joint_dual = -joint_dual;
		}

		blend_real += joint_real * weight;
		blend_dual += joint_dual * weight;
	}

	float inv_len = 1 / length(blend_real);
	blend_real *= inv_len;
	blend_dual *= inv_len;

	result_pos = pos + 2 * cross(blend_real.xyz, cross(blend_real.xyz, pos) + blend_real.w * pos);
	float3 trans = 2 * (blend_real.w * blend_dual.xyz - blend_dual.w * blend_real.xyz + cross(blend_real.xyz, blend_dual.xyz));
	result_pos += trans;

	result_normal = normal + 2 * cross(blend_real.xyz, cross(blend_real.xyz, normal) + blend_real.w * normal);
	result_tangent = tangent + 2 * cross(blend_real.xyz, cross(blend_real.xyz, tangent) + blend_real.w * tangent);
}

void CalcMesh(float2 tex0,
				float4 pos,
				float4 blend_weights,
				int4 blend_indices,
				float3 N,
				float4 T,

				out float2 oTex,
				out float3 oPos,
				out float3 oNormal,
				out float3 oTangent,
				out float3 oBinormal)
{
	N = N * 2 - 1;
	T = T * 2 - 1;
	
	if (has_skinned)
	{
		Skinned(pos.xyz, N, T.xyz, blend_weights, blend_indices, oPos, oNormal, oTangent);
	}
	else
	{
		oPos = pos.xyz;
		oTangent = T.xyz;
		oNormal = N;
	}
	oNormal = normalize(oNormal);
	oTangent = normalize(oTangent);
	oBinormal = cross(oNormal, oTangent) * T.w;

	oTex = tex0;
}

void CalcPosLH(float3 pos,
				float3x3 obj2tan,
				out float4 oPos,
				out float3 oL,
				out float3 oH)
{
	oPos = mul(float4(pos, 1), worldviewproj);

	float3 L = light_pos - pos;
	float3 V = eye_pos - pos;
	float3 H = normalize(L) + normalize(V);

	oL = mul(obj2tan, L);
	oH = mul(obj2tan, H);
}

float4 VisualizeVertex(float3 pos, float3 tangent, float3 binormal, float3 normal,
						float4 blend_weights, int4 blend_indices, float2 tex)
{
	float4 oClr;
	if (0 == vertex_usage)
	{
		oClr = float4(pos, 1);
	}
	else if (1 == vertex_usage)
	{
		oClr = float4(normal / 2 + 0.5f, 1);
	}
	else if (4 == vertex_usage)
	{
		oClr = blend_weights;
	}
	else if (5 == vertex_usage)
	{
		oClr = blend_indices / 255.0f;
	}
	else if (6 == vertex_usage)
	{
		oClr = float4(tex, 0, 1);
	}
	else if (7 == vertex_usage)
	{
		oClr = float4(tangent / 2 + 0.5f, 1);
	}
	else// if (8 == vertex_usage)
	{
		oClr = float4(binormal / 2 + 0.5f, 1);
	}

	return oClr;
}



void MeshVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				int4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float2 oTex0 : TEXCOORD0,
				out float3 oL	: TEXCOORD1,	// in tangent space
				out float3 oH	: TEXCOORD2,	// in tangent space
				out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos;
	float3x3 obj2tan;
	CalcMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				oTex0, result_pos,
				obj2tan[2], obj2tan[0], obj2tan[1]);

	CalcPosLH(result_pos, obj2tan,
				oPos, oL, oH);
}

float4 LightingPS(float2 uv : TEXCOORD0,
				float3 L	: TEXCOORD1,
				float3 H	: TEXCOORD2) : SV_Target
{
	float3 normal;
	if (has_normal_map)
	{
		normal = decompress_normal(normal_tex.Sample(linear_sampler, uv)).rgb;
	}
	else
	{
		normal = float3(0, 0, 1);
	}

	float3 c_diff, c_spec, emit;
	float opacity;
	if (diffuse_clr.a > 0.5f)
	{
		c_diff = diffuse_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		c_diff = diffuse_clr.rgb;
	}
	if (specular_clr.a > 0.5f)
	{
		c_spec = specular_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		c_spec = specular_level;
	}
	if (emit_clr.a > 0.5f)
	{
		emit = emit_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		emit = emit_clr.rgb;
	}
	if (has_opacity_map)
	{
		opacity = diffuse_tex.Sample(linear_sampler, uv).a;
	}
	else
	{
		opacity = opacity_clr;
	}
	
	float3 clr = ambient_clr.rgb * c_diff + emit;

	float3 light_vec = normalize(L);
	float3 halfway = normalize(H);
	clr += calc_brdf(c_diff, c_spec, shininess, light_vec, halfway, normal);

	return float4(clr, opacity);
}

void VisualizeVertexVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				int4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float4 oClr : COLOR,
				out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos;
	float3x3 obj2tan;
	float2 oTex;
	CalcMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				oTex, result_pos,
				obj2tan[2], obj2tan[0], obj2tan[1]);

	oPos = mul(float4(result_pos, 1), worldviewproj);
	oClr = VisualizeVertex(result_pos, obj2tan[0], obj2tan[1], obj2tan[2], blend_weights, blend_indices, oTex);
}

float4 VisualizeVertexPS(float4 clr : COLOR) : SV_Target
{
	return clr;
}

float4 VisualizeTexturePS(float2 tex0 : TEXCOORD0) : SV_Target
{
	if (0 == texture_slot)
	{
		return diffuse_tex.Sample(linear_sampler, tex0);
	}
	else if (1 == texture_slot)
	{
		return specular_tex.Sample(linear_sampler, tex0);
	}
	else if (2 == texture_slot)
	{
		return float4(decompress_normal(normal_tex.Sample(linear_sampler, tex0)).rgb, 1);
	}
	else if (3 == texture_slot)
	{
		return emit_tex.Sample(linear_sampler, tex0);
	}
	else //if (4 == texture_slot)
	{
		return diffuse_tex.Sample(linear_sampler, tex0).a;
	}
}
		]]>
	</shader>

	<technique name="LightingLineTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>


	<parameter type="bool" name="adaptive_tess"/>
	<parameter type="float4" name="tess_factors"/>

	<shader>
		<![CDATA[
void CalcPNControlPoints(float3 pos0, float3 pos1, float3 pos2,
				float3 normal0, float3 normal1, float3 normal2,
				
				out float3 b210, out float3 b120, out float3 b021,
				out float3 b012, out float3 b102, out float3 b201, out float3 b111,
				out float3 n110, out float3 n011, out float3 n101)
{
	// Assign Positions
	float3 b003 = pos0;
	float3 b030 = pos1;
	float3 b300 = pos2;
	// And Normals
	float3 n002 = normal0;
	float3 n020 = normal1;
	float3 n200 = normal2;
    
	// Compute the cubic geometry control points
	// Edge control points
	b210 = (2 * b003 + b030 - (dot(b030 - b003, n002) * n002)) / 3;
	b120 = (2 * b030 + b003 - (dot(b003 - b030, n020) * n020)) / 3;
	b021 = (2 * b030 + b300 - (dot(b300 - b030, n020) * n020)) / 3;
	b012 = (2 * b300 + b030 - (dot(b030 - b300, n200) * n200)) / 3;
	b102 = (2 * b300 + b003 - (dot(b003 - b300, n200) * n200)) / 3;
	b201 = (2 * b003 + b300 - (dot(b300 - b003, n002) * n002)) / 3;
	// Center control point
	float3 e = (b210 + b120 + b021 + b012 + b102 + b201) / 6;
	float3 v = (b003 + b030 + b300) / 3;
	b111 = lerp(e, v, 0.5f);

	// Compute the quadratic normal control points, and rotate into world space
	float v12 = 2 * dot(b030 - b003, n002 + n020) / dot(b030 - b003, b030 - b003);
	n110 = normalize(n002 + n020 - v12 * (b030 - b003));
	float v23 = 2 * dot(b300 - b030, n020 + n200) / dot(b300 - b030, b300 - b030);
	n011 = normalize(n020 + n200 - v23 * (b300 - b030));
	float v31 = 2 * dot(b003 - b300, n200 + n002) / dot(b003 - b300, b003 - b300);
	n101 = normalize(n200 + n002 - v31 * (b003 - b300));
}

void InterpolatePNAttrs(float3 bc_coords,
				float3 pos0, float3 pos1, float3 pos2,
				float2 tex0, float2 tex1, float2 tex2,
				float3 normal0, float3 normal1, float3 normal2,
				float3 tangent0, float3 tangent1, float3 tangent2,
				float3 binormal0, float3 binormal1, float3 binormal2,
				float3 b210, float3 b120, float3 b021,
				float3 b012, float3 b102, float3 b201, float3 b111,
				float3 n110, float3 n011, float3 n101,
				
				out float3 oPos, out float2 oTex,
				out float3 oNormal, out float3 oTangent, out float3 oBinormal)
{
	// The barycentric coordinates
	float u = bc_coords.x;
	float v = bc_coords.y;
	float w = bc_coords.z;

	// Precompute squares and squares * 3 
	float uu = u * u;
	float vv = v * v;
	float ww = w * w;
	float uu3 = uu * 3;
	float vv3 = vv * 3;
	float ww3 = ww * 3;

	// Compute position from cubic control points and barycentric coords
	oPos = pos0 * ww * w
					+ pos1 * uu * u
					+ pos2 * vv * v
					+ b210 * ww3 * u
					+ b120 * w * uu3
					+ b201 * ww3 * v
					+ b021 * uu3 * v
					+ b102 * w * vv3
					+ b012 * u * vv3
					+ b111 * 6 * w * u * v;

	// Compute normal from quadratic control points and barycentric coords
	oNormal = normal0 * ww
					+ normal1 * uu
					+ normal2 * vv
					+ n110 * w * u
					+ n011 * u * v
					+ n101 * w * v;
	oNormal = normalize(oNormal);

	// Linearly interpolate the tangent
	oTangent = tangent0 * w
					+ tangent1 * u
					+ tangent2 * v;
	oTangent = normalize(oTangent);

	// Linearly interpolate the binormal
	oBinormal = binormal0 * w
					+ binormal1 * u
					+ binormal2 * v;
	oBinormal = normalize(oBinormal);

	// Linearly interpolate the texture coords
	oTex = tex0 * w + tex1 * u + tex2 * v;
}
		]]>
	</shader>

	<shader version="5">
		<![CDATA[
struct VS_CONTROL_POINT_OUTPUT
{
	float3 Pos : POSITION;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
	float3 Tangent : TEXCOORD2;
	float3 Binormal : TEXCOORD3;
};

VS_CONTROL_POINT_OUTPUT PNTrianglesVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				int4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,
				float4 T	: TANGENT)
{
	VS_CONTROL_POINT_OUTPUT output;
	
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	CalcMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				output.Texcoord0, output.Pos,
				output.Normal, output.Tangent, output.Binormal);

	return output;
}
		
struct HS_CONSTANT_DATA_OUTPUT
{
	// Tess factor for the FF HW block
	float edges[3]	: SV_TessFactor;
	float inside	: SV_InsideTessFactor;

	// Geometry cubic generated control points
	float3 b210	: POSITION3;
	float3 b120	: POSITION4;
	float3 b021	: POSITION5;
	float3 b012	: POSITION6;
	float3 b102	: POSITION7;
	float3 b201	: POSITION8;
	float3 b111	: CENTER;

	// Normal quadratic generated control points
	float3 n110	: NORMAL3;
	float3 n011	: NORMAL4;
	float3 n101	: NORMAL5;
};

//--------------------------------------------------------------------------------------
// Constant data function for the PNTrianglesHS.  This is executed once per patch.
//--------------------------------------------------------------------------------------
HS_CONSTANT_DATA_OUTPUT PNTrianglesConstantsHS(InputPatch<VS_CONTROL_POINT_OUTPUT, 3> ip)
{	
	HS_CONSTANT_DATA_OUTPUT output;
    
	if (adaptive_tess)
	{
		// Calculate the tessellation factor per edge, based on distance from camera
		float dist;
		float3 mid_point;
		// Edge 0
		mid_point = (ip[2].Pos + ip[0].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[0] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 1
		mid_point = (ip[0].Pos + ip[1].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[1] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 2
		mid_point = (ip[1].Pos + ip[2].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[2] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Inside
		output.inside = (output.edges[0] + output.edges[1] + output.edges[2]) / 3;
	}
	else
	{
		// Simply output the tessellation factors from constant space 
		// for use by the FF tessellation unit
		output.edges[0] = output.edges[1] = output.edges[2] = tess_factors.x;
		output.inside = tess_factors.y;
	}

	CalcPNControlPoints(ip[0].Pos, ip[1].Pos, ip[2].Pos,
				ip[0].Normal, ip[1].Normal, ip[2].Normal,				
				output.b210, output.b120, output.b021,
				output.b012, output.b102, output.b201, output.b111,
				output.n110, output.n011, output.n101);

	return output;
}

struct HS_CONTROL_POINT
{
	float3 Pos : POSITION;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
	float3 Tangent : TEXCOORD2;
	float3 Binormal : TEXCOORD3;
};

[domain("tri")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(3)]
[patchconstantfunc("PNTrianglesConstantsHS")]
HS_CONTROL_POINT PNTrianglesHS(InputPatch<VS_CONTROL_POINT_OUTPUT, 3> p, 
										uint i : SV_OutputControlPointID)
{
	HS_CONTROL_POINT output;
	output.Pos = p[i].Pos;
	output.Texcoord0 = p[i].Texcoord0;
	output.Normal = p[i].Normal;
	output.Tangent = p[i].Tangent;
	output.Binormal = p[i].Binormal;
	return output;
}

[domain("tri")]
void PNTrianglesDS(HS_CONSTANT_DATA_OUTPUT HSConstantData, 
							float3 bc_coords : SV_DomainLocation,
							const OutputPatch<HS_CONTROL_POINT, 3> patch,

							out float2 oTex0 : TEXCOORD0,
							out float3 oL : TEXCOORD1,
							out float3 oH : TEXCOORD2,
							out float4 oPos : SV_Position)
{
	float3 pos;
	float3x3 obj2tan;
	InterpolatePNAttrs(bc_coords,
				patch[0].Pos, patch[1].Pos, patch[2].Pos,
				patch[0].Texcoord0, patch[1].Texcoord0, patch[2].Texcoord0,
				patch[0].Normal, patch[1].Normal, patch[2].Normal,
				patch[0].Tangent, patch[1].Tangent, patch[2].Tangent,
				patch[0].Binormal, patch[1].Binormal, patch[2].Binormal,

				HSConstantData.b210, HSConstantData.b120, HSConstantData.b021,
				HSConstantData.b012, HSConstantData.b102, HSConstantData.b201, HSConstantData.b111,
				HSConstantData.n110, HSConstantData.n011, HSConstantData.n101,
				pos, oTex0,
				obj2tan[2], obj2tan[0], obj2tan[1]);

	CalcPosLH(pos, obj2tan,
				oPos, oL, oH);
}
		]]>
	</shader>

	<technique name="LightingLineSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>


	<parameter type="buffer" elem_type="float4" name="skinned_pos_buf"/>
	<parameter type="buffer" elem_type="float2" name="skinned_tex_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_normal_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_tangent_buf"/>
	<parameter type="buffer" elem_type="uint" name="index_buf"/>
	<parameter type="int" name="start_index_loc"/>
	<parameter type="int" name="base_vertex_loc"/>

	<shader type="vertex_shader" version="4">
		<![CDATA[
void SkinnedStreamOutVS(float3 pos : POSITION,
					float2 texcoord0 : TEXCOORD0,
					float3 N : NORMAL,
					float4 T : Tangent,
					float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
					float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
					float4 blend_indices_f : BLENDINDICES,
#else
					int4 blend_indices : BLENDINDICES,
#endif
#endif

					out float4 oPosOS : SV_Position,
					out float2 oTex0 : TEXCOORD0,
					out float4 oNormal : NORMAL,
					out float4 oTangent : TANGENT)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos, result_normal, result_tangent, result_binormal;
	CalcMesh(texcoord0, float4(pos, 1),
				blend_weights, blend_indices,
				N, T,
				oTex0, result_pos,
				result_normal, result_tangent, result_binormal);

	oPosOS = float4(result_pos, 1);
	oNormal = float4(result_normal / 2 + 0.5f, 0);
	oTangent = float4(result_tangent / 2 + 0.5f, T.w);
}


void CalcInstTessPNTriangles(float2 barycentric,
					uint instance_id,
					out float2 oTex0,
					out float3 oPos,
					out float3 oNormal,
					out float3 oTangent,
					out float3 oBinormal)
{
	uint index0 = index_buf.Load(instance_id * 3 + 0);
	float3 pos_os0 = skinned_pos_buf.Load(index0).xyz;
	float2 tex0 = skinned_tex_buf.Load(index0).xy;
	float3 normal0 = skinned_normal_buf.Load(index0).xyz * 2 - 1;
	float4 tangent0 = skinned_tangent_buf.Load(index0) * 2 - 1;
	float3 binormal0 = cross(normal0, tangent0.xyz) * tangent0.w;
	uint index1 = index_buf.Load(instance_id * 3 + 1);
	float3 pos_os1 = skinned_pos_buf.Load(index1).xyz;
	float2 tex1 = skinned_tex_buf.Load(index1).xy;
	float3 normal1 = skinned_normal_buf.Load(index1).xyz * 2 - 1;
	float4 tangent1 = skinned_tangent_buf.Load(index1) * 2 - 1;
	float3 binormal1 = cross(normal1.xyz, tangent1.xyz) * tangent1.w;
	uint index2 = index_buf.Load(instance_id * 3 + 2);
	float3 pos_os2 = skinned_pos_buf.Load(index2).xyz;
	float2 tex2 = skinned_tex_buf.Load(index2).xy;
	float3 normal2 = skinned_normal_buf.Load(index2).xyz * 2 - 1;
	float4 tangent2 = skinned_tangent_buf.Load(index2) * 2 - 1;
	float3 binormal2 = cross(normal2.xyz, tangent2.xyz) * tangent2.w;

	float3 b210, b120, b021, b012, b102, b201, b111;
	float3 n110, n011, n101;
	CalcPNControlPoints(pos_os0.xyz, pos_os1.xyz, pos_os2.xyz,
				normal0, normal1, normal2,
				b210, b120, b021,
				b012, b102, b201, b111,
				n110, n011, n101);

	InterpolatePNAttrs(float3(barycentric, 1 - barycentric.x - barycentric.y),
				pos_os0, pos_os1, pos_os2,
				tex0, tex1, tex2,
				normal0, normal1, normal2,
				tangent0.xyz, tangent1.xyz, tangent2.xyz,
				binormal0, binormal1, binormal2,
				b210, b120, b021,
				b012, b102, b201, b111,
				n110, n011, n101,
				oPos, oTex0,
				oNormal, oTangent, oBinormal);
}

void InstTessPNTrianglesVS(float2 barycentric : TEXCOORD1,

					uint instance_id : SV_InstanceID,
					
					out float2 oTex0 : TEXCOORD0,
					out float3 oL : TEXCOORD1,
					out float3 oH : TEXCOORD2,
					out float4 oPos : SV_Position)
{
	float3 pos;
	float3x3 obj2tan;
	CalcInstTessPNTriangles(barycentric, instance_id,
					oTex0, pos, obj2tan[2], obj2tan[0], obj2tan[1]);

	CalcPosLH(pos, obj2tan,
				oPos, oL, oH);
}

void InstTessPNTrianglesVisualizeVertexVS(float2 barycentric : TEXCOORD1,

					uint instance_id : SV_InstanceID,
					
					out float4 oClr : COLOR,
					out float4 oPos : SV_Position)
{
	float2 tex0;
	float3 pos, normal, tangent, binormal;
	CalcInstTessPNTriangles(barycentric, instance_id,
					tex0, pos, normal, tangent, binormal);

	oPos = mul(float4(pos, 1), worldviewproj);
	oClr = VisualizeVertex(pos, tangent, binormal, normal, 0, 0, tex0);
}
		]]>
	</shader>

	<technique name="SkinnedStreamOut">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="SkinnedStreamOutVS()">
				<stream_output>
					<slot usage="POSITION" component="xyzw"/>
					<slot usage="TEXCOORD" usage_index="0" component="xy"/>
					<slot usage="NORMAL" component="xyzw"/>
					<slot usage="TANGENT" component="xyzw"/>
				</stream_output>
			</state>
		</pass>
	</technique>

	<technique name="LightingLineSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessPNTrianglesVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>
</effect>
