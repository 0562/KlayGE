<?xml version='1.0'?>

<effect>
	<include name="util.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="Quaternion.fxml"/>

	<parameter type="float4" name="joint_reals" array_size="NUM_JOINTS"/>
	<parameter type="float4" name="joint_duals" array_size="NUM_JOINTS"/>

	<parameter type="float4x4" name="worldviewproj" semantic="WORLDVIEWPROJECTION"/>
	<parameter type="float3" name="light_pos"/>
	<parameter type="float3" name="eye_pos"/>

	<parameter type="int" name="has_skinned"/>
	<parameter type="int" name="has_normal_map"/>
	<parameter type="int" name="has_opacity_map"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float4" name="ambient_clr"/>
	<parameter type="float4" name="diffuse_clr"/>
	<parameter type="float4" name="specular_clr"/>
	<parameter type="float4" name="emit_clr"/>
	<parameter type="float" name="opacity_clr"/>

	<parameter type="float" name="specular_level"/>
	<parameter type="float" name="shininess"/>
	
	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="texture2D" name="normal_tex"/>
	<parameter type="texture2D" name="specular_tex"/>
	<parameter type="texture2D" name="emit_tex"/>

	<cbuffer name="less_freq">
		<parameter type="int" name="vertex_usage"/>
		<parameter type="int" name="vertex_usage_index"/>
		<parameter type="int" name="texture_slot"/>
	</cbuffer>

	<shader>
		<![CDATA[
void Skinned(float3 pos,
			float3 normal,
			float3 tangent,
			float4 blend_weights,
			int4 blend_indices,
			out float3 result_pos,
			out float3 result_normal,
			out float3 result_tangent)
{
	float4 dp0 = joint_reals[blend_indices[0]];
	
	float4 blend_real = 0;
	float4 blend_dual = 0;
	for (int i = 0; i < 4; ++ i)
	{
		float4 joint_real = joint_reals[blend_indices[i]];
		float4 joint_dual = joint_duals[blend_indices[i]];

		float weight = blend_weights[i];
		
		if (dot(dp0, joint_real) < 0)
		{
			joint_real = -joint_real;
			joint_dual = -joint_dual;
		}

		blend_real += joint_real * weight;
		blend_dual += joint_dual * weight;
	}

	float inv_len = 1 / length(blend_real);
	blend_real *= inv_len;
	blend_dual *= inv_len;

	result_pos = pos + 2 * cross(blend_real.xyz, cross(blend_real.xyz, pos) + blend_real.w * pos);
	float3 trans = 2 * (blend_real.w * blend_dual.xyz - blend_dual.w * blend_real.xyz + cross(blend_real.xyz, blend_dual.xyz));
	result_pos += trans;

	result_normal = normal + 2 * cross(blend_real.xyz, cross(blend_real.xyz, normal) + blend_real.w * normal);
	result_tangent = tangent + 2 * cross(blend_real.xyz, cross(blend_real.xyz, tangent) + blend_real.w * tangent);
}

void CalcMesh(float2 tex0,
				float4 pos,
				float4 blend_weights,
				int4 blend_indices,
				float3 N,
				float4 T,

				out float2 oTex,
				out float3 oPos,
				out float3 oNormal,
				out float3 oTangent,
				out float3 oBinormal)
{
	N = N * 2 - 1;
	T = T * 2 - 1;
	
	if (has_skinned)
	{
		Skinned(pos.xyz, N, T.xyz, blend_weights, blend_indices, oPos, oNormal, oTangent);
	}
	else
	{
		oPos = pos.xyz;
		oTangent = T.xyz;
		oNormal = N;
	}
	oNormal = normalize(oNormal);
	oTangent = normalize(oTangent);
	oBinormal = cross(oNormal, oTangent) * T.w;

	oTex = tex0;
}

void CalcPosLH(float3 pos,
				float3x3 obj2tan,
				out float4 oPos,
				out float3 oL,
				out float3 oH)
{
	oPos = mul(float4(pos, 1), worldviewproj);

	float3 L = light_pos - pos;
	float3 V = eye_pos - pos;
	float3 H = normalize(L) + normalize(V);

	oL = mul(obj2tan, L);
	oH = mul(obj2tan, H);
}

float4 VisualizeVertex(float3 pos, float3 tangent, float3 binormal, float3 normal,
						float4 blend_weights, int4 blend_indices, float2 tex)
{
	float4 oClr;
	if (0 == vertex_usage)
	{
		oClr = float4(pos, 1);
	}
	else if (1 == vertex_usage)
	{
		oClr = float4(normal / 2 + 0.5f, 1);
	}
	else if (4 == vertex_usage)
	{
		oClr = blend_weights;
	}
	else if (5 == vertex_usage)
	{
		oClr = blend_indices / 255.0f;
	}
	else if (6 == vertex_usage)
	{
		oClr = float4(tex, 0, 1);
	}
	else if (7 == vertex_usage)
	{
		oClr = float4(tangent / 2 + 0.5f, 1);
	}
	else// if (8 == vertex_usage)
	{
		oClr = float4(binormal / 2 + 0.5f, 1);
	}

	return oClr;
}



void MeshVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				uint4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float2 oTex0 : TEXCOORD0,
				out float3 oL	: TEXCOORD1,	// in tangent space
				out float3 oH	: TEXCOORD2,	// in tangent space
				out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos;
	float3x3 obj2tan;
	CalcMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				oTex0, result_pos,
				obj2tan[2], obj2tan[0], obj2tan[1]);

	CalcPosLH(result_pos, obj2tan,
				oPos, oL, oH);
}

float4 LightingPS(float2 uv : TEXCOORD0,
				float3 L	: TEXCOORD1,
				float3 H	: TEXCOORD2) : SV_Target
{
	float3 normal;
	if (has_normal_map)
	{
		normal = decompress_normal(normal_tex.Sample(linear_sampler, uv)).rgb;
	}
	else
	{
		normal = float3(0, 0, 1);
	}

	float3 c_diff, c_spec, emit;
	float opacity;
	if (diffuse_clr.a > 0.5f)
	{
		c_diff = diffuse_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		c_diff = diffuse_clr.rgb;
	}
	if (specular_clr.a > 0.5f)
	{
		c_spec = specular_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		c_spec = specular_level;
	}
	if (emit_clr.a > 0.5f)
	{
		emit = emit_tex.Sample(linear_sampler, uv).rgb;
	}
	else
	{
		emit = emit_clr.rgb;
	}
	if (has_opacity_map)
	{
		opacity = diffuse_tex.Sample(linear_sampler, uv).a;
	}
	else
	{
		opacity = opacity_clr;
	}
	
	float3 clr = ambient_clr.rgb * c_diff + emit;

	float3 light_vec = normalize(L);
	float3 halfway = normalize(H);
	clr += calc_brdf(c_diff, c_spec, shininess, light_vec, halfway, normal);

	return float4(clr, opacity);
}

void VisualizeVertexVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				uint4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,	// in object space
				float4 T	: TANGENT,	// in object space
				
				out float4 oClr : COLOR,
				out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos;
	float3x3 obj2tan;
	float2 oTex;
	CalcMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				oTex, result_pos,
				obj2tan[2], obj2tan[0], obj2tan[1]);

	oPos = mul(float4(result_pos, 1), worldviewproj);
	oClr = VisualizeVertex(result_pos, obj2tan[0], obj2tan[1], obj2tan[2], blend_weights, blend_indices, oTex);
}

float4 VisualizeVertexPS(float4 clr : COLOR) : SV_Target
{
	return clr;
}

float4 VisualizeTexturePS(float2 tex0 : TEXCOORD0) : SV_Target
{
	if (0 == texture_slot)
	{
		return diffuse_tex.Sample(linear_sampler, tex0);
	}
	else if (1 == texture_slot)
	{
		return specular_tex.Sample(linear_sampler, tex0);
	}
	else if (2 == texture_slot)
	{
		return float4(decompress_normal(normal_tex.Sample(linear_sampler, tex0)).rgb, 1);
	}
	else if (3 == texture_slot)
	{
		return emit_tex.Sample(linear_sampler, tex0);
	}
	else //if (4 == texture_slot)
	{
		return diffuse_tex.Sample(linear_sampler, tex0).a;
	}
}
		]]>
	</shader>

	<technique name="LightingFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="MeshVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingLineTech" inherit="LightingFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="LightingLineBlendTech" inherit="LightingFillBlendTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineTech" inherit="VisualizeVertexFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineTech" inherit="VisualizeTextureFillTech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>


	<parameter type="bool" name="adaptive_tess"/>
	<parameter type="float4" name="tess_factors"/>

	<shader>
		<![CDATA[
float3 PhongProject(float3 p, float3 c, float3 n)
{
	return p - dot(p - c, n) * n;
}

void InterpolatePhongAttrs(float3 bc_coords,
				float3 pos0, float3 pos1, float3 pos2,
				float2 tex0, float2 tex1, float2 tex2,
				float3 normal0, float3 normal1, float3 normal2,
				float3 tangent0, float3 tangent1, float3 tangent2,
				float3 binormal0, float3 binormal1, float3 binormal2,
				
				out float3 oPos, out float2 oTex,
				out float3 oNormal, out float3 oTangent, out float3 oBinormal)
{
	// The barycentric coordinates
	float u = bc_coords.x;
	float v = bc_coords.y;
	float w = bc_coords.z;
	
	float alpha = 0.75f;

	float3 p = w * pos0 + u * pos1 + v * pos2;
	float3 c0 = PhongProject(p, pos0, normal0);
	float3 c1 = PhongProject(p, pos1, normal1);
	float3 c2 = PhongProject(p, pos2, normal2);
	float3 q = w * c0 + u * c1 + v * c2;
	oPos = lerp(p, q, alpha);

	// Compute normal from quadratic control points and barycentric coords
	oNormal = normal0 * w
					+ normal1 * u
					+ normal2 * v;
	oNormal = normalize(oNormal);

	// Linearly interpolate the tangent
	oTangent = tangent0 * w
					+ tangent1 * u
					+ tangent2 * v;
	oTangent = normalize(oTangent);

	// Linearly interpolate the binormal
	oBinormal = binormal0 * w
					+ binormal1 * u
					+ binormal2 * v;
	oBinormal = normalize(oBinormal);

	// Linearly interpolate the texture coords
	oTex = tex0 * w + tex1 * u + tex2 * v;
}
		]]>
	</shader>

	<shader version="5">
		<![CDATA[
struct CONTROL_POINT
{
	float3 Pos : POSITION;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
	float3 Tangent : TEXCOORD2;
	float3 Binormal : TEXCOORD3;
};

CONTROL_POINT SmoothVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
				float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
				float4 blend_indices_f : BLENDINDICES,
#else
				uint4 blend_indices : BLENDINDICES,
#endif
#endif
				float3 N	: NORMAL,
				float4 T	: TANGENT)
{
	CONTROL_POINT output;
	
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	CalcMesh(tex0, pos,
				blend_weights, blend_indices,
				N, T,
				output.Texcoord0, output.Pos,
				output.Normal, output.Tangent, output.Binormal);

	return output;
}
		
struct HS_CONSTANT_DATA_OUTPUT
{
	// Tess factor for the FF HW block
	float edges[3]	: SV_TessFactor;
	float inside	: SV_InsideTessFactor;
};

//--------------------------------------------------------------------------------------
// Constant data function for the SmoothHS.  This is executed once per patch.
//--------------------------------------------------------------------------------------
HS_CONSTANT_DATA_OUTPUT SmoothConstantsHS(InputPatch<CONTROL_POINT, 3> ip)
{	
	HS_CONSTANT_DATA_OUTPUT output;
    
	if (adaptive_tess)
	{
		// Calculate the tessellation factor per edge, based on distance from camera
		float dist;
		float3 mid_point;
		// Edge 0
		mid_point = (ip[2].Pos + ip[0].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[0] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 1
		mid_point = (ip[0].Pos + ip[1].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[1] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 2
		mid_point = (ip[1].Pos + ip[2].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[2] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Inside
		output.inside = (output.edges[0] + output.edges[1] + output.edges[2]) / 3;
	}
	else
	{
		// Simply output the tessellation factors from constant space 
		// for use by the FF tessellation unit
		output.edges[0] = output.edges[1] = output.edges[2] = tess_factors.x;
		output.inside = tess_factors.y;
	}

	return output;
}

[domain("tri")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(3)]
[patchconstantfunc("SmoothConstantsHS")]
CONTROL_POINT SmoothHS(InputPatch<CONTROL_POINT, 3> p, 
								uint i : SV_OutputControlPointID)
{
	CONTROL_POINT output;
	output.Pos = p[i].Pos;
	output.Texcoord0 = p[i].Texcoord0;
	output.Normal = p[i].Normal;
	output.Tangent = p[i].Tangent;
	output.Binormal = p[i].Binormal;
	return output;
}

[domain("tri")]
void SmoothDS(HS_CONSTANT_DATA_OUTPUT HSConstantData, 
							float3 bc_coords : SV_DomainLocation,
							const OutputPatch<CONTROL_POINT, 3> patch,

							out float2 oTex0 : TEXCOORD0,
							out float3 oL : TEXCOORD1,
							out float3 oH : TEXCOORD2,
							out float4 oPos : SV_Position)
{
	float3 pos;
	float3x3 obj2tan;
	InterpolatePhongAttrs(bc_coords,
				patch[0].Pos, patch[1].Pos, patch[2].Pos,
				patch[0].Texcoord0, patch[1].Texcoord0, patch[2].Texcoord0,
				patch[0].Normal, patch[1].Normal, patch[2].Normal,
				patch[0].Tangent, patch[1].Tangent, patch[2].Tangent,
				patch[0].Binormal, patch[1].Binormal, patch[2].Binormal,
				
				pos, oTex0,
				obj2tan[2], obj2tan[0], obj2tan[1]);

	CalcPosLH(pos, obj2tan,
				oPos, oL, oH);
}
		]]>
	</shader>

	<technique name="LightingFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="VisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="SmoothVS()"/>
			<state name="hull_shader" value="SmoothHS()"/>
			<state name="domain_shader" value="SmoothDS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingLineSmooth5Tech" inherit="LightingFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="LightingLineBlendSmooth5Tech" inherit="LightingFillBlendSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
	
	<technique name="VisualizeVertexLineSmooth5Tech" inherit="VisualizeVertexFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth5Tech" inherit="VisualizeTextureFillSmooth5Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>


	<parameter type="buffer" elem_type="float4" name="skinned_pos_buf"/>
	<parameter type="buffer" elem_type="float2" name="skinned_tex_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_normal_buf"/>
	<parameter type="buffer" elem_type="float4" name="skinned_tangent_buf"/>
	<parameter type="buffer" elem_type="uint" name="index_buf"/>
	<parameter type="int" name="start_index_loc"/>
	<parameter type="int" name="base_vertex_loc"/>

	<shader type="vertex_shader" version="4">
		<![CDATA[
void SkinnedStreamOutVS(float3 pos : POSITION,
					float2 texcoord0 : TEXCOORD0,
					float3 N : NORMAL,
					float4 T : Tangent,
					float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
					float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
					float4 blend_indices_f : BLENDINDICES,
#else
					uint4 blend_indices : BLENDINDICES,
#endif
#endif

					out float4 oPosOS : SV_Position,
					out float2 oTex0 : TEXCOORD0,
					out float4 oNormal : NORMAL,
					out float4 oTangent : TANGENT)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos, result_normal, result_tangent, result_binormal;
	CalcMesh(texcoord0, float4(pos, 1),
				blend_weights, blend_indices,
				N, T,
				oTex0, result_pos,
				result_normal, result_tangent, result_binormal);

	oPosOS = float4(result_pos, 1);
	oNormal = float4(result_normal / 2 + 0.5f, 0);
	oTangent = float4(result_tangent / 2 + 0.5f, T.w);
}


void CalcInstTessSmooth(float2 barycentric,
					uint instance_id,
					out float2 oTex0,
					out float3 oPos,
					out float3 oNormal,
					out float3 oTangent,
					out float3 oBinormal)
{
	uint index0 = index_buf.Load(instance_id * 3 + 0);
	float3 pos_os0 = skinned_pos_buf.Load(index0).xyz;
	float2 tex0 = skinned_tex_buf.Load(index0).xy;
	float3 normal0 = skinned_normal_buf.Load(index0).xyz * 2 - 1;
	float4 tangent0 = skinned_tangent_buf.Load(index0) * 2 - 1;
	float3 binormal0 = cross(normal0, tangent0.xyz) * tangent0.w;
	uint index1 = index_buf.Load(instance_id * 3 + 1);
	float3 pos_os1 = skinned_pos_buf.Load(index1).xyz;
	float2 tex1 = skinned_tex_buf.Load(index1).xy;
	float3 normal1 = skinned_normal_buf.Load(index1).xyz * 2 - 1;
	float4 tangent1 = skinned_tangent_buf.Load(index1) * 2 - 1;
	float3 binormal1 = cross(normal1.xyz, tangent1.xyz) * tangent1.w;
	uint index2 = index_buf.Load(instance_id * 3 + 2);
	float3 pos_os2 = skinned_pos_buf.Load(index2).xyz;
	float2 tex2 = skinned_tex_buf.Load(index2).xy;
	float3 normal2 = skinned_normal_buf.Load(index2).xyz * 2 - 1;
	float4 tangent2 = skinned_tangent_buf.Load(index2) * 2 - 1;
	float3 binormal2 = cross(normal2.xyz, tangent2.xyz) * tangent2.w;

	InterpolatePhongAttrs(float3(barycentric, 1 - barycentric.x - barycentric.y),
				pos_os0, pos_os1, pos_os2,
				tex0, tex1, tex2,
				normal0, normal1, normal2,
				tangent0.xyz, tangent1.xyz, tangent2.xyz,
				binormal0, binormal1, binormal2,
				
				oPos, oTex0,
				oNormal, oTangent, oBinormal);
}

void InstTessSmoothVS(float2 barycentric : TEXCOORD1,

					uint instance_id : SV_InstanceID,
					
					out float2 oTex0 : TEXCOORD0,
					out float3 oL : TEXCOORD1,
					out float3 oH : TEXCOORD2,
					out float4 oPos : SV_Position)
{
	float3 pos;
	float3x3 obj2tan;
	CalcInstTessSmooth(barycentric, instance_id,
					oTex0, pos, obj2tan[2], obj2tan[0], obj2tan[1]);

	CalcPosLH(pos, obj2tan,
				oPos, oL, oH);
}

void InstTessSmoothVisualizeVertexVS(float2 barycentric : TEXCOORD1,

					uint instance_id : SV_InstanceID,
					
					out float4 oClr : COLOR,
					out float4 oPos : SV_Position)
{
	float2 tex0;
	float3 pos, normal, tangent, binormal;
	CalcInstTessSmooth(barycentric, instance_id,
					tex0, pos, normal, tangent, binormal);

	oPos = mul(float4(pos, 1), worldviewproj);
	oClr = VisualizeVertex(pos, tangent, binormal, normal, 0, 0, tex0);
}
		]]>
	</shader>

	<technique name="SkinnedStreamOut">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="SkinnedStreamOutVS()">
				<stream_output>
					<slot usage="POSITION" component="xyzw"/>
					<slot usage="TEXCOORD" usage_index="0" component="xy"/>
					<slot usage="NORMAL" component="xyzw"/>
					<slot usage="TANGENT" component="xyzw"/>
				</stream_output>
			</state>
		</pass>
	</technique>



	<technique name="LightingFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessSmoothVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="LightingFillBlendSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>

			<state name="vertex_shader" value="InstTessSmoothVS()"/>
			<state name="pixel_shader" value="LightingPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessSmoothVisualizeVertexVS()"/>
			<state name="pixel_shader" value="VisualizeVertexPS()"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="InstTessSmoothVS()"/>
			<state name="pixel_shader" value="VisualizeTexturePS()"/>
		</pass>
	</technique>

	<technique name="LightingLineSmooth4Tech" inherit="LightingFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="LightingLineBlendSmooth4Tech" inherit="LightingFillBlendSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeVertexLineSmooth4Tech" inherit="VisualizeVertexFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>

	<technique name="VisualizeTextureLineSmooth4Tech" inherit="VisualizeTextureFillSmooth4Tech">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
		</pass>
	</technique>
</effect>
