<?xml version='1.0'?>

<effect>
	<include name="../../../RenderFX/util.fxml"/>
	<include name="../../../RenderFX/Quaternion.fxml"/>

	<parameter type="float4" name="joint_rots" array_size="64"/>
	<parameter type="float4" name="joint_poss" array_size="64"/>

	<parameter type="float4x4" name="worldviewproj" semantic="WORLDVIEWPROJECTION"/>
	<parameter type="float3" name="light_pos"/>
	<parameter type="float3" name="eye_pos"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="texture2D" name="normal_tex"/>
	<parameter type="texture2D" name="specular_tex"/>

	<shader>
		<![CDATA[
void SkinnedMeshVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float4 blend_weights : BLENDWEIGHT,
				int4 blend_indices : BLENDINDICES,
				float3 N	: NORMAL,	// in object space
				float3 T	: TANGENT,	// in object space
				
				out float2 oTex0 : TEXCOORD0,
				out float3 oL	: TEXCOORD1,	// in tangent space
				out float3 oH	: TEXCOORD2,	// in tangent space
				out float4 oPos : SV_Position)
{
	oTex0 = tex0;

	float3 result_pos = 0;
	float3x3 obj2tan = 0;
	for (int i = 0; i < 4; ++ i)
	{
		float4 joint_rot = joint_rots[blend_indices[i]];
		float4 joint_pos = joint_poss[blend_indices[i]];
		float weight = blend_weights[i];

		result_pos += (mul_quat(pos.xyz, joint_rot) + joint_pos.xyz) * weight;
		obj2tan[0] += mul_quat(T, joint_rot) * weight;
		obj2tan[2] += mul_quat(N, joint_rot) * weight;
	}
	obj2tan[0] = normalize(obj2tan[0]);
	obj2tan[2] = normalize(obj2tan[2]);
	obj2tan[1] = cross(obj2tan[2], obj2tan[0]);

	oPos = mul(float4(result_pos, 1), worldviewproj);

	float3 L = light_pos - result_pos;
	float3 V = eye_pos - result_pos;
	float3 H = L + V;

	oH = mul(obj2tan, H);
	oL = mul(obj2tan, L);
}

void NonSkinnedMeshVS(float2 tex0 : TEXCOORD0,
				float4 pos : POSITION,
				float3 N	: NORMAL,	// in object space
				float3 T	: TANGENT,	// in object space
				
				out float2 oTex0 : TEXCOORD0,
				out float3 oL	: TEXCOORD1,	// in tangent space
				out float3 oH	: TEXCOORD2,	// in tangent space
				out float4 oPos : SV_Position)
{
	oTex0 = tex0;
	
	float3x3 obj2tan = 0;
	obj2tan[0] = T;
	obj2tan[2] = N;
	obj2tan[1] = cross(obj2tan[2], obj2tan[0]);

	oPos = mul(pos, worldviewproj);

	float3 L = light_pos - pos;
	float3 V = eye_pos - pos;
	float3 H = L + V;

	oH = mul(obj2tan, H);
	oL = mul(obj2tan, L);
}

float4 PixelLighting(float3 normal, float2 uv, float3 L, float3 H)
{
	half4 diffuse = diffuse_tex.Sample(linear_sampler, uv);
	half3 specular = specular_tex.Sample(linear_sampler, uv).rgb;
	
	half3 light_vec = normalize(L);
	half diffuse_factor = dot(light_vec, normal);

	half4 clr;
	if (diffuse_factor > 0)
	{
		half3 half_way = normalize(H);
		half specular_factor = pow(dot(half_way, normal), 8);
		clr = half4(diffuse.rgb * diffuse_factor + specular * specular_factor, diffuse.a);
	}
	else
	{
		clr = half4(0, 0, 0, diffuse.a);
	}
	
	return clr;	
}

float4 SkinnedMeshPS(float2 uv : TEXCOORD0,
				float3 L	: TEXCOORD1,
				float3 H	: TEXCOORD2) : SV_Target
{
	half4 clr = PixelLighting(decompress_normal(normal_tex.Sample(linear_sampler, uv)).rgb, uv, L, H);
	return clr;	
}

float4 SkinnedMeshNoNormalMapPS(float2 uv : TEXCOORD0,
				float3 L	: TEXCOORD1,
				float3 H	: TEXCOORD2) : SV_Target
{
	half4 clr = PixelLighting(half3(0, 0, 1), uv, L, H);
	return clr;	
}
		]]>
	</shader>

	<technique name="SkinnedMeshTech">
		<pass name="p0">
			<state name="vertex_shader" value="SkinnedMeshVS()"/>
			<state name="pixel_shader" value="SkinnedMeshPS()"/>
		</pass>
	</technique>

	<technique name="SkinnedMeshNoNormalMapTech">
		<pass name="p0">
			<state name="vertex_shader" value="SkinnedMeshVS()"/>
			<state name="pixel_shader" value="SkinnedMeshNoNormalMapPS()"/>
		</pass>
	</technique>

	<technique name="NonSkinnedMeshTech">
		<pass name="p0">
			<state name="vertex_shader" value="NonSkinnedMeshVS()"/>
			<state name="pixel_shader" value="SkinnedMeshPS()"/>
		</pass>
	</technique>

	<technique name="NonSkinnedMeshNoNormalMapTech">
		<pass name="p0">
			<state name="vertex_shader" value="NonSkinnedMeshVS()"/>
			<state name="pixel_shader" value="SkinnedMeshNoNormalMapPS()"/>
		</pass>
	</technique>

	<shader>
		<![CDATA[
void AxisVS(float4 pos : POSITION,
				out float4 oClr	: COLOR0,
				out float4 oPos : SV_Position)
{
	oPos = mul(float4(pos.xyz, 1), worldviewproj);
	if (pos.w < 0.5f)
	{
		oClr = float4(1, 0, 0, 1);
	}
	else
	{
		if (pos.w < 1.5f)
		{
			oClr = float4(0, 1, 0, 1);
		}
		else
		{
			oClr = float4(0, 0, 1, 1);
		}
	}
}

float4 AxisPS(float4 clr : COLOR0) : SV_Target
{
	return clr;
}
		]]>
	</shader>

	<technique name="AxisTech">
		<pass name="p0">
			<state name="vertex_shader" value="AxisVS()"/>
			<state name="pixel_shader" value="AxisPS()"/>
		</pass>
	</technique>

	<shader>
		<![CDATA[
void GridVS(float4 pos : POSITION,
				out float4 oPos : SV_Position)
{
	oPos = mul(pos, worldviewproj);
}

float4 GridPS() : SV_Target
{
	return 0.5;
}
		]]>
	</shader>

	<technique name="GridTech">
		<pass name="p0">
			<state name="vertex_shader" value="GridVS()"/>
			<state name="pixel_shader" value="GridPS()"/>
		</pass>
	</technique>
</effect>
