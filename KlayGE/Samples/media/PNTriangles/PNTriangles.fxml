<?xml version='1.0'?>

<effect>
	<include name="util.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="Quaternion.fxml"/>

	<parameter type="float4" name="joint_rots" array_size="64"/>
	<parameter type="float4" name="joint_poss" array_size="64"/>

	<parameter type="bool" name="adaptive_tess"/>
	<parameter type="float4" name="tess_factors"/>
	<parameter type="float3" name="eye_pos"/>
	<parameter type="float3" name="light_dir" x="-1" y="2" z="1"/>

	<parameter type="float4x4" name="world" semantic="WORLD"/>
	<parameter type="float4x4" name="view" semantic="VIEW"/>
	<parameter type="float4x4" name="viewproj"/>
	<parameter type="float4x4" name="worldview" semantic="WORLDVIEW"/>
	<parameter type="float4x4" name="worldviewproj" semantic="WORLDVIEWPROJECTION"/>
	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
void Skinned(float3 pos : POSITION,
			float3 normal : NORMAL,
			float4 blend_weights : BLENDWEIGHT,
			int4 blend_indices : BLENDINDICES,
			out float3 result_pos,
			out float3 result_normal)
{
	result_pos = float3(0, 0, 0);
	result_normal = float3(0, 0, 0);
	for (int i = 0; i < 4; ++ i)
	{
		float4 joint_rot = joint_rots[blend_indices[i]];
		float4 joint_pos = joint_poss[blend_indices[i]];
		float weight = blend_weights[i];

		result_pos += (mul_quat(pos.xyz, joint_rot) + joint_pos.xyz) * weight;
		result_normal += mul_quat(normal.xyz, joint_rot) * weight;
	}
}

void NoPNTrianglesVS(float3 pos : POSITION,
					float2 texcoord0 : TEXCOORD0,
					float3 normal : NORMAL,
					float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
					float4 blend_indices_f : BLENDINDICES,
#else
#ifdef KLAYGE_OPENGLES2
					float4 blend_indices_f : BLENDINDICES,
#else
					int4 blend_indices : BLENDINDICES,
#endif
#endif

					out float2 oTex0 : TEXCOORD0,
					out float3 oNormal : TEXCOORD1,
					out float3 oPosES : TEXCOORD2,
					out float4 oPos : SV_Position)
{
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos, result_normal;
	Skinned(pos, normal, blend_weights, blend_indices,
		result_pos, result_normal);

	oPos = mul(float4(result_pos, 1), worldviewproj);
	oTex0 = texcoord0;
	oNormal = mul(result_normal, (float3x3)worldview);
	oPosES = mul(float4(result_pos, 1), worldview).xyz;
}

float4 PS(float2 oTex0 : TEXCOORD0, float3 normal : TEXCOORD1, float3 pos_es : TEXCOORD2) : SV_Target
{
	float3 l = normalize(-light_dir);
	float3 n = normalize(normal);
	float3 e = normalize(eye_pos - pos_es);

	float3 diff_clr = diffuse_tex.Sample(linear_sampler, oTex0).rgb;
	return float4(0.2f * diff_clr + calc_brdf(diff_clr * 0.7f, 0.1f, 20, l, normalize(l + e), n), 1);
}
		]]>
	</shader>

	<technique name="NoPNTriangles">
		<pass name="p0">
			<state name="vertex_shader" value="NoPNTrianglesVS()"/>
			<state name="pixel_shader" value="PS()"/>
		</pass>
	</technique>

	<technique name="NoPNTrianglesLine">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			
			<state name="vertex_shader" value="NoPNTrianglesVS()"/>
			<state name="pixel_shader" value="PS()"/>
		</pass>
	</technique>

	<shader version="5">
		<![CDATA[
struct VS_CONTROL_POINT_OUTPUT
{
	float3 Pos : WORLDPOS;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
};

struct HS_CONTROL_POINT
{
	float3 Pos : WORLDPOS;
	float2 Texcoord0 : TEXCOORD0;
	float3 Normal : TEXCOORD1;
};

VS_CONTROL_POINT_OUTPUT PNTrianglesVS(float3 pos : POSITION,
					float2 texcoord0 : TEXCOORD0,
					float3 normal : NORMAL,
					float4 blend_weights : BLENDWEIGHT,
#ifdef KLAYGE_OPENGL
					float4 blend_indices_f : BLENDINDICES
#else
#ifdef KLAYGE_OPENGLES2
					float4 blend_indices_f : BLENDINDICES
#else
					int4 blend_indices : BLENDINDICES
#endif
#endif
					)
{
	VS_CONTROL_POINT_OUTPUT output;
	
#ifdef KLAYGE_OPENGL
	int4 blend_indices = (int4)blend_indices_f;
#else
#ifdef KLAYGE_OPENGLES2
	int4 blend_indices = (int4)blend_indices_f;
#endif
#endif

	float3 result_pos, result_normal;
	Skinned(pos, normal, blend_weights, blend_indices,
		result_pos, result_normal);

	output.Pos = mul(float4(result_pos, 1), world).xyz;
	output.Texcoord0 = texcoord0;
	output.Normal = normalize(mul(result_normal, (float3x3)world));

	return output;
}

struct HS_CONSTANT_DATA_OUTPUT
{
	// Tess factor for the FF HW block
	float edges[3]	: SV_TessFactor;
	float inside	: SV_InsideTessFactor;

	// Geometry cubic generated control points
	float3 b210	: POSITION3;
	float3 b120	: POSITION4;
	float3 b021	: POSITION5;
	float3 b012	: POSITION6;
	float3 b102	: POSITION7;
	float3 b201	: POSITION8;
	float3 b111	: CENTER;

	// Normal quadratic generated control points
	float3 n110	: NORMAL3;      
	float3 n011	: NORMAL4;
	float3 n101	: NORMAL5;
};

//--------------------------------------------------------------------------------------
// Constant data function for the PNTrianglesHS.  This is executed once per patch.
//--------------------------------------------------------------------------------------
HS_CONSTANT_DATA_OUTPUT PNTrianglesConstantsHS(InputPatch<VS_CONTROL_POINT_OUTPUT, 3> ip)
{	
	HS_CONSTANT_DATA_OUTPUT output;
    
	if (adaptive_tess)
	{
		// Calculate the tessellation factor per edge, based on distance from camera
		float dist;
		float3 mid_point;
		// Edge 0
		mid_point = (ip[2].Pos + ip[0].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[0] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 1
		mid_point = (ip[0].Pos + ip[1].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[1] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Edge 2
		mid_point = (ip[1].Pos + ip[2].Pos) / 2;
		dist = distance(mid_point, eye_pos) - tess_factors.z;
		output.edges[2] = tess_factors.x * (1 - clamp(dist / tess_factors.w, 0, 1 - (1 / tess_factors.x)));
		// Inside
		output.inside = (output.edges[0] + output.edges[1] + output.edges[2]) / 3;
	}
	else
	{
		// Simply output the tessellation factors from constant space 
		// for use by the FF tessellation unit
		output.edges[0] = output.edges[1] = output.edges[2] = tess_factors.x;
		output.inside = tess_factors.y;
	}

	// Assign Positions
	float3 b003 = ip[0].Pos;
	float3 b030 = ip[1].Pos;
	float3 b300 = ip[2].Pos;
	// And Normals
	float3 n002 = ip[0].Normal;
	float3 n020 = ip[1].Normal;
	float3 n200 = ip[2].Normal;
    
	// Compute the cubic geometry control points
	// Edge control points
	output.b210 = (2 * b003 + b030 - (dot(b030 - b003, n002) * n002)) / 3;
	output.b120 = (2 * b030 + b003 - (dot(b003 - b030, n020) * n020)) / 3;
	output.b021 = (2 * b030 + b300 - (dot(b300 - b030, n020) * n020)) / 3;
	output.b012 = (2 * b300 + b030 - (dot(b030 - b300, n200) * n200)) / 3;
	output.b102 = (2 * b300 + b003 - (dot(b003 - b300, n200) * n200)) / 3;
	output.b201 = (2 * b003 + b300 - (dot(b300 - b003, n002) * n002)) / 3;
	// Center control point
	float3 e = (output.b210 + output.b120 + output.b021 + output.b012 + output.b102 + output.b201) / 6;
	float3 v = (b003 + b030 + b300) / 3;
	output.b111 = lerp(e, v, 0.5f);

	// Compute the quadratic normal control points, and rotate into world space
	float v12 = 2 * dot(b030 - b003, n002 + n020) / dot(b030 - b003, b030 - b003);
	output.n110 = normalize(n002 + n020 - v12 * (b030 - b003));
	float v23 = 2 * dot(b300 - b030, n020 + n200) / dot(b300 - b030, b300 - b030);
	output.n011 = normalize(n020 + n200 - v23 * (b300 - b030));
	float v31 = 2 * dot(b003 - b300, n200 + n002) / dot(b003 - b300, b003 - b300);
	output.n101 = normalize(n200 + n002 - v31 * (b003 - b300));

	return output;
}

[domain("tri")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(3)]
[patchconstantfunc("PNTrianglesConstantsHS")]
HS_CONTROL_POINT PNTrianglesHS(InputPatch<VS_CONTROL_POINT_OUTPUT, 3> p, 
										uint i : SV_OutputControlPointID)
{
	HS_CONTROL_POINT output;
	output.Pos = p[i].Pos;
	output.Texcoord0 = p[i].Texcoord0;
	output.Normal = p[i].Normal;
	return output;
}

[domain("tri")]
void PNTrianglesDS(HS_CONSTANT_DATA_OUTPUT HSConstantData, 
							float3 bc_coords : SV_DomainLocation,
							const OutputPatch<HS_CONTROL_POINT, 3> patch,

							out float2 oTex0 : TEXCOORD0,
							out float3 oNormal : TEXCOORD1,
							out float3 oPosES : TEXCOORD2,
							out float4 oPos : SV_Position)
{
	// The barycentric coordinates
	float u = bc_coords.x;
	float v = bc_coords.y;
	float w = bc_coords.z;

	// Precompute squares and squares * 3 
	float uu = u * u;
	float vv = v * v;
	float ww = w * w;
	float uu3 = uu * 3;
	float vv3 = vv * 3;
	float ww3 = ww * 3;

	// Compute position from cubic control points and barycentric coords
	float3 world_pos = patch[0].Pos * ww * w
					+ patch[1].Pos * uu * u
					+ patch[2].Pos * vv * v
					+ HSConstantData.b210 * ww3 * u
					+ HSConstantData.b120 * w * uu3
					+ HSConstantData.b201 * ww3 * v
					+ HSConstantData.b021 * uu3 * v
					+ HSConstantData.b102 * w * vv3
					+ HSConstantData.b012 * u * vv3
					+ HSConstantData.b111 * 6 * w * u * v;

	// Compute normal from quadratic control points and barycentric coords
	float3 normal = patch[0].Normal * ww
					+ patch[1].Normal * uu
					+ patch[2].Normal * vv
					+ HSConstantData.n110 * w * u
					+ HSConstantData.n011 * u * v
					+ HSConstantData.n101 * w * v;
	normal = normalize(normal);

	// Linearly interpolate the texture coords
	oTex0 = patch[0].Texcoord0 * w + patch[1].Texcoord0 * u + patch[2].Texcoord0 * v;

	// Transform model position with view-projection matrix
	oPos = mul(float4(world_pos, 1), viewproj);
	oPosES = mul(float4(world_pos, 1), view).xyz;
	oNormal = mul(normal, (float3x3)view); 
}
		]]>
	</shader>

	<technique name="PNTriangles">
		<pass name="p0">
			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="PS()"/>
		</pass>
	</technique>

	<technique name="PNTrianglesLine">
		<pass name="p0">
			<state name="polygon_mode" value="line"/>
			
			<state name="vertex_shader" value="PNTrianglesVS()"/>
			<state name="hull_shader" value="PNTrianglesHS()"/>
			<state name="domain_shader" value="PNTrianglesDS()"/>
			<state name="pixel_shader" value="PS()"/>
		</pass>
	</technique>
</effect>

