<?xml version="1.0" encoding="utf-8"?>

<effect>
	<parameter type="float4x4" name="mvp"/>

	<parameter type="float3" name="eye_pos"/>
	<parameter type="float3" name="look_at_vec"/>

	<parameter type="texture2D" name="earth_color_tex">
		<annotation type="string" name="SasResourceAddress" value="earth_color.dds"/>
	</parameter>
	<parameter type="texture2D" name="ocean_mask_tex">
		<annotation type="string" name="SasResourceAddress" value="ocean_mask.dds"/>
	</parameter>
	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="float" name="planet_radius" value="1"/>
	<parameter type="float" name="atmosphere_top" value="1.011"/>
	<parameter type="float" name="density" value="0.00119"/>
	<parameter type="float3" name="light_dir" x="-1" y="0" z="0"/>
	<parameter type="float3" name="beta" x="38.05" y="82.36" z="214.65"/>
	<parameter type="float3" name="absorb" x="0.75" y="0.85" z="1"/>

	<macro name="LN2" value="0.693147181"/>
	<macro name="H50" value="(density * LN2)"/>
	<macro name="BETA50" value="(beta * LN2)"/>
	<macro name="INV_H50" value="(1 / H50)"/>
	<macro name="X50" value="(planet_radius / H50)"/>

	<shader>
		<![CDATA[
void AtmosphericScatteringVS(float4 pos		: POSITION,
					out float4 oPosOS		: TEXCOORD0,
					out float4 oPos			: SV_Position)
{
	oPosOS = float4(pos.xyz * 1.2f, pos.w);
	oPos = mul(oPosOS, mvp);
}

float4 PointOnSurface(float3 eye_pos, float3 view_dir)
{
	// intersect a point on an implicit surface
	// this is just an ad-hoc way to add terrain geometry
	// it has nothing to do with the atmospheric scattering itself

	float4 result = 0;

	float r = planet_radius;
	float d = dot(eye_pos, view_dir);

	float d2 = d * d;
	float x2 = dot(eye_pos, eye_pos);
	float r2 = r * r;
	float D = d2 - x2 + r2;

	if (D >= 0)
	{
		if (x2 > r2)
		{
			float t = -d - sqrt(D);
			if (t > 0)
			{
				result = float4(eye_pos + view_dir * t, 1);
			}
		}
		else
		{
			result = float4(eye_pos, 1);
		}
	}

	return result;
}

float Chapman(float X, float h, float cos_chi)
{
	// this is the approximate Chapman function,
	// corrected for transitive consistency 

	float c = sqrt(X + h);    
    
	if (cos_chi >= 0)
	{	
 		return c / (c * cos_chi + 1) * exp2(-h);
	}
	else
	{
		float x0 = sqrt(1 - cos_chi * cos_chi) * (X + h);
		float c0 = sqrt(x0);
		return 2 * c0 * exp2(X - x0) - c / (1 - c * cos_chi) * exp2(-h);
	}
}

float3 Transmittance(float3 r, float3 view_dir)
{
	// a quick function to get the transmittance
	// looking from point p into infinity

	float rsq = dot(r, r);
	float inv_rl = 1 / sqrt(rsq);
	float len = rsq * inv_rl;
	float x = len * INV_H50;
	float h = x - X50;
	float cos_chi = dot(r, view_dir) * inv_rl;
	
	return exp2(-BETA50 * H50 * Chapman(X50, h, cos_chi));
}

void AerialPerspective(float3 r0, float3 r1, bool infinite,
		out float3 result_t, out float3 result_s)
{
	// compute the full aerial perspective
	// from point r0 to point r1, 
	// all positions relative to the planet center
	// if the infinite flag is true, the ray is followed beyond r1 into open space

	result_t = 1;
	result_s = 0;

	// get the principal integration bounds
	// as the intersection of the viewing ray
	// with the atmosphere boundary
	// t0 = start, t1 = end

	float t0 = 0;
	float t1 = 0;
	float3 dr = r1 - r0;
	float3 drn = normalize(dr);

	{
		float dp = dot(r0, drn);
		float r0sq = dot(r0, r0);
		float top2 = atmosphere_top * atmosphere_top;
		float D = dp * dp - r0sq + top2;

		if (D >= 0)
		{
			t0 = max(0, -dp - sqrt(D));
			t1 = -dp + sqrt(D);
		}
		else
		{
			return;
		}
	}

	// the infinite flag means the viewing ray extends
	// beyond the point of x1 (into space)
	// otherwise it ends at x1 (onto ground)

	float inf_neg = 1;
	if (!infinite)
	{
		t0 = min(t0, length(dr));
		t1 = min(t1, length(dr));
		inf_neg = -1;
	}

	// initialization of
	// the integration loop variables

	const int NMAX = 16;
	int N = NMAX; 
	float range = t1 - t0;
	float dt = range / (N - 1);

	float last_amtl = 0; 
	float last_mray = 0;

	{
		float3 r = r0 + drn * t1;
		float rl = length(r);
		float x = rl * INV_H50;
		float h = x - X50;
		float cos_chi_sun = dot(r / rl, light_dir);
		float cos_chi_ray = dot(r / rl, inf_neg * drn);
		
		last_amtl = H50 * Chapman(X50, h, cos_chi_sun);
		last_mray = inf_neg * H50 * Chapman(X50, h, cos_chi_ray);
	}

	float cos_theta = dot(drn, light_dir);
	float phase = 3.0f / 4 * (1 + cos_theta * cos_theta);

	// main loop
	// integrate along the ray in reverse order
	// (back to front)

	for (int i = N - 1; i > 0; -- i)
	{
		// calculate altitude r along the ray
		float t = i * dt + t0;
		float3 r = r0 + drn * t;
		float rl = length(r);

		// normalize altitude to 50%-height
		float x = rl * INV_H50;
		float h = x - X50;

		// calculate local incidence angle with the sunlight
		float cos_chi_sun = dot(r / rl, light_dir);
		float cos_chi_ray = dot(r / rl, inf_neg * drn);

		// calculate the airmass along this segment of the ray
		float mray = inf_neg * H50 * Chapman(X50, h, cos_chi_ray);
		float msegment = mray - last_mray;

		// calculate inscatter for this segment
		// amtl = airmass to light
		// for simplicity, the sun irradiance is assumed to be 1
		// so this is just the transmittance towards the sun, Tsun
		// for a Rayleigh atmosphere
		float amtl = H50 * Chapman(X50, h, cos_chi_sun);
		float3 segment_s = phase * exp2(-BETA50 * (amtl + last_amtl) * 0.5f);

		// calculate the transmittance for this segment
		float3 segment_t = exp2(-BETA50 * msegment);
		
		// propagate the integration
		// previous inscatter is attenuated by current transmittance, plus the new inscatter
		// previous transmittance is attenuated by current transmittance
		result_s = result_s * segment_t + (1 - segment_t) * segment_s;
		result_t = result_t * segment_t;

		// keep these variables for the next iteration
		last_amtl = amtl;
		last_mray = mray;
	}

	// Factored the average absorbtion color out of the loop
	// This would not be possible with different absorbtion colors at different scale heights
	result_s *= absorb;
}

float4 AtmosphericScatteringPS(float3 pos_os : TEXCOORD0) : SV_Target
{
	float3 color = 0;
	float3 view_dir = normalize(pos_os - eye_pos);

	// raycast a point to the planet surface
	float4 P = PointOnSurface(eye_pos, view_dir);

	if (P.w == 0)
	{
		// there was no surface intersection
		// this is simply the aerial perspective of empty space
		float3 t, s;
		AerialPerspective(eye_pos, eye_pos + view_dir, true, t, s);
		color = s;
	}
	else
	{
		// we have hit a surface point
		// get surfance normal and generate spherical texture coordinates
		float3 N = normalize(P.xyz);
		float2 uv = 0.5f + float2(0.15915494f, 0.31830989f) * float2(atan2(N.z, N.x), asin(-N.y));

		float3 surface_color = earth_color_tex.Sample(linear_sampler, uv).xyz;

		// get the direct light color
		// from the transmittance of the sun through the atmosphere
		float3 light_color = Transmittance(P.xyz, light_dir);

		// for shading the landmass we use the Lommel-Seeliger law
		float3 V = -view_dir;
		float dot_nv = max(0, dot(N, V));
		float dot_nl = max(0, dot(N, light_dir));
		float3 land_color = light_color * surface_color * dot_nl / (dot_nl + dot_nv);

		// for shading the ocean 
		// we obtain the skycolor reflection
		// via the aerial perspective of the reflection vector,
		// and mix it with an approximate fresnel factor
		float3 t, s;
		AerialPerspective(P.xyz, P.xyz - reflect(V, N), true, t, s);
		float fresnel = 1 - dot_nv;
		fresnel *= fresnel;
		fresnel *= fresnel;
		float3 ocean_color = lerp(land_color, s, fresnel);

		// we also add the specular reflection of the sun to the ocean
		// uses the micro-facet shading model described in ShaderX7 
		float3 H = normalize(light_dir + V);
		float dot_nh = max(0, dot(N, H));
		float dot_lh = max(0, dot(light_dir, H));
		ocean_color += light_color * 0.02f * (32 + 1) / 8 * pow(dot_nh, 32) / pow(dot_lh, 3) * dot_nl;

		// final shaded surface color
		surface_color = lerp(land_color, ocean_color, ocean_mask_tex.Sample(linear_sampler, uv).x);

		// finally obtain the aerial perspective of the shaded surface point
		// from the camera's point of view
		AerialPerspective(eye_pos, P.xyz, false, t, s);
		color = s + t * surface_color;
	}

	return float4(color, 1);
}
		]]>
	</shader>
	
	<technique name="AtmosphericScatteringTech">
		<pass name="p0">
			<state name="cull_mode" value="none"/>
			
			<state name="vertex_shader" value="AtmosphericScatteringVS()"/>
			<state name="pixel_shader" value="AtmosphericScatteringPS()"/>
		</pass>
	</technique>
</effect>
