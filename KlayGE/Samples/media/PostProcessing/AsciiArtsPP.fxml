<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="sampler" name="src_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="float4" name="tex_coord_offset" array_size="8"/>

	<shader>
		<![CDATA[
		
void Downsample8x8VS(float4 pos : POSITION,
					out float4 oTex0 : TEXCOORD0,
					out float4 oTex1 : TEXCOORD1,
					out float4 oTex2 : TEXCOORD2,
					out float4 oTex3 : TEXCOORD3,
					out float4 oTex4 : TEXCOORD4,
					out float4 oTex5 : TEXCOORD5,
					out float4 oTex6 : TEXCOORD6,
					out float4 oTex7 : TEXCOORD7,
					out float4 oPos : SV_Position)
{
	float2 tex_base;
	PostProcessVS(pos, tex_base, oPos);
	
	oTex0 = tex_base.xyxy + tex_coord_offset[0];
	oTex1 = tex_base.xyxy + tex_coord_offset[1];
	oTex2 = tex_base.xyxy + tex_coord_offset[2];
	oTex3 = tex_base.xyxy + tex_coord_offset[3];
	oTex4 = tex_base.xyxy + tex_coord_offset[4];
	oTex5 = tex_base.xyxy + tex_coord_offset[5];
	oTex6 = tex_base.xyxy + tex_coord_offset[6];
	oTex7 = tex_base.xyxy + tex_coord_offset[7];
}

float4 Downsample8x8PS(float4 oTex0 : TEXCOORD0,
					float4 oTex1 : TEXCOORD1,
					float4 oTex2 : TEXCOORD2,
					float4 oTex3 : TEXCOORD3,
					float4 oTex4 : TEXCOORD4,
					float4 oTex5 : TEXCOORD5,
					float4 oTex6 : TEXCOORD6,
					float4 oTex7 : TEXCOORD7) : SV_Target
{
	const half3 rgb_to_lum = half3(0.299, 0.587, 0.114);

	half4 s = src_tex.Sample(src_sampler, oTex0.xy)
				+ src_tex.Sample(src_sampler, oTex0.zw)
				+ src_tex.Sample(src_sampler, oTex1.xy)
				+ src_tex.Sample(src_sampler, oTex1.zw)
				+ src_tex.Sample(src_sampler, oTex2.xy)
				+ src_tex.Sample(src_sampler, oTex2.zw)
				+ src_tex.Sample(src_sampler, oTex3.xy)
				+ src_tex.Sample(src_sampler, oTex3.zw)
				+ src_tex.Sample(src_sampler, oTex4.xy)
				+ src_tex.Sample(src_sampler, oTex4.zw)
				+ src_tex.Sample(src_sampler, oTex5.xy)
				+ src_tex.Sample(src_sampler, oTex5.zw)
				+ src_tex.Sample(src_sampler, oTex6.xy)
				+ src_tex.Sample(src_sampler, oTex6.zw)
				+ src_tex.Sample(src_sampler, oTex7.xy)
				+ src_tex.Sample(src_sampler, oTex7.zw);

	return dot(saturate(s.rgb / 16), rgb_to_lum);
}
		]]>
	</shader>

	<technique name="Downsample8x8">
		<pass name="p0">
			<state name="depth_enable" value="false"/>

			<state name="vertex_shader" value="Downsample8x8VS()"/>
			<state name="pixel_shader" value="Downsample8x8PS()"/>
		</pass>
	</technique>
	

	<parameter type="texture2D" name="lums_tex"/>
	<parameter type="sampler" name="lums_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<cbuffer name="per_frame">
		<parameter type="float2" name="cell_per_row_line"/>
	</cbuffer>

	<shader>
		<![CDATA[
float4 AsciiArtsPS(float2 tex_coord0 : TEXCOORD0) : SV_Target
{
	half lum = src_tex.Sample(src_sampler, tex_coord0).r;
	half2 t = half2(floor(lum * 31) / 32, 0) + frac(tex_coord0 / cell_per_row_line) / half2(32, 1);
	return lum * lums_tex.Sample(lums_sampler, t).r;
}
		]]>
	</shader>

	<technique name="AsciiArts">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="AsciiArtsPS()"/>
		</pass>
	</technique>
</effect>