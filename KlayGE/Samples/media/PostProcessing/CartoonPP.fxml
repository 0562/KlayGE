<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>

	<shader>
		<![CDATA[
float3 GetNormal(float4 ndc)
{
	return float3(ndc.xy, -sqrt(1 - dot(ndc.xy, ndc.xy)));
}

float GetDepth(float4 ndc)
{
	return ndc.z;
}
		]]>
	</shader>
	
	<parameter type="float2" name="inv_width_height"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="texture2D" name="color_tex"/>

	<cbuffer name="per_frame">
		<parameter type="float2" name="e_barrier"/>
	</cbuffer>

	<parameter type="float2" name="e_weights" x="0.25" y="1.0"/>

	<shader>
		<![CDATA[
void PostToonVS(float4 pos : POSITION,
				out float2 oTc0 : TEXCOORD0, // center
				out float4 oTc1 : TEXCOORD1, // left top / right bottom
				out float4 oTc2 : TEXCOORD2, // right top / left bottom
				out float4 oTc3 : TEXCOORD3, // left / right
				out float4 oTc4 : TEXCOORD4, // top / bottom
				out float4 oPos : SV_Position)
{
	PostProcessVS(pos, oTc0, oPos);

	oTc1 = oTc0.xyxy + inv_width_height.xyxy * float4(-1, -1, +1, +1);
	oTc2 = oTc0.xyxy + inv_width_height.xyxy * float4(+1, -1, -1, +1);
	oTc3 = oTc0.xyxy + inv_width_height.xyxy * float4(-1, 0, +1, 0);
	oTc4 = oTc0.xyxy + inv_width_height.xyxy * float4(0, -1, 0, +1);
}

float4 PostToonPS(float2 tc0 : TEXCOORD0,
				float4 tc1 : TEXCOORD1,
				float4 tc2 : TEXCOORD2,
				float4 tc3 : TEXCOORD3,
				float4 tc4 : TEXCOORD4) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);
	float depth = GetDepth(ndc);
	if (1 == depth)
	{
		clip(-1);
	}
	float3 normal = GetNormal(ndc);
	
	half4 color = color_tex.Sample(point_sampler, tc0);
	half toon = dot(color.rgb, half3(0.299f, 0.587f, 0.114f));

	half4 s1 = src_tex.Sample(point_sampler, tc1.xy);
	half4 s2 = src_tex.Sample(point_sampler, tc1.zw);
	half4 s3 = src_tex.Sample(point_sampler, tc2.xy);
	half4 s4 = src_tex.Sample(point_sampler, tc2.zw);
	half4 s5 = src_tex.Sample(point_sampler, tc3.xy);
	half4 s6 = src_tex.Sample(point_sampler, tc3.zw);
	half4 s7 = src_tex.Sample(point_sampler, tc4.xy);
	half4 s8 = src_tex.Sample(point_sampler, tc4.zw);

	// Normal discontinuity filter
	half4 nd = half4(dot(normal, GetNormal(s1)),
				dot(normal, GetNormal(s2)),
				dot(normal, GetNormal(s3)),
				dot(normal, GetNormal(s4)));
	nd = step(e_barrier.x, nd);
	half ne = (dot(nd, e_weights.x).x < 1) ? 0 : 1;

	// Depth filter : compute gradiental difference:
	half4 dd = half4(GetDepth(s1) + GetDepth(s2), GetDepth(s3) + GetDepth(s4), GetDepth(s5) + GetDepth(s6), GetDepth(s7) + GetDepth(s8));
	dd = step(e_barrier.y, abs(2 * depth - dd));
	half de = (dot(dd, e_weights.y).x < 1) ? 1 : 0;

	const float toon_clr[3] = { 0.47f, 0.63f, 1 };
	return toon_clr[int(toon * 3)] * de * ne;
}
		]]>
	</shader>

	<technique name="Cartoon">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>
			
			<state name="vertex_shader" value="PostToonVS()"/>
			<state name="pixel_shader" value="PostToonPS()"/>
		</pass>
	</technique>
</effect>
