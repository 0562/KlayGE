<?xml version='1.0'?>

<effect>
	<include name="../../../RenderFX/util.fxml"/>
	<include name="../../../RenderFX/Lighting.fxml"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="mvp" semantic="WORLDVIEWPROJECTION"/>
		<parameter type="float3" name="eye_pos"/>
		<parameter type="float3" name="light_pos"/>
	</cbuffer>

	<parameter type="float" name="parallax_scale"/>
	<parameter type="float" name="parallax_bias"/>

	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="texture2D" name="normal_tex"/>
	<parameter type="texture2D" name="height_tex"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
void ParallaxVS(float4 pos				: POSITION,
					float2 texcoord0	: TEXCOORD0,
					float3 T			: TANGENT,
					float3 B			: BINORMAL,
					out float2 oTexcoord0	: TEXCOORD0,
					out float3 oL			: TEXCOORD1,	// in tangent space
					out float3 oV			: TEXCOORD2,	// in tangent space
					out float3 oH			: TEXCOORD3,	// in tangent space
					out float4 oPos			: SV_Position)
{
	oPos = mul(pos, mvp);
	oTexcoord0 = texcoord0;

	float3x3 objToTangentSpace;
	objToTangentSpace[0] = T;
	objToTangentSpace[1] = B;
	objToTangentSpace[2] = cross(T, B);

	float3 lightVec = light_pos - pos.xyz;
	float3 viewVec = eye_pos - pos.xyz;
	float3 halfVec = lightVec + viewVec;

	oL = mul(objToTangentSpace, lightVec);
	oV = mul(objToTangentSpace, viewVec);
	oH = mul(objToTangentSpace, halfVec);
}

half4 ParallaxPS(float2 texCoord0	: TEXCOORD0,
					float3 L		: TEXCOORD1,
					float3 V		: TEXCOORD2,
					float3 H		: TEXCOORD3) : SV_Target
{
	half3 view = normalize(V);

	half height = height_tex.Sample(linear_sampler, texCoord0).r * parallax_scale - parallax_bias;
	half2 texUV = texCoord0 + (view.xy * height);

	half3 diffuse = diffuse_tex.Sample(linear_sampler, texUV).rgb;

	half3 bump_normal = decompress_normal(normal_tex.Sample(linear_sampler, texUV));
	half3 light_vec = normalize(L);
	half diffuse_factor = diffuse_term(light_vec, bump_normal);

	half4 clr;
	if (diffuse_factor > 0)
	{
		half3 halfway = normalize(H);
		half specular_factor = specular_term(halfway, bump_normal, 4);
		clr = half4(diffuse * diffuse_factor + 0.3f * specular_factor, 1);
	}
	else
	{
		clr = half4(0, 0, 0, 1);
	}

	return clr;
}
		]]>
	</shader>
	
	<technique name="Parallax">
		<pass name="p0">
			<state name="vertex_shader" value="ParallaxVS()"/>
			<state name="pixel_shader" value="ParallaxPS()"/>
		</pass>
	</technique>
</effect>
