<?xml version='1.0'?>

<effect>
	<include name="util.fxml"/>
	<include name="Lighting.fxml"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="mvp" semantic="WORLDVIEWPROJECTION"/>
		<parameter type="float3" name="eye_pos"/>
		<parameter type="float3" name="light_pos"/>
	</cbuffer>

	<parameter type="float" name="parallax_scale"/>
	<parameter type="float" name="parallax_bias"/>

	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="texture2D" name="normal_tex"/>
	<parameter type="texture2D" name="height_tex"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
void ParallaxVS(float4 pos				: POSITION,
					float2 texcoord0	: TEXCOORD0,
					float3 N			: NORMAL,
					float3 T			: TANGENT,
					out float4 oL			: TEXCOORD0,	// in tangent space
					out float4 oV			: TEXCOORD1,	// in tangent space
					out float3 oH			: TEXCOORD2,	// in tangent space
					out float4 oPos			: SV_Position)
{
	oPos = mul(pos, mvp);
	
	N = N * 2 - 1;
	T = T * 2 - 1;

	float3x3 objToTangentSpace;
	objToTangentSpace[0] = T;
	objToTangentSpace[1] = cross(N, T);
	objToTangentSpace[2] = N;

	float3 lightVec = light_pos - pos.xyz;
	float3 viewVec = eye_pos - pos.xyz;
	float3 halfVec = normalize(lightVec) + normalize(viewVec);

	oL.xyz = mul(objToTangentSpace, lightVec);
	oV.xyz = mul(objToTangentSpace, viewVec);
	oH = mul(objToTangentSpace, halfVec);
	
	oL.w = texcoord0.x;
	oV.w = texcoord0.y;
}

float4 ParallaxPS(float4 L		: TEXCOORD0,
					float4 V		: TEXCOORD1,
					float3 H		: TEXCOORD2) : SV_Target
{
	float2 texCoord0 = float2(L.w, V.w);
	
	float3 view = normalize(V.xyz);

	float height = height_tex.Sample(linear_sampler, texCoord0).r * parallax_scale - parallax_bias;
	float2 texUV = texCoord0 + (view.xy * height);

	float3 diffuse = diffuse_tex.Sample(linear_sampler, texUV).rgb;

	float3 bump_normal = decompress_normal(normal_tex.Sample(linear_sampler, texUV));
	float3 light_vec = normalize(L.xyz);
	float diffuse_factor = diffuse_term(light_vec, bump_normal);

	float3 halfway = normalize(H);
	float3 specular = specular_term(0.04f, light_vec, view, halfway, bump_normal, 32);
	return float4((diffuse + specular) * diffuse_factor, 1);
}
		]]>
	</shader>
	
	<technique name="Parallax">
		<pass name="p0">
			<state name="vertex_shader" value="ParallaxVS()"/>
			<state name="pixel_shader" value="ParallaxPS()"/>
		</pass>
	</technique>
</effect>
