<?xml version='1.0'?>

<effect>
	<include name="../../../RenderFX/Lighting.fxml"/>
	<include name="../../../RenderFX/PostProcess.fxml"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="model_view_proj"/>
		<parameter type="float4x4" name="model_view"/>
		<parameter type="float3" name="light_in_model"/>
		<parameter type="float3" name="eye_in_model"/>

		<parameter type="float" name="depth_min"/>
		<parameter type="float" name="inv_depth_range"/>
	</cbuffer>

	<shader>
		<![CDATA[
void NormalDepthVS(float4 pos : POSITION,
			float3 normal : NORMAL,
			out float4 oPos : SV_Position,
			out float4 oNormal : TEXCOORD0,
			out float3 oLightVec : TEXCOORD1,
			out float3 oViewVec : TEXCOORD2)
{
	oPos = mul(pos, model_view_proj);
	oNormal.xyz = mul(normal, (float3x3)model_view);
	oNormal.w = (oPos.z - depth_min) * inv_depth_range;
	
	oLightVec = light_in_model - pos.xyz;
	oViewVec = eye_in_model - pos.xyz;
}

void NormalDepthPS(float4 pos : SV_Position, float4 normal : TEXCOORD0,
			float3 light_vec : TEXCOORD1, float3 view_vec : TEXCOORD2,
			out half4 oClr : SV_Target0, out half4 oNormalDepth : SV_Target1)
{
	normal.xyz = normalize(normal.xyz);
	oNormalDepth = normal;
	
	light_vec = normalize(light_vec);
	view_vec = normalize(view_vec);
	
	float diffuse = diffuse_lighting(light_vec, normal);
	float specular = 0;
	if (diffuse > 0)
	{
		specular = dot(normalize(light_vec + view_vec), normal);
		if (specular > 0)
		{
			specular = pow(specular, 8.0f);
		}
		else
		{
			specular = 0;
		}
	}
	else
	{
		diffuse = 0;
	}
	oClr = diffuse * 0.7f + specular * 0.3f;
}
		]]>
	</shader>

	<technique name="NormalDepth">
		<pass name="p0">
			<state name="vertex_shader" value="NormalDepthVS()"/>
			<state name="pixel_shader" value="NormalDepthPS()"/>
		</pass>
	</technique>

	<parameter type="float" name="inv_width"/>
	<parameter type="float" name="inv_height"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="toonmap_tex"/>
	<parameter type="texture2D" name="src_tex"/>
	<parameter type="texture2D" name="color_tex"/>

	<cbuffer name="per_frame">
		<parameter type="float2" name="e_barrier"/>
		<parameter type="float2" name="e_weights" x="0.25" y="1.0"/>
	</cbuffer>

	<shader>
		<![CDATA[
void PostToonVS(float4 pos : POSITION,
				out float4 oPos : SV_Position,
				out float2 oTc0 : TEXCOORD0, // center
				out float4 oTc1 : TEXCOORD1, // left top / right bottom
				out float4 oTc2 : TEXCOORD2, // right top / left bottom
				out float4 oTc3 : TEXCOORD3, // left / right
				out float4 oTc4 : TEXCOORD4) // top / bottom
{
	PostProcessVS(pos, oPos, oTc0);

	oTc1 = oTc0.xyxy + float4(-inv_width, -inv_height, +inv_width, +inv_height);
	oTc2 = oTc0.xyxy + float4(+inv_width, -inv_height, -inv_width, +inv_height);
	oTc3 = oTc0.xyxy + float4(-inv_width, 0, +inv_width, 0);
	oTc4 = oTc0.xyxy + float4(0, -inv_height, 0, +inv_height);
}

float4 PostToonPS(float4 pos : SV_Position,
				float2 tc0 : TEXCOORD0,
				float4 tc1 : TEXCOORD1,
				float4 tc2 : TEXCOORD2,
				float4 tc3 : TEXCOORD3,
				float4 tc4 : TEXCOORD4) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);
	if (1 == ndc.w)
	{
		clip(-1);
	}
	
	half4 color = color_tex.Sample(point_sampler, tc0);
	half toon = dot(color.rgb, half3(0.299f, 0.587f, 0.114f));

	half4 s1 = src_tex.Sample(point_sampler, tc1.xy);
	half4 s2 = src_tex.Sample(point_sampler, tc1.zw);
	half4 s3 = src_tex.Sample(point_sampler, tc2.xy);
	half4 s4 = src_tex.Sample(point_sampler, tc2.zw);
	half4 s5 = src_tex.Sample(point_sampler, tc3.xy);
	half4 s6 = src_tex.Sample(point_sampler, tc3.zw);
	half4 s7 = src_tex.Sample(point_sampler, tc4.xy);
	half4 s8 = src_tex.Sample(point_sampler, tc4.zw);

	// Normal discontinuity filter
	half4 nd = half4(dot(ndc.xyz, s1.xyz),
				dot(ndc.xyz, s2.xyz),
				dot(ndc.xyz, s3.xyz),
				dot(ndc.xyz, s4.xyz));
	nd = step(e_barrier.x, nd);
	half ne = (dot(nd, e_weights.x).x < 1) ? 0 : 1;

	// Depth filter : compute gradiental difference:
	half4 dd = half4(s1.w + s2.w, s3.w + s4.w, s5.w + s6.w, s7.w + s8.w);
	dd = step(e_barrier.y, abs(2 * ndc.w - dd));
	half de = (dot(dd, e_weights.y).x < 1) ? 1 : 0;

	return toonmap_tex.Sample(point_sampler, float2(toon, 0.5f)).r * de * ne;
}
		]]>
	</shader>

	<technique name="Cartoon">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>
			
			<state name="vertex_shader" value="PostToonVS()"/>
			<state name="pixel_shader" value="PostToonPS()"/>
		</pass>
	</technique>
</effect>
