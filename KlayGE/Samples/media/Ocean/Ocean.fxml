<?xml version='1.0'?>

<effect>
	<include name="Lighting.fxml"/>
	<include name="Noise.fxml"/>
	<include name="InfTerrain.fxml"/>
	<include name="util.fxml"/>

	<macro name="BLEND_FACTOR" value="0.6"/>
	
	<parameter type="float3" name="sun_dir"/>
	<parameter type="float" name="sun_shineness" value="128"/>
	<parameter type="float3" name="sun_color"/>
	<parameter type="float3" name="fog_color"/>
	<parameter type="float3" name="waterbody_color" x="0.07" y="0.15" z="0.2"/>
	<parameter type="float3" name="waterbody_specular_color" x="5" y="5" z="5"/>
	<parameter type="float" name="patch_length"/>

	<parameter type="texture2D" name="displacement_tex_0"/>
	<parameter type="texture2D" name="displacement_tex_1"/>
	<parameter type="texture2DArray" name="displacement_tex_array"/>
	<parameter type="texture2D" name="gradient_tex_0"/>
	<parameter type="texture2D" name="gradient_tex_1"/>
	<parameter type="texture2DArray" name="gradient_tex_array"/>
	<parameter type="texture2D" name="refraction_tex"/>
	<parameter type="texture2D" name="refraction_depth_tex"/>
	<parameter type="texture2D" name="reflection_tex"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="mvp"/>
		<parameter type="int2" name="frames"/>
		<parameter type="float3" name="min_disp0"/>
		<parameter type="float3" name="min_disp1"/>
		<parameter type="float3" name="disp_range0"/>
		<parameter type="float3" name="disp_range1"/>
		<parameter type="float" name="interpolate_frac"/>
	</cbuffer>

	<parameter type="sampler" name="linear_wrap_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
		<state name="address_w" value="wrap"/>
	</parameter>
	<parameter type="sampler" name="linear_clamp_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	<parameter type="sampler" name="point_clamp_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
void OceanVS(float2 pos : POSITION,
					out float4 eye_dir_fog : TEXCOORD0,
					out float4 tex_coord_noise_grad : TEXCOORD1,
					out float4 pos_ss : TEXCOORD2,
					out float4 oPos : SV_Position)
{
	float4 pos_os = GetInfTerrainPosOS(pos, 10);
	float2 tex_coord = pos_os.xz / (patch_length * 3.2f);

#if KLAYGE_MAX_TEX_ARRAY_LEN > 1
	float3 disp0 = displacement_tex_array.SampleLevel(linear_wrap_sampler, float3(tex_coord, frames.x), 0).xyz;
	float3 disp1 = displacement_tex_array.SampleLevel(linear_wrap_sampler, float3(tex_coord, frames.y), 0).xyz;
#else
	float3 disp0 = displacement_tex_0.SampleLevel(linear_wrap_sampler, tex_coord, 0).xyz;
	float3 disp1 = displacement_tex_1.SampleLevel(linear_wrap_sampler, tex_coord, 0).xyz;
#endif

	float3 disp = lerp(min_disp0 + disp0 * disp_range0, min_disp1 + disp1 * disp_range1, interpolate_frac);

	float lacunarity = 1.93485736f;
	float gain = 1.0f / 1.93485736f;

	eye_dir_fog.xyz = eye_pos - pos_os.xyz;
	float fog_scale = saturate(length(eye_dir_fog.xz) / 1200.0f);
	float height_scale = 1 - fog_scale;
	eye_dir_fog.w = fog_scale;

	pos_os.xz += disp.xy;
	
	float noise_height = fBm(tex_coord, 3, lacunarity, gain);

	float d = 1.0f / 64;
	float fx = fBm(tex_coord + float2(d, 0), 3, lacunarity, gain);
	float fy = fBm(tex_coord + float2(0, d), 3, lacunarity, gain);
	float2 noise_grad = (float2(fx, fy) - noise_height) * stretch;

	pos_os.y = base_level + lerp(noise_height * stretch, disp.z, BLEND_FACTOR) * height_scale;
	
	oPos = mul(pos_os, mvp);
	
	tex_coord_noise_grad = float4(tex_coord, noise_grad);
	pos_ss = oPos;
}

float4 OceanPS(float4 eye_dir_fog : TEXCOORD0, float4 tex_coord_noise_grad : TEXCOORD1, float4 pos_ss : TEXCOORD2) : SV_Target0
{
#if KLAYGE_MAX_TEX_ARRAY_LEN > 1
	float2 gradient0 = gradient_tex_array.Sample(linear_wrap_sampler, float3(tex_coord_noise_grad.xy, frames.x)).xy;
	float2 gradient1 = gradient_tex_array.Sample(linear_wrap_sampler, float3(tex_coord_noise_grad.xy * 6.4f, frames.x)).xy;
	float2 gradient2 = gradient_tex_array.Sample(linear_wrap_sampler, float3(tex_coord_noise_grad.xy, frames.y)).xy;
	float2 gradient3 = gradient_tex_array.Sample(linear_wrap_sampler, float3(tex_coord_noise_grad.xy * 6.4f, frames.y)).xy;
#else
	float2 gradient0 = gradient_tex_0.Sample(linear_wrap_sampler, tex_coord_noise_grad.xy).xy;
	float2 gradient1 = gradient_tex_0.Sample(linear_wrap_sampler, tex_coord_noise_grad.xy * 6.4f).xy;
	float2 gradient2 = gradient_tex_1.Sample(linear_wrap_sampler, tex_coord_noise_grad.xy).xy;
	float2 gradient3 = gradient_tex_1.Sample(linear_wrap_sampler, tex_coord_noise_grad.xy * 6.4f).xy;
#endif

	float2 gradient = lerp(lerp(gradient0, gradient1, 0.3f), lerp(gradient2, gradient3, 0.3f), interpolate_frac) * 2 - 1;
	gradient = lerp(tex_coord_noise_grad.zw, gradient, BLEND_FACTOR);
	
	float3 normal = normalize(float3(gradient.x, 1, gradient.y));

	pos_ss.xyz /= pos_ss.w;
	float2 ss_tc = float2(pos_ss.x, KLAYGE_FLIPPING * pos_ss.y) / 2 + 0.5f;

	float2 bump = normal.xz / pos_ss.z;
	float3 reflection = reflection_tex.Sample(linear_clamp_sampler, float2(ss_tc.x, 1 - ss_tc.y) + bump * 0.05f).xyz;

	float no_water_depth = refraction_depth_tex.Sample(point_clamp_sampler, ss_tc).x;

	float3 refraction;
	float offseted_depth = refraction_depth_tex.Sample(point_clamp_sampler, ss_tc + bump * 0.2f).x;
	if (offseted_depth < pos_ss.w)
	{
		refraction = refraction_tex.Sample(linear_clamp_sampler, ss_tc).rgb;
	}
	else
	{
		refraction.r = refraction_tex.Sample(linear_clamp_sampler, ss_tc + bump * 0.10f).r;
		refraction.g = refraction_tex.Sample(linear_clamp_sampler, ss_tc + bump * 0.15f).g;
		refraction.b = refraction_tex.Sample(linear_clamp_sampler, ss_tc + bump * 0.20f).b;
	}

	float water_depth = clamp(no_water_depth - pos_ss.w, 0, 100.0f);

	float3 eye_dir = normalize(eye_dir_fog.xyz);
	float fresnel = fresnel_term_schlick(eye_dir, normal, 0.027f).x;

	float3 ambient = waterbody_color * 0.1f;
	float3 diffuse = waterbody_color;

	float3 light_dir = normalize(-sun_dir);
	float3 halfway = normalize(light_dir + eye_dir);
	float3 specular = sun_color * waterbody_specular_color * specular_normalize_factor(sun_shineness) * roughness_term(halfway, normal, sun_shineness);

	float n_dot_l = max(0.0f, directional_lighting(-light_dir, normal));
	float3 water_color = ambient + (diffuse + specular) * n_dot_l;
	float3 sss = 0.9f * (max(0, dot(-normal, light_dir)) + max(0, dot(-eye_dir, light_dir))) * exp(-water_depth * 0.04f) * waterbody_color;
	water_color = lerp(lerp(water_color, refraction * exp(-water_depth * 0.05f), saturate(10 / pos_ss.w)), reflection, fresnel) + sss;

	return float4(lerp(water_color, fog_color, eye_dir_fog.w), saturate(water_depth * 0.1f));
}
		]]>
	</shader>

	<technique name="Ocean">
		<pass name="p0">
			<state name="polygon_mode" value="fill"/>

			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>
			
			<state name="vertex_shader" value="OceanVS()"/>
			<state name="pixel_shader" value="OceanPS()"/>
		</pass>
	</technique>

	<parameter type="float2" name="scale_bias" x="4.2" y="-0.2"/>
	<parameter type="float4x4" name="inv_mvp"/>

	<parameter type="textureCUBE" name="skybox_tex"/>
	<parameter type="textureCUBE" name="skybox_C_tex"/>
	<parameter type="sampler" name="skybox_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
		<state name="address_w" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
void FoggySkyBoxVS(float4 pos : POSITION,
			out float3 texcoord0 : TEXCOORD0,
			out float4 oPos : SV_Position)
{
	oPos = pos;
	texcoord0 = mul(pos, inv_mvp).xyz;
}

float4 FoggySkyBoxPS(float3 texCoord0 : TEXCOORD0) : SV_Target
{
	float fog = saturate(normalize(texCoord0).y * scale_bias.x + scale_bias.y);
	fog *= fog * (3 - 2 * fog);

	float3 sky = decode_hdr_yc(skybox_tex.Sample(skybox_sampler, texCoord0).r,
			skybox_C_tex.Sample(skybox_sampler, texCoord0)).rgb;

	return float4(lerp(fog_color, sky, fog), 1);
}
		]]>
	</shader>

	<technique name="FoggySkyBox">
		<pass name="p0">
			<state name="cull_mode" value="none"/>
			<state name="depth_write_mask" value="0"/>
			<state name="depth_func" value="equal"/>

			<state name="vertex_shader" value="FoggySkyBoxVS()"/>
			<state name="pixel_shader" value="FoggySkyBoxPS()"/>
		</pass>
	</technique>
</effect>
