<?xml version='1.0'?>

<effect>
	<include name="../../../RenderFX/PostProcess.fxml"/>

	<parameter type="float" name="point_radius"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="View"/>
		<parameter type="float4x4" name="Proj"/>

		<parameter type="float3" name="upper_left"/>
		<parameter type="float3" name="upper_right"/>
		<parameter type="float3" name="lower_left"/>
		<parameter type="float3" name="lower_right"/>

		<parameter type="float" name="depth_min"/>
		<parameter type="float" name="inv_depth_range"/>

		<parameter type="float2" name="offset"/>
		<parameter type="int" name="flip"/>
	</cbuffer>
	<parameter type="texture2D" name="particle_tex"/>
	<parameter type="sampler" name="particle_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>
	<parameter type="texture2D" name="scene_tex"/>
	<parameter type="sampler" name="scene_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return lerp(lerp(upper_left, upper_right, tex.x),
				lerp(lower_left, lower_right, tex.x),
				tex.y);
}
		]]>
	</shader>
	
	<shader>
		<![CDATA[
void ParticleVS(float4 pos			: TEXCOORD0,
					float2 tex			: POSITION,
					out float4 oPos		: SV_Position,
					out float4 oClr     : COLOR0,
					out float4 oPosSS	: TEXCOORD0,
					out float4 oCenterView : TEXCOORD1,
					out float3 oViewDir : TEXCOORD2)
{
	oCenterView = mul(float4(pos.xyz, 1), View);
	float4 view_pos = oCenterView;
	view_pos.xy += (float2(tex.x, 1 - tex.y) * 2 - 1) * point_radius;
	oPos = mul(view_pos, Proj);
	oClr = float4(1, 1, 1, pos.w);
	oPosSS = oPos / oPos.w;
	   
	oViewDir = texcoord_to_view(float2(oPosSS.x, -oPosSS.y) / 2 + 0.5f);
}

float4 ParticlePS(float4 pos : SV_Position,
						float4 clr : COLOR0,
						float4 PosSS : TEXCOORD0,
						float4 CenterView : TEXCOORD1,
						float3 view_dir : TEXCOORD2) : SV_Target
{
	CenterView /= CenterView.w;
	float dir = view_dir.z;
	view_dir = normalize(view_dir);
	
	float v = dot(CenterView.xyz, view_dir);
	float disc = point_radius * point_radius - (dot(CenterView.xyz, CenterView.xyz) - v * v);
	if (disc < 0)
	{
		clip(-1);
		return 0;
	}
	else
	{
		float2 tex_coord = PosSS.xy + offset;
		tex_coord.y *= flip;
		tex_coord = tex_coord / 2 + 0.5f;

		float depth = scene_tex.SampleLevel(scene_sampler, tex_coord, 0).a;

		float3 intersect = (v - sqrt(disc)) * view_dir;
		clr *= particle_tex.SampleLevel(particle_sampler, (intersect.xy - CenterView.xy) / point_radius / 2 + 0.5, 0);
		clr.a *= saturate((dir * depth - intersect.z) * 5);
		clip(clr.a - 0.03f);

		return clr;
	}
}
		]]>
	</shader>
	
	<technique name="Particle">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
			
			<state name="blend_enable" value="true"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>
			
			<state name="vertex_shader" value="ParticleVS()"/>
			<state name="pixel_shader" value="ParticlePS()"/>
		</pass>
	</technique>

	<parameter type="float3" name="LightPos" x="0" y="10" z="3"/>
	<parameter type="texture2D" name="grass_tex"/>
	<parameter type="sampler" name="grass_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<shader>
		<![CDATA[
void TerrainVS(float4 Position : POSITION,
					float3 Normal : NORMAL,
					out float4 oPos : SV_Position,
					out float2 oTex0 : TEXCOORD0,
					out float3 oPosOS : TEXCOORD1,
					out float3 oNormal : TEXCOORD2,
					out float2 oDepth : TEXCOORD3)
{
	float4 pos_es = mul(Position, View);
	oPos = mul(pos_es, Proj);
	oNormal = Normal;
	oPosOS = Position.xyz;
	oDepth = pos_es.zw;
	oTex0 = Position.xz;
}

float4 TerrainPS(float4 pos : SV_Position,
					float2 tex0 : TEXCOORD0,
					float3 pos_os : TEXCOORD1,
					float3 normal : TEXCOORD2,
					float2 depth : TEXCOORD3) : SV_Target 
{
	return float4(grass_tex.Sample(grass_sampler, tex0).rgb * dot(normalize(LightPos - pos_os), normal),
				(depth.x / depth.y - depth_min) * inv_depth_range);
}
		]]>
	</shader>
	
	<technique name="Terrain">
		<pass name="p0">
			<state name="vertex_shader" value="TerrainVS()"/>
			<state name="pixel_shader" value="TerrainPS()"/>
		</pass>
	</technique>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="sampler" name="src_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	
	<shader>
		<![CDATA[
float4 CopyPS(float4 pos : SV_Position, float2 tex : TEXCOORD0) : SV_Target
{
	float4 s = src_tex.Sample(src_sampler, tex);
	return float4(s.rgb, 1);
}
		]]>
	</shader>
	
	<technique name="Copy">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="CopyPS()"/>
		</pass>
	</technique>
</effect>
