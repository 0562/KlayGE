<?xml version='1.0'?>

<effect>
	<include name="../../../RenderFX/util.fxml"/>
	<include name="../../../RenderFX/PostProcess.fxml"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	
	<parameter type="sampler" name="bilinear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
		<state name="address_w" value="wrap"/>
	</parameter>

	<parameter type="texture2D" name="particle_pos_tex"/>
	<parameter type="texture3D" name="noise_vol_tex"/>

	<parameter type="float3" name="LightPos" x="0" y="10" z="3"/>
	<parameter type="float" name="point_radius"/>
	<parameter type="float4" name="init_pos_life"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="View"/>
		<parameter type="float4x4" name="Proj"/>
		<parameter type="float4x4" name="inv_view"/>

		<parameter type="float3" name="upper_left"/>
		<parameter type="float3" name="upper_right"/>
		<parameter type="float3" name="lower_left"/>
		<parameter type="float3" name="lower_right"/>

		<parameter type="float2" name="offset"/>
		<parameter type="int" name="flip"/>
	</cbuffer>

	<parameter type="texture2D" name="particle_tex"/>
	<parameter type="texture2D" name="scene_tex"/>

	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return lerp(lerp(upper_left, upper_right, tex.x),
				lerp(lower_left, lower_right, tex.x),
				tex.y);
}
		]]>
	</shader>
	
	<shader>
		<![CDATA[
void ParticlesVS(float2 tex_pos		: POSITION,
					float2 tex			: TEXCOORD0,
					out float4 oClr     : COLOR0,
					out float4 oPosSS	: TEXCOORD0,
					out float4 oCenterView : TEXCOORD1,
					out float3 oViewDir : TEXCOORD2,
					out float4 oPos		: SV_Position)
{
	float4 pos = particle_pos_tex.SampleLevel(point_sampler, tex_pos, 0);

	if (pos.w <= 0)
	{
		oPos = float4(-1, -1, 0, 0);
		oClr = 0;
		oCenterView = 0;
		oPosSS = 0;
		oViewDir = 0;
	}
	else
	{
		oCenterView = mul(float4(pos.xyz, 1), View);
		float4 view_pos = oCenterView;
		view_pos.xy += (float2(tex.x, 1 - tex.y) * 2 - 1) * point_radius;
		oPos = mul(view_pos, Proj);
			  
		oClr = float4(1, 1, 1, pos.w);
		oPosSS = oPos / oPos.w;
		
		oViewDir = texcoord_to_view(float2(oPosSS.x, -oPosSS.y) / 2 + 0.5f);
	}
}

float4 ParticlesPS(float4 clr : COLOR0,
						float4 PosSS : TEXCOORD0,
						float4 CenterView : TEXCOORD1,
						float3 view_dir : TEXCOORD2) : SV_Target
{
	CenterView /= CenterView.w;
	float dir = view_dir.z;
	view_dir = normalize(view_dir);
	
	float v = dot(CenterView.xyz, view_dir);
	float disc = point_radius * point_radius - (dot(CenterView.xyz, CenterView.xyz) - v * v);
	if (disc < 0)
	{
		return 0;
	}
	else
	{
		float2 tex_coord = PosSS.xy + offset;
		tex_coord.y = -tex_coord.y;
		tex_coord = tex_coord / 2 + 0.5f;

		float depth = scene_tex.Sample(point_sampler, tex_coord).a;
		float3 intersect = (v - sqrt(disc)) * view_dir;
		float optical_depth = dir * depth - intersect.z;
		
		if (optical_depth < 0)
		{
			return 0;
		}
		else
		{
			optical_depth = min(optical_depth, 2 * sqrt(disc) * view_dir.z);
			float4 intersect_ws = mul(float4(intersect, 1), inv_view);
			intersect_ws /= intersect_ws.w;
			float2 dxdy = (intersect.xy - CenterView.xy) / point_radius;
			float intensity = 5 * exp(-dot(dxdy, dxdy) / 0.125f);
			float4 n = noise_vol_tex.Sample(bilinear_sampler, intersect_ws.rgb / 50);
			return float4((dot(normalize(LightPos - intersect_ws), n.xyz) / n.w / 100).xxx, optical_depth * intensity * saturate(clr.a / init_pos_life.w));
		}
	}
}
		]]>
	</shader>
	
	<technique name="Particles">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
			
			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>
			
			<state name="vertex_shader" value="ParticlesVS()"/>
			<state name="pixel_shader" value="ParticlesPS()"/>
		</pass>
	</technique>

	<parameter type="texture2D" name="particle_vel_tex"/>

	<cbuffer name="per_frame2">
		<parameter type="float4x4" name="ps_model_mat"/>
		<parameter type="float" name="accumulate_time"/>
		<parameter type="float" name="elapse_time"/>
	</cbuffer>

	<parameter type="texture2D" name="particle_init_vel_tex"/>
	<parameter type="texture2D" name="particle_birth_time_tex"/>

	<parameter type="texture2D" name="height_map_tex"/>
	<parameter type="texture2D" name="normal_map_tex"/>
	<parameter type="sampler" name="normal_map_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
void UpdateVS(float4 pos			: POSITION,
					float2 tex			: TEXCOORD0,
					out float2 oTex		: TEXCOORD0,
					out float4 oPos		: SV_Position)
{
	oPos = pos;
	oTex = float2(tex.x, 1 - tex.y);
}

void UpdatePS(float2 tex : TEXCOORD0,
				out float4 out_pos : SV_Target0,
				out float4 out_vel : SV_Target1)
{
	float4 cur_pos = particle_pos_tex.Sample(point_sampler, tex);
	if (cur_pos.w > 0)
	{
		float3 cur_vel = particle_vel_tex.Sample(point_sampler, tex);

		cur_vel += float3(0, -0.1f, 0) * elapse_time;
		cur_pos.xyz += cur_vel * elapse_time;
		cur_pos.w -= elapse_time;
		
		float2 tex_pos = cur_pos.xz / 4 + 0.5;
		tex_pos.y = 1 - tex_pos.y;
		float height = height_map_tex.Sample(point_sampler, tex_pos).r;
		if (cur_pos.y < height)
		{
			cur_vel = reflect(cur_vel, decompress_normal(normal_map_tex.Sample(normal_map_sampler, tex_pos)).xzy) * 0.99f;
		}
		
		out_pos = cur_pos;
		out_vel = float4(cur_vel, 1);
	}
	else
	{
		float t = accumulate_time - particle_birth_time_tex.Sample(point_sampler, tex).r;
		if ((t > 0) && (t < elapse_time))
		{
			float4 pos = mul(float4(init_pos_life.xyz, 1), ps_model_mat);
			pos /= pos.w;

			float3 vel = particle_init_vel_tex.Sample(point_sampler, tex + cur_pos.xz).xyz;
			vel = mul(vel, (float3x3)ps_model_mat);

			out_pos = float4(pos.xyz, init_pos_life.w);
			out_vel = float4(vel, 1);
		}
		else
		{
			out_pos = float4(0, 0, 0, -1);
			out_vel = 0;
		}
	}
}
		]]>
	</shader>

	<technique name="Update">
		<pass name="p0">
			<state name="vertex_shader" value="UpdateVS()"/>
			<state name="pixel_shader" value="UpdatePS()"/>
		</pass>
	</technique>

	<cbuffer name="per_frame3">
		<parameter type="float" name="depth_min"/>
		<parameter type="float" name="inv_depth_range"/>
	</cbuffer>

	<parameter type="texture2D" name="grass_tex"/>

	<shader>
		<![CDATA[
void TerrainVS(float4 pos			: POSITION,
					float2 tex			: TEXCOORD0,
					out float4 oTex  : TEXCOORD0,
					out float3 oPosOS : TEXCOORD1,
					out float2 oDepth : TEXCOORD2,
					out float4 oPos		: SV_Position)
{
	oTex.xy = float2(tex.x, 1 - tex.y);
	oTex.zw = oTex.xy * 4;

	pos = pos.xzyw;
	pos.y += height_map_tex.SampleLevel(point_sampler, oTex.xy, 0).r;
	
	oPosOS = pos;
	
	float4 pos_es = mul(pos, View);
	oPos = mul(pos_es, Proj);
	oDepth = pos_es.zw;
}

float4 TerrainPS(float4 tex : TEXCOORD0, float3 pos_os : TEXCOORD1, float2 depth : TEXCOORD2) : SV_Target
{
	float3 normal = decompress_normal(normal_map_tex.Sample(normal_map_sampler, tex.xy)).xzy;
	return float4(grass_tex.Sample(bilinear_sampler, tex.zw).rgb * dot(normalize(LightPos - pos_os), normal),
		(depth.x / depth.y - depth_min) * inv_depth_range);
}
		]]>
	</shader>

	<technique name="Terrain">
		<pass name="p0">
			<state name="vertex_shader" value="TerrainVS()"/>
			<state name="pixel_shader" value="TerrainPS()"/>
		</pass>
	</technique>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="texture2D" name="tex_with_alpha"/>

	<shader>
		<![CDATA[
float4 BlendPS(float2 tex : TEXCOORD0) : SV_Target
{
	float4 a = tex_with_alpha.Sample(point_sampler, tex);
	a.a = saturate(a.a);
	float4 s = src_tex.Sample(point_sampler, tex);
	return float4(lerp(s.rgb, a.rgb, a.a), 1);
}
		]]>
	</shader>

	<technique name="Blend">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="BlendPS()"/>
		</pass>
	</technique>
</effect>
