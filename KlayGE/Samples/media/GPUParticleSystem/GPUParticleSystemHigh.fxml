<?xml version='1.0'?>

<effect>
	<include name="util.fxml"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	
	<parameter type="sampler" name="bilinear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
		<state name="address_w" value="wrap"/>
	</parameter>

	<parameter type="texture2D" name="particle_pos_tex"/>
	<parameter type="buffer" elem_type="float4" name="particle_pos_buff"/>
	<parameter type="texture3D" name="noise_vol_tex"/>

	<parameter type="float3" name="LightPos" x="0" y="10" z="3"/>
	<parameter type="float" name="point_radius"/>
	<parameter type="float4" name="init_pos_life"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="View"/>
		<parameter type="float4x4" name="Proj"/>
		<parameter type="float4x4" name="mvp"/>
		<parameter type="float4x4" name="inv_view"/>

		<parameter type="float3" name="upper_left"/>
		<parameter type="float3" name="upper_right"/>
		<parameter type="float3" name="lower_left"/>
		<parameter type="float3" name="lower_right"/>

		<parameter type="float2" name="offset"/>
		<parameter type="int" name="flip"/>
	</cbuffer>

	<parameter type="texture2D" name="particle_tex"/>
	<parameter type="texture2D" name="scene_tex"/>

	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return lerp(lerp(upper_left, upper_right, tex.x),
				lerp(lower_left, lower_right, tex.x),
				tex.y);
}
		]]>
	</shader>
	
	<shader>
		<![CDATA[
struct VS_TO_GS
{
	float4 CenterView_Life : TEXCOORD0;
};

struct PS_IN
{
	float4 pos : SV_Position;
	float4 clr : COLOR0;
	float4 PosSS : TEXCOORD0;
	float4 CenterView : TEXCOORD1;
	float3 view_dir : TEXCOORD2;
};

void ParticlesVS2(float2 tex_pos : POSITION,
					out VS_TO_GS vs_out)
{
	float4 pos = particle_pos_tex.SampleLevel(point_sampler, tex_pos, 0);

	vs_out.CenterView_Life = float4(mul(float4(pos.xyz, 1), View).xyz, pos.w);
}

void ParticlesVS3(uint vid : SV_VertexID,
					out VS_TO_GS vs_out)
{
	float4 pos = particle_pos_buff.Load(vid);
	
	vs_out.CenterView_Life = float4(mul(float4(pos.xyz, 1), View).xyz, pos.w);
}

#ifdef KLAYGE_OPENGL
POINT TRIANGLE_OUT void ParticlesGS(AttribArray<float4> input : TEXCOORD0)
{
	float4 CenterView_Life;
	CenterView_Life = input[0];
#else
[maxvertexcount(4)]
void ParticlesGS(point VS_TO_GS input[1], inout TriangleStream<PS_IN> out_stream)
{
	float4 CenterView_Life;
	CenterView_Life = input[0].CenterView_Life;
#endif

	if (CenterView_Life.w > 0)
	{
		PS_IN gs_out;

		for (int i = 0; i < 4; ++ i)
		{
			float2 tex = float2((i & 1) ? 1 : -1, (i & 2) ? -1 : 1);

			float4 view_pos = float4(CenterView_Life.xyz, 1);
			gs_out.CenterView = view_pos;
			view_pos.xy += tex * point_radius;
			gs_out.pos = mul(view_pos, Proj);
			gs_out.clr = float4(1, 1, 1, CenterView_Life.w);
			gs_out.PosSS = gs_out.pos / gs_out.pos.w;
			gs_out.view_dir = texcoord_to_view(float2(gs_out.PosSS.x, -gs_out.PosSS.y) / 2 + 0.5f);

#ifdef KLAYGE_OPENGL
			emitVertex(gs_out.pos : POSITION, gs_out.clr : COLOR0, gs_out.PosSS : TEXCOORD0,
				gs_out.CenterView : TEXCOORD1, gs_out.view_dir : TEXCOORD2);
#else
			out_stream.Append(gs_out);
#endif
		}
		
#ifdef KLAYGE_OPENGL
		restartStrip();
#else
		out_stream.RestartStrip();
#endif
	}
}

float4 ParticlesPS(PS_IN ps_in) : SV_Target
{
	ps_in.CenterView /= ps_in.CenterView.w;
	float dir = ps_in.view_dir.z;
	ps_in.view_dir = normalize(ps_in.view_dir);
	
	float4 clr = ps_in.clr;
	
	float v = dot(ps_in.CenterView.xyz, ps_in.view_dir);
	float disc = point_radius * point_radius - (dot(ps_in.CenterView.xyz, ps_in.CenterView.xyz) - v * v);
	if (disc < 0)
	{
		clr = 0;
	}
	else
	{
		float2 tex_coord = ps_in.PosSS.xy + offset;
		tex_coord.y *= flip;
		tex_coord = tex_coord / 2 + 0.5f;

		float depth = scene_tex.SampleLevel(point_sampler, tex_coord, 0).a;
		float3 intersect = (v - sqrt(disc)) * ps_in.view_dir;
		float optical_depth = dir * depth - intersect.z;
		
		if (optical_depth < 0)
		{
			clr = 0;
		}
		else
		{
			optical_depth = min(optical_depth, 2 * sqrt(disc) * ps_in.view_dir.z);
			float4 intersect_ws = mul(float4(intersect, 1), inv_view);
			intersect_ws /= intersect_ws.w;
			float2 dxdy = (intersect.xy - ps_in.CenterView.xy) / point_radius;
			float intensity = 5 * exp(-dot(dxdy, dxdy) / 0.125f);
			float4 n = noise_vol_tex.SampleLevel(bilinear_sampler, intersect_ws.rgb / 50, 0);
			clr = float4((dot(normalize(LightPos - intersect_ws.xyz), n.xyz) / n.w / 100).xxx, optical_depth * intensity * saturate(clr.a / init_pos_life.w));
		}
	}
	
	return clr;
}
		]]>
	</shader>
	
	<technique name="ParticlesWithGS">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

			<state name="vertex_shader" value="ParticlesVS2()"/>
			<state name="geometry_shader" value="ParticlesGS()"/>
			<state name="pixel_shader" value="ParticlesPS()"/>
		</pass>
	</technique>

	<technique name="ParticlesWithGSSO">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

			<state name="vertex_shader" value="ParticlesVS3()"/>
			<state name="geometry_shader" value="ParticlesGS()"/>
			<state name="pixel_shader" value="ParticlesPS()"/>
		</pass>
	</technique>

	<parameter type="buffer" elem_type="float4" name="particle_vel_buff"/>

	<cbuffer name="per_frame2">
		<parameter type="float4x4" name="ps_model_mat"/>
		<parameter type="float" name="accumulate_time"/>
		<parameter type="float" name="elapse_time"/>
	</cbuffer>

	<parameter type="texture2D" name="particle_init_vel_tex"/>
	<parameter type="texture2D" name="particle_birth_time_tex"/>
	<parameter type="buffer" elem_type="float4" name="particle_init_vel_buff"/>
	<parameter type="buffer" elem_type="float" name="particle_birth_time_buff"/>

	<parameter type="texture2D" name="height_map_tex"/>
	<parameter type="texture2D" name="normal_map_tex"/>
	<parameter type="sampler" name="normal_map_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
void UpdateSOVS(uint vid			: SV_VertexID,
					out float4 out_pos	: SV_Position,
					out float4 out_vel	: TEXCOORD0)
{
	float4 cur_pos = particle_pos_buff.Load(vid);
	if (cur_pos.w > 0)
	{
		float3 cur_vel = particle_vel_buff.Load(vid).xyz;
		cur_vel += float3(0, -0.1f, 0) * elapse_time;
		cur_pos.xyz += cur_vel * elapse_time;
		cur_pos.w -= elapse_time;
		
		float2 tex_pos = cur_pos.xz / 4 + 0.5;
		tex_pos.y = 1 - tex_pos.y;
		float height = height_map_tex.SampleLevel(point_sampler, tex_pos, 0).r;
		if (cur_pos.y < height)
		{
			cur_vel = reflect(cur_vel, decompress_normal(normal_map_tex.SampleLevel(normal_map_sampler, tex_pos, 0)).xzy) * 0.99f;
		}
		
		out_pos = cur_pos;
		out_vel = float4(cur_vel, 1);
	}
	else
	{
		float t = accumulate_time - particle_birth_time_buff.Load(vid).r;
		if ((t > 0) && (t < elapse_time))
		{
			float4 pos = mul(float4(init_pos_life.xyz, 1), ps_model_mat);
			pos /= pos.w;

			float3 vel = particle_init_vel_buff.Load((vid + uint(cur_pos.z * 256 * 256 + cur_pos.x * 256)) % 65536).xyz;
			vel = mul(vel, (float3x3)ps_model_mat);

			out_pos = float4(pos.xyz, init_pos_life.w);
			out_vel = float4(vel, 1);
		}
		else
		{
			out_pos = float4(0, 0, 0, -1);
			out_vel = 0;
		}
	}
}
		]]>
	</shader>

	<technique name="UpdateSO">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="0"/>
			
			<state name="vertex_shader" value="UpdateSOVS()">
				<stream_output>
					<slot usage="SV_Position" component="xyzw"/>
					<slot usage="TEXCOORD" usage_index="0" component="xyzw"/>
				</stream_output>
			</state>
		</pass>
	</technique>
</effect>
