KlayGE的字体系统设计目标是一个快速、易于实现、支持字体的高质量放缩，同时内存占用不应该太多，
且适用于DX7以上硬件。为达到这个目的，我们选择了“可放缩的点阵字体”这条路线。
通过对点阵字体的分析，可以发现点阵字体不能放缩的根本原因是，点阵中每一个元素所代表的含义是
sub-pixel的coverage信息[2]，表示该元素所覆盖的区域有多少在字的轮廓中。举例来说，如果某个元素
是0.5，就表示这块区域有50%在字内。这样的一个coverage信息是非线性的，无法通过线性插值得到平滑
的结果。所以强制对它进行放缩（线性插值）就会产生锯齿和间断等artifact。如果放弃使用coverage信
息，而用线性的距离作为元素存储的内容，就可以在一定程度上克服放缩的麻烦。所以，我们在点阵上不
存储传统的coverage，而存储signed distance field。
核心算法
经过分析，该字体系统的字形需要表示成signed distance field信息。做到这一点需要经过以下4个步骤。
第一步：生成大位图
在KFontGen中，这一步是通过freetype[3]读取矢量字体，渲染一张4096x4096的灰度图。如下图所示（为
了本文的显示方便，已经缩小到了512x512，下同）：
第二步：轮廓搜索
freetype生成的灰度图是经过光栅化的，也就是说字的轮廓和内部都进行了填充。我们只关心轮廓本身，
所以在这一步，我们需要提取出它的轮廓，也就是同时满足
   1. 该元素的值不为0
   2. 该元素的8个相邻元素存在0
这两个条件的元素。把轮廓元素标识为1，其他标示为0，就可以提取到的下图所示的轮廓：
第三步：得到distance field
一般来说，目标字体大小远远小于4096x4096。所以这里需要把对上一步得到的大位图进行离散采样，
得到目标字体大小的点阵。在默认情况下，KFontGen生成的目标字体大小是32x32。也就是说，从
(64, 64)开始，x和y方向分别每隔128采一个点。分别计算这些采样点到轮廓的最近距离，这样得到的就是
一个32x32的distance field。同时，在采样的时候，根据步骤一得到的灰度图可以判断一个采样点是否在
字内，如果在字内，这个距离就是正数，否则就是负数。由此可以得到所要的signed distance field。
第四步：量化
上一步得到的distance field每一个元素都是个float的数据，需要量化成每个元素8位，以减少空间占用，
加速渲染。量化后得到的最终结果是一张小位图：
实现细节
这四个步骤原理虽然简单，但在实际实现中，需要经过比较深入的优化才能得到实用级别的速度。
二值化灰度图
步骤一得到的灰度图是存成BYTE的形式，每个元素一个字节。实际上我们需要的只是一个0，1的二值信息，
表示一个元素是否在字内。所以我们需要对它进行二值化操作，不但节省空间，而且加速了后面的步骤。
对于灰度图中的每一个元素，取它的最高位，就可以生成前述的二值化位图。注意：freetype 虽然可以直
接生成单色图，但是这样生成的结果锯齿很多，无法达到高质量的要求。
SSE2的PMOVMSKB指令加速二值化
SSE2提供了PMOVMSKB指令，可以在一次提取16个字节的最高位，放入一个unsigned short中。这样能把二值
化的速度提高数倍。[4]
通过and和xor可以加速轮廓搜索
一旦用一个bit表示一个元素，就可以通过位运算来搜索轮廓。根据前面提出的轮廓条件可以推出，如果下
面的表达式：
center & (center ^ (center & up & down & left & right))
不为0，那么该元素在轮廓上；否则就不属于轮廓。其中center表示要检测的元素，up、down、left和right
分别表示该元素的上下左右四个相邻元素。在这里用SSE2可以进一步加速and和xor。[4]
KD-tree用来加速搜索最近邻
轮廓提取的结果可以看成是一个点集，集合中每个点都在轮廓上。计算distance field的本质就是计算采样
点到这个点集的最短距离。这个操作可以用KD-tree来加速[1]。把点集建立成一棵KD-tree，然后用每个采
样点的坐标去查询KD-tree，得到最近的轮廓点。计算它们之间的距离就可以得到该采样点到轮廓的最短距
离。
经过这些优化，在Pentium Core2 2.3GHz, 4GB DDR2-800的机器上可以做到55字/秒的速度。