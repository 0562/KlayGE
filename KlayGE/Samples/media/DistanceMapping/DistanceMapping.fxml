<?xml version='1.0'?>

<effect>
	<include name="util.fxml"/>
	<include name="Lighting.fxml"/>

	<parameter type="float4x4" name="worldviewproj" semantic="WORLDVIEWPROJECTION"/>
	<parameter type="float3" name="light_pos"/>
	<parameter type="float3" name="eye_pos"/>

	<parameter type="texture2D" name="diffuse_tex"/>
	<parameter type="texture2D" name="normal_tex"/>
	<parameter type="texture3D" name="distance_tex"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
		<state name="address_w" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
void DistanceMappingVS(float4 pos		: POSITION,
					float2 texcoord0	: TEXCOORD0,
					float3 T			: TANGENT,	// in object space
					float3 B			: BINORMAL,	// in object space
					
					out float3 oTexcoord0	: TEXCOORD0,
					out float3 oL			: TEXCOORD1,	// in tangent space
					out float3 oV			: TEXCOORD2,	// in tangent space
					out float4 oPos			: SV_Position)
{
	oPos = mul(pos, worldviewproj);
	oTexcoord0 = float3(texcoord0, 1);

	float3x3 matObjToTangentSpace;
	matObjToTangentSpace[0] = T;
	matObjToTangentSpace[1] = B;
	matObjToTangentSpace[2] = cross(T, B);

	float3 vLight = light_pos - pos.xyz;
	float3 vView = pos.xyz - eye_pos;

	float3 vTanLight = mul(matObjToTangentSpace, vLight);
	float3 vTanView = mul(matObjToTangentSpace, vView);

	oL = vTanLight;
	oV = vTanView;
}

float4 DistanceMappingPS(float3 texCoord0	: TEXCOORD0,
						float3 L		: TEXCOORD1,
						float3 V		: TEXCOORD2) : SV_Target
{
	float3 view = normalize(V) * float3(1, 1, 16) * 0.06;

	float3 texUV = texCoord0;
	for (int i = 0; i < 8; ++ i)
	{
		texUV += view * distance_tex.Sample(linear_sampler, texUV).r;
	}

	if ((texUV.x < 0) || (texUV.y < 0) || (texUV.x > 1) || (texUV.y > 1))
	{
		clip(-1);
	}

	float2 dx = ddx(texCoord0.xy);
	float2 dy = ddy(texCoord0.xy);

	float3 diffuse = diffuse_tex.SampleGrad(linear_sampler, texUV.xy, dx, dy).rgb;

	float3 bump_normal = decompress_normal(normal_tex.SampleGrad(linear_sampler, texUV.xy, dx, dy));
	float3 light_vec = normalize(L);
	float diffuse_factor = diffuse_term(light_vec, bump_normal);

	return float4(diffuse * diffuse_factor, 1);
}

float4 DistanceMappingPS_20(float3 texCoord0	: TEXCOORD0,
						float3 L		: TEXCOORD1,
						float3 V		: TEXCOORD2) : SV_Target
{
	float3 view = normalize(V) * float3(1, 1, 16) * 0.06;

	float3 texUV = texCoord0;
	for (int i = 0; i < 2; ++ i)
	{
		texUV += view * distance_tex.Sample(linear_sampler, texUV).r;
	}
	
	if ((texUV.x < 0) || (texUV.y < 0) || (texUV.x > 1) || (texUV.y > 1))
	{
		clip(-1);
	}

	float3 diffuse = diffuse_tex.Sample(linear_sampler, texUV.xy).rgb;

	float3 bump_normal = decompress_normal(normal_tex.Sample(linear_sampler, texUV.xy));
	float3 light_vec = normalize(L);
	float diffuse_factor = diffuse_term(light_vec, bump_normal);

	return float4(diffuse * diffuse_factor, 1);
}
		]]>
	</shader>

	<technique name="DistanceMapping2a">
		<pass name="p0">
			<state name="vertex_shader" value="DistanceMappingVS()"/>
			<state name="pixel_shader" value="DistanceMappingPS()"/>
		</pass>
	</technique>

	<technique name="DistanceMapping20">
		<pass name="p0">
			<state name="vertex_shader" value="DistanceMappingVS()"/>
			<state name="pixel_shader" value="DistanceMappingPS_20()"/>
		</pass>
	</technique>
</effect>

