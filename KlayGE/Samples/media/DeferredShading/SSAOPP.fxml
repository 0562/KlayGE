<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>
	<include name="DeferredShadingUtil.fxml"/>

	<cbuffer name="never_changes">
		<parameter type="float2" name="sphere_xy" array_size="12">
			<value>
				<![CDATA[
					0.00393088, 0.499985,
					-0.135392, -0.48132,
					0.48296, 0.129421,
					-0.463939, 0.186442,

					0.00221673, 0.281953,
					-0.0763507, -0.271428,
					0.272352, 0.0729836,
					-0.261626, 0.105139,
					0.197926, -0.200817,
					-0.35696, -0.243844,
					0.105313, -0.487068,
					0.485581, -0.111505
				]]>
			</value>
		</parameter>
	</cbuffer>

	<cbuffer name="per_frame">
		<parameter type="float3" name="upper_left"/>
		<parameter type="float3" name="upper_right"/>
		<parameter type="float3" name="lower_left"/>
		<parameter type="float3" name="lower_right"/>

		<parameter type="float4x4" name="proj"/>

		<parameter type="float3" name="depth_near_far_invfar"/>
		<parameter type="float2" name="inv_tex_width_height"/>
	</cbuffer>

	<cbuffer name="vo_params">
		<parameter type="float" name="vo_intensity" value="2.14"/>
	</cbuffer>
	<parameter type="sampler" name="bilinear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="src_tex"/>

	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return lerp(lerp(upper_left, upper_right, tex.x),
				lerp(lower_left, lower_right, tex.x),
				tex.y);
}

float CalcObscurance(float2 tc, float3 pos_es, float3 x_dir, float3 y_dir, float3 normal, float radius, int start, int end)
{
	float sqr_radius = radius * radius;
	float obscurance = 0;
	float total_weight = 0;
	for (int i = start; i < end; ++ i)
	{
		float3 sample_point_offset = (sphere_xy[i].x * x_dir + sphere_xy[i].y * y_dir) * radius;
		float3 sample_point = pos_es + sample_point_offset;
		float4 sample_point_ss = mul(float4(sample_point, 1), proj);
		
		float2 tc_sample = TexCoordFromPos(sample_point_ss / sample_point_ss.w);
		float4 ndc_sample = src_tex.SampleLevel(bilinear_sampler, tc_sample, 0);
		float depth_sample = GetDepth(ndc_sample) * depth_near_far_invfar.y;

		float3 view_dir_sample = normalize(texcoord_to_view(float2(tc_sample.x, (flipping < 0) ? tc_sample.y : 1 - tc_sample.y)));
		float v = dot(pos_es, view_dir_sample);
		float disc = sqr_radius - (dot(pos_es, pos_es) - v * v);
		float intersect_t = v - sqrt(disc);

		float zs;
		if (depth_sample <= intersect_t * view_dir_sample.z)
		{
			float3 pos_es_sample = view_dir_sample * intersect_t;
			zs = dot(pos_es_sample - pos_es, normal);
			obscurance += zs;
		}
		else
		{
			float3 pos_es_sample = view_dir_sample * (depth_sample / view_dir_sample.z);
			float3 pos_sphere_sample = mul(float3x3(x_dir, y_dir, normal), pos_es_sample - pos_es);
			zs = sqrt(sqr_radius - dot(pos_sphere_sample.xy, pos_sphere_sample.xy));
			obscurance += clamp(pos_sphere_sample.z, 0, zs);
		}
		total_weight += zs;
	}
	
	return obscurance / total_weight;
}

float4 SSVO(float2 tc0, float radius, int start, int end)
{
	float obscurance = 1;
	
	float4 ndc = src_tex.Sample(point_sampler, tc0);
	float depth = GetDepth(ndc) * depth_near_far_invfar.y;
	float3 normal = GetNormal(ndc);
	
	float3 view_dir = normalize(texcoord_to_view(float2(tc0.x, (flipping < 0) ? tc0.y : 1 - tc0.y)));
	float3 pos_es = view_dir * (depth / view_dir.z);

	float3 y_dir = cross(normal, float3(0, 0, 1));
	float3 x_dir = cross(y_dir, normal);

	obscurance = CalcObscurance(tc0, pos_es, x_dir, y_dir, normal, radius, start, end);
	return 1 - saturate(vo_intensity * obscurance);
}

float4 SSVOLowPS(float2 tc0 : TEXCOORD0) : SV_Target
{
	return SSVO(tc0, 0.5f, 0, 4);
}

float4 SSVOHighPS(float2 tc0 : TEXCOORD0) : SV_Target
{
	return SSVO(tc0, 1.0f, 4, 12);
}
		]]>
	</shader>

	<technique name="SSVOLow">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="SSVOLowPS()"/>
		</pass>
	</technique>
	<technique name="SSVOHigh">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="SSVOHighPS()"/>
		</pass>
	</technique>
</effect>
