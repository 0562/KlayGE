<?xml version='1.0'?>

<effect>
	<include name="Quaternion.fxml"/>
	<include name="DeferredShadingUtil.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="PostProcess.fxml"/>

	<cbuffer name="per_frame">
		<parameter type="float3" name="upper_left"/>
		<parameter type="float3" name="upper_right"/>
		<parameter type="float3" name="lower_left"/>
		<parameter type="float3" name="lower_right"/>

		<parameter type="float3" name="depth_near_far_invfar"/>
	</cbuffer>

	<parameter type="int" name="flip"/>

	<parameter type="float" name="min_variance" value="0.026"/>
	<parameter type="float" name="bleeding_reduce" value="0.55"/>

	<cbuffer name="light_sources">
		<parameter type="int" name="num_lights"/>
		<parameter type="float4" name="light_clr_type" array_size="MAX_NUM_LIGHTS"/>
		<parameter type="float4" name="light_pos" array_size="MAX_NUM_LIGHTS"/>
		<parameter type="float4" name="light_falloff" array_size="MAX_NUM_LIGHTS"/>
		<parameter type="float4" name="light_rotation" array_size="MAX_NUM_LIGHTS"/>
		<parameter type="float2" name="light_cos_outer_inner" array_size="MAX_NUM_LIGHTS"/>
		<parameter type="float4x4" name="light_proj" array_size="MAX_NUM_LIGHTS"/>
	</cbuffer>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="texture2DArray" name="shadow_map_tex_array"/>
	
	<parameter type="sampler" name="linear_border_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="address_w" value="wrap"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>
	
	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return lerp(lerp(upper_left, upper_right, tex.x),
				lerp(lower_left, lower_right, tex.x),
				tex.y);
}

float linstep(float min, float max, float v)
{
	return clamp((v - min) / (max - min), 0, 1);
}
		]]>
	</shader>

	<parameter type="texture2D" name="rand_normal_tex">
		<annotation type="string" name="SasResourceAddress" value="rand_normal.dds"/>
	</parameter>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="bilinear_wrap_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float2" name="inv_width_height"/>
	<parameter type="texture2D" name="src_tex"/>
	<parameter type="texture2D" name="color_tex"/>
	<parameter type="texture2D" name="ssao_tex"/>

	<parameter type="bool" name="ssao_enabled"/>

	<shader>
		<![CDATA[
float GetEdgeWeight(float2 tc0)
{
	float4 tc1 = tc0.xyxy + inv_width_height.xyxy * float4(-1, -1, +1, +1);
	float4 tc2 = tc0.xyxy + inv_width_height.xyxy * float4(+1, -1, -1, +1);
	float4 tc3 = tc0.xyxy + inv_width_height.xyxy * float4(-1, 0, +1, 0);
	float4 tc4 = tc0.xyxy + inv_width_height.xyxy * float4(0, -1, 0, +1);
	
	float4 nd[9];  
	// Retrieve normal and depth data for all neighbors.
	nd[0] = src_tex.Sample(point_sampler, tc0);
	nd[1] = src_tex.Sample(point_sampler, tc1.xy);
	nd[2] = src_tex.Sample(point_sampler, tc1.zw);
	nd[3] = src_tex.Sample(point_sampler, tc2.xy);
	nd[4] = src_tex.Sample(point_sampler, tc2.zw);
	nd[5] = src_tex.Sample(point_sampler, tc3.xy);
	nd[6] = src_tex.Sample(point_sampler, tc3.zw);
	nd[7] = src_tex.Sample(point_sampler, tc4.xy);
	nd[8] = src_tex.Sample(point_sampler, tc4.zw);

	// Compute Deltas in Depth.
	float4 Deltas1;
	float4 Deltas2;
	Deltas1.x = GetDepth(nd[1]);
	Deltas1.y = GetDepth(nd[2]);
	Deltas1.z = GetDepth(nd[3]);
	Deltas1.w = GetDepth(nd[4]);
	Deltas2.x = GetDepth(nd[5]);
	Deltas2.y = GetDepth(nd[6]);
	Deltas2.z = GetDepth(nd[7]);
	Deltas2.w = GetDepth(nd[8]);
	// Compute andbsolute gradients from center.
	Deltas1 = abs(Deltas1 - GetDepth(nd[0]));
	Deltas2 = abs(GetDepth(nd[0]) - Deltas2);
	// Find min and max gradient, ensuring min != 0
	float4 maxDeltas = max(Deltas1, Deltas2);
	float4 minDeltas = max(min(Deltas1, Deltas2), 0.00001);
	// Compare change in gradients, flagging ones that change
	// significantly.
	// How severe the change must be to get flagged is a function of the
	// minimum gradient. It is not resolution dependent. The constant
	// number here would change based on how the depth values are stored
	// and how sensitive the edge detection should be.
	float4 depthResults = step(minDeltas * 25.0, maxDeltas);
	// Compute change in the cosine of the angle between normals.
	float3 normal0 = GetNormal(nd[0]);
	Deltas1.x = dot(GetNormal(nd[1]), normal0);
	Deltas1.y = dot(GetNormal(nd[2]), normal0);
	Deltas1.z = dot(GetNormal(nd[3]), normal0);
	Deltas1.w = dot(GetNormal(nd[4]), normal0);
	Deltas2.x = dot(GetNormal(nd[5]), normal0);
	Deltas2.y = dot(GetNormal(nd[6]), normal0);
	Deltas2.z = dot(GetNormal(nd[7]), normal0);
	Deltas2.w = dot(GetNormal(nd[8]), normal0);
	Deltas1 = abs(Deltas1 - Deltas2);
	// Compare change in the cosine of the angles, flagging changes
	// above some constant threshold. The cosine of the angle is not a
	// linear function of the angle, so to have the flagging be
	// independent of the angles involved, an arccos function would be
	// required.
	float4 normalResults = step(0.4, Deltas1);
	normalResults = max(normalResults, depthResults);
	return dot(normalResults, 0.25);
}

void DeferredShadingVS(float4 pos : POSITION,
				out float2 oTc0 : TEXCOORD0,
				out float3 view_dir : TEXCOORD1,
				out float4 oPos : SV_Position)
{
	PostProcessVS(pos, oTc0, oPos);
	
	float4 PosSS = oPos / oPos.w;
	view_dir = texcoord_to_view(float2(PosSS.x, -PosSS.y) / 2 + 0.5f);
}

float4 DeferredShadingPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);
	float4 color = color_tex.Sample(point_sampler, tc0);
	float3 diffuse_clr = GetDiffuse(color);
	float depth = GetDepth(ndc);
	
	float4 final_clr;
	if (0 == GetMtlID(ndc))
	{
		final_clr = float4(diffuse_clr, 1);
	}
	else
	{
		float3 normal = GetNormal(ndc);
		view_dir = normalize(view_dir);

		float3 pos_es = view_dir * ((depth * depth_near_far_invfar.y) / view_dir.z);
		view_dir = -view_dir;
		
		float3 diffuse = 0, specular = 0;
		for (int i = 0; (i < MAX_NUM_LIGHTS) && (i < num_lights); ++ i)
		{
			float d = 0, s = 0;
			float atten = 0;
			
			float3 normal_ls = mul_quat(normal, light_rotation[i]);
			
			int type = (int)(light_clr_type[i].w + 0.1f);
			if (1 == type)
			{
				// directional

				float3 dir = -mul_quat(float3(0, 0, 1), light_rotation[i]);
				d = diffuse_term(dir, normal_ls);
				if (d > 0)
				{
					float3 view_dir_ls = mul_quat(view_dir, light_rotation[i]);
					s = specular_term(normalize(dir + view_dir_ls), normal_ls, 8.0f);
					atten = 1;
				}
				else
				{
					d = 0;
				}
			}
			else
			{
				float3 pos_ls = mul_quat(pos_es * light_pos[i].w, light_rotation[i]) + light_pos[i].xyz;
				float4 light_proj_pos = mul(float4(pos_ls, 1), light_proj[i]);
				if (((light_proj_pos.x < light_proj_pos.w) && (light_proj_pos.x > -light_proj_pos.w))
					&& ((light_proj_pos.y < light_proj_pos.w) && (light_proj_pos.y > -light_proj_pos.w)))
				{
					light_proj_pos /= light_proj_pos.w;
					light_proj_pos.y *= flip;
					light_proj_pos.xy = light_proj_pos.xy / 2 + 0.5f;
					
					if (light_proj_pos.z > 0)
					{
						float3 dir = -normalize(pos_ls);
						d = diffuse_term(dir, normal_ls);
						if (d > 0)
						{
							float2 moments = shadow_map_tex_array.SampleLevel(linear_border_sampler, float3(light_proj_pos.xy, i), 0);
						
							float3 view_dir_ls = mul_quat(view_dir, light_rotation[i]);
							s = specular_term(normalize(dir + view_dir_ls), normal_ls, 8.0f);
							atten = attenuation_term(float3(0, 0, 0), pos_ls, light_falloff[i].xyz);
							
							float shadow = 1.0f / (0.1f + 0.5f * pos_ls.z * pos_ls.z);

							float p = (pos_ls.z <= moments.x);
							// Variance shadow mapping
							float variance = moments.y - moments.x * moments.x;
							variance = max(variance, min_variance);
							float m_d = moments.x - pos_ls.z;
							float p_max = variance / (variance + m_d * m_d);
							p_max = linstep(bleeding_reduce, 1, p_max);

							shadow *= max(p, p_max);
							
							if (2 == type)
							{
								float spot = spot_lighting(float3(0, 0, 0), float3(0, 0, 1), light_cos_outer_inner[i], pos_ls.xyz);
								shadow *= spot;
							}

							d *= shadow;
							s *= shadow;
						}
						else
						{
							d = 0;
						}
					}
					else
					{
						d = 0;
					}
				}
				else
				{
					d = 0;
				}
			}
			
			diffuse += d * atten * light_clr_type[i].xyz;
			specular += s * atten  * light_clr_type[i].xyz;
		}

		float ssao = 1;
		if (ssao_enabled)
		{
			ssao = ssao_tex.Sample(point_sampler, tc0).x;
		}
		float3 specular_clr = GetSpecular(color);
		final_clr = float4(0.65f * diffuse_clr * (0.1f * ssao + diffuse) + 0.3f * specular_clr * specular, 1);
	}
	
	return final_clr;
}

float4 ShowPositionPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);
	float depth = GetDepth(ndc);
	
	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth * depth_near_far_invfar.y);
	
	return float4(pos_es, 1);
}

float4 ShowNormalPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);
	float3 normal = GetNormal(ndc);
	
	return float4(normal / 2 + 0.5f, 1);
}

float4 ShowDepthPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);
	float depth = GetDepth(ndc);
	return float4(depth.xxx, 1);
}

float4 ShowDiffusePS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 color = color_tex.Sample(point_sampler, tc0);
	float3 diffuse_clr = GetDiffuse(color);
	return float4(diffuse_clr, 1);
}

float4 ShowSpecularPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 color = color_tex.Sample(point_sampler, tc0);
	float3 specular_clr = GetSpecular(color);
	return float4(specular_clr, 1);
}

float4 ShowEdgePS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);

	float4 color = GetEdgeWeight(tc0);
	return color;
}

float4 ShowSSAOPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	half4 ndc = src_tex.Sample(point_sampler, tc0);

	float4 color = ssao_tex.Sample(point_sampler, tc0).xxxx;
	return color;
}
		]]>
	</shader>

	<technique name="DeferredShading">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>
			
			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="DeferredShadingPS()"/>
		</pass>
	</technique>
	<technique name="DeferredShadingBlend">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="DeferredShadingPS()"/>
		</pass>
	</technique>

	<technique name="ShowPosition">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="ShowPositionPS()"/>
		</pass>
	</technique>

	<technique name="ShowNormal">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="ShowNormalPS()"/>
		</pass>
	</technique>

	<technique name="ShowDepth">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="ShowDepthPS()"/>
		</pass>
	</technique>

	<technique name="ShowDiffuse">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="ShowDiffusePS()"/>
		</pass>
	</technique>

	<technique name="ShowSpecular">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="ShowSpecularPS()"/>
		</pass>
	</technique>

	<technique name="ShowEdge">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="ShowEdgePS()"/>
		</pass>
	</technique>

	<technique name="ShowSSAO">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="ShowSSAOPS()"/>
		</pass>
	</technique>
</effect>
