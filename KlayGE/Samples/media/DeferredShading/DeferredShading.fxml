<?xml version='1.0'?>

<effect>
	<include name="DeferredShadingUtil.fxml"/>
	<include name="Lighting.fxml"/>

	<macro name="LT_Ambient" value="0"/>
	<macro name="LT_Point" value="1"/>
	<macro name="LT_Directional" value="2"/>
	<macro name="LT_Spot" value="3"/>

	<macro name="LSA_NoShadow" value="1"/>
	<macro name="LSA_NoDiffuse" value="2"/>
	<macro name="LSA_NoSpecular" value="4"/>
	
	<cbuffer name="per_frame">
		<parameter type="float3" name="upper_left"/>
		<parameter type="float3" name="upper_right"/>
		<parameter type="float3" name="lower_left"/>
		<parameter type="float3" name="lower_right"/>

		<parameter type="float3" name="depth_near_far_invfar"/>

		<parameter type="float4x4" name="inv_view"/>
	</cbuffer>

	<parameter type='float4' name='texel_to_pixel_offset'/>
	<parameter type='int' name='flipping'/>
	<parameter type="int" name="sm_flipping"/>

	<parameter type="float" name="min_variance" value="0.026"/>
	<parameter type="float" name="bleeding_reduce" value="0.55"/>

	<cbuffer name="light_sources">
		<parameter type="bool" name="show_skybox"/>
		<parameter type="int" name="light_attrib"/>
		<parameter type="float4" name="light_clr_type"/>
		<parameter type="float4" name="light_falloff"/>
		<parameter type="float4" name="light_pos_es"/>
		<parameter type="float4" name="light_dir_es"/>
		<parameter type="float4x4" name="light_view_proj"/>
		<parameter type="float4x4" name="light_volume_mvp"/>
	</cbuffer>

	<parameter type="texture2D" name="shadow_map_tex"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	
	<shader>
		<![CDATA[
float3 texcoord_to_view(float2 tex)
{
	return lerp(lerp(upper_left, upper_right, tex.x),
				lerp(lower_left, lower_right, tex.x),
				tex.y);
}

float linstep(float min, float max, float v)
{
	return saturate((v - min) / (max - min));
}
		]]>
	</shader>

	<parameter type="texture2D" name="rand_normal_tex">
		<annotation type="string" name="SasResourceAddress" value="rand_normal.dds"/>
	</parameter>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="bilinear_wrap_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float2" name="inv_width_height"/>
	<parameter type="texture2D" name="nd_tex"/>
	<parameter type="texture2D" name="color_tex"/>
	<parameter type="texture2D" name="ssao_tex"/>

	<parameter type="bool" name="ssao_enabled"/>

	<shader>
		<![CDATA[
float GetEdgeWeight(float2 tc0)
{
	float4 tc1 = tc0.xyxy + inv_width_height.xyxy * float4(-1, -1, +1, +1);
	float4 tc2 = tc0.xyxy + inv_width_height.xyxy * float4(+1, -1, -1, +1);
	float4 tc3 = tc0.xyxy + inv_width_height.xyxy * float4(-1, 0, +1, 0);
	float4 tc4 = tc0.xyxy + inv_width_height.xyxy * float4(0, -1, 0, +1);
	
	float4 nd[9];  
	// Retrieve normal and depth data for all neighbors.
	nd[0] = nd_tex.Sample(point_sampler, tc0);
	nd[1] = nd_tex.Sample(point_sampler, tc1.xy);
	nd[2] = nd_tex.Sample(point_sampler, tc1.zw);
	nd[3] = nd_tex.Sample(point_sampler, tc2.xy);
	nd[4] = nd_tex.Sample(point_sampler, tc2.zw);
	nd[5] = nd_tex.Sample(point_sampler, tc3.xy);
	nd[6] = nd_tex.Sample(point_sampler, tc3.zw);
	nd[7] = nd_tex.Sample(point_sampler, tc4.xy);
	nd[8] = nd_tex.Sample(point_sampler, tc4.zw);

	// Compute Deltas in Depth.
	float4 Deltas1;
	float4 Deltas2;
	Deltas1.x = GetDepth(nd[1]);
	Deltas1.y = GetDepth(nd[2]);
	Deltas1.z = GetDepth(nd[3]);
	Deltas1.w = GetDepth(nd[4]);
	Deltas2.x = GetDepth(nd[5]);
	Deltas2.y = GetDepth(nd[6]);
	Deltas2.z = GetDepth(nd[7]);
	Deltas2.w = GetDepth(nd[8]);
	// Compute andbsolute gradients from center.
	Deltas1 = abs(Deltas1 - GetDepth(nd[0]));
	Deltas2 = abs(GetDepth(nd[0]) - Deltas2);
	// Find min and max gradient, ensuring min != 0
	float4 maxDeltas = max(Deltas1, Deltas2);
	float4 minDeltas = max(min(Deltas1, Deltas2), 0.00001);
	// Compare change in gradients, flagging ones that change
	// significantly.
	// How severe the change must be to get flagged is a function of the
	// minimum gradient. It is not resolution dependent. The constant
	// number here would change based on how the depth values are stored
	// and how sensitive the edge detection should be.
	float4 depthResults = step(minDeltas * 25.0, maxDeltas);
	// Compute change in the cosine of the angle between normals.
	float3 normal0 = GetNormal(nd[0]);
	Deltas1.x = dot(GetNormal(nd[1]), normal0);
	Deltas1.y = dot(GetNormal(nd[2]), normal0);
	Deltas1.z = dot(GetNormal(nd[3]), normal0);
	Deltas1.w = dot(GetNormal(nd[4]), normal0);
	Deltas2.x = dot(GetNormal(nd[5]), normal0);
	Deltas2.y = dot(GetNormal(nd[6]), normal0);
	Deltas2.z = dot(GetNormal(nd[7]), normal0);
	Deltas2.w = dot(GetNormal(nd[8]), normal0);
	Deltas1 = abs(Deltas1 - Deltas2);
	// Compare change in the cosine of the angles, flagging changes
	// above some constant threshold. The cosine of the angle is not a
	// linear function of the angle, so to have the flagging be
	// independent of the angles involved, an arccos function would be
	// required.
	float4 normalResults = step(0.4, Deltas1);
	normalResults = max(normalResults, depthResults);
	return dot(normalResults, 0.25);
}

float4 CalcColor(float2 ds, float3 diffuse_clr, float specular_clr)
{
#ifdef KLAYGE_D3D9
	if (((light_attrib / LSA_NoDiffuse) % 2) != 0)
#else
	if ((light_attrib & LSA_NoDiffuse) != 0)
#endif
	{
		ds.x = 0;
	}
#ifdef KLAYGE_D3D9
	if (((light_attrib / LSA_NoSpecular) % 2) != 0)
#else
	if ((light_attrib & LSA_NoSpecular) != 0)
#endif
	{
		ds.y = 0;
	}

	return float4((ds.x * diffuse_clr + ds.y * specular_clr) * light_clr_type.xyz, 1);
}

float VSM(float3 pos_es, float len)
{
	float4 light_proj_pos = mul(float4(pos_es, 1), light_view_proj);
	light_proj_pos /= light_proj_pos.w;
	light_proj_pos.y *= sm_flipping;
	light_proj_pos.xy = light_proj_pos.xy / 2 + 0.5f;
	
	float2 moments = shadow_map_tex.SampleLevel(linear_sampler, light_proj_pos.xy, 0);
	
	float shadow = 1;
#ifdef KLAYGE_D3D9
	if (0 == ((light_attrib / LSA_NoShadow) % 2))
#else
	if (0 == (light_attrib & LSA_NoShadow))
#endif
	{
		float p = (len < moments.x);
		// Variance shadow mapping
		float variance = moments.y - moments.x * moments.x;
		variance = max(variance, min_variance);
		float m_d = moments.x - len;
		float p_max = variance / (variance + m_d * m_d);
		p_max = linstep(bleeding_reduce, 1, p_max);

		shadow = max(p, p_max);
	}
	
	return shadow;
}

void DeferredShadingVS(float4 pos : POSITION,
				out float4 oPosSS : TEXCOORD0,
#ifndef KLAYGE_D3D9
				out noperspective float2 oTc : TEXCOORD1,
				out noperspective float3 oViewDir : TEXCOORD2,
#endif
				out float4 oPos : SV_Position)
{
	oPos = mul(float4(pos.xyz, 1), light_volume_mvp);
	oPosSS = oPos;
	oPos += texel_to_pixel_offset;
	oPos.z = 0;

#ifndef KLAYGE_D3D9
	oTc = oPosSS.xy / oPosSS.w * 0.5f;
	oTc.y *= flipping;
	oTc += 0.5;
	
	oViewDir = texcoord_to_view(oTc);
#endif
}

float4 DeferredShadingPointPS(float4 pos_ss : TEXCOORD0
#ifndef KLAYGE_D3D9
	, noperspective float2 tc : TEXCOORD1, noperspective float3 view_dir : TEXCOORD2
#endif
	) : SV_Target
{
#ifdef KLAYGE_D3D9
	pos_ss.xy /= pos_ss.w;

	float2 tc = pos_ss.xy * 0.5f;
	tc.y *= flipping;
	tc += 0.5;
	
	float3 view_dir = texcoord_to_view(tc);
#endif

	float4 ndc = nd_tex.Sample(point_sampler, tc);
	float4 color = color_tex.Sample(point_sampler, tc);
	float3 diffuse_clr = GetDiffuse(color);
	float depth = GetDepth(ndc);

	float4 final_clr;
	if (0 == GetMtlID(ndc))
	{
		if (show_skybox)
		{
			final_clr = float4(diffuse_clr, 1);
		}
		else
		{
			clip(-1);
		}
	}
	else
	{
		float3 normal = GetNormal(ndc);
		view_dir = normalize(view_dir);

		float3 pos_es = view_dir * ((depth * depth_near_far_invfar.y) / view_dir.z);
		view_dir = -view_dir;

		float2 ds = 0;

		float3 dir = light_pos_es.xyz - pos_es;
		float len = length(dir);
		dir = normalize(dir);

		float3 dir_ws = mul(-dir, (float3x3)inv_view);
		float3 abs_dir = abs(dir_ws);
		int face;
		if (abs_dir.x > abs_dir.y)
		{
			if (abs_dir.x > abs_dir.z)
			{
				face = (dir_ws.x > 0) ? 0 : 1;
			}
			else
			{
				face = (dir_ws.z > 0) ? 4 : 5;
			}
		}
		else
		{
			if (abs_dir.y > abs_dir.z)
			{
				face = (dir_ws.y > 0) ? 2 : 3;
			}
			else
			{
				face = (dir_ws.z > 0) ? 4 : 5;
			}
		}
		
		if (face == (int)light_dir_es.w)
		{
			ds.x = diffuse_term(dir, normal);
			if (ds.x > 0)
			{
				ds.y = specular_term(normalize(dir + view_dir), normal, GetShininess(ndc));
				float atten = attenuation_term(light_pos_es.xyz, pos_es.xyz, light_falloff.xyz);

				ds *= VSM(pos_es, len) * atten;
			}
			else
			{
				clip(-1);
			}
		}
		else
		{
			clip(-1);
		}

		final_clr = CalcColor(ds, diffuse_clr, GetSpecular(color));
	}

	return final_clr;
}

float4 DeferredShadingSpotPS(float4 pos_ss : TEXCOORD0
#ifndef KLAYGE_D3D9
	, noperspective float2 tc : TEXCOORD1, noperspective float3 view_dir : TEXCOORD2
#endif
	) : SV_Target
{
#ifdef KLAYGE_D3D9
	pos_ss.xy /= pos_ss.w;

	float2 tc = pos_ss.xy * 0.5f;
	tc.y *= flipping;
	tc += 0.5;
	
	float3 view_dir = texcoord_to_view(tc);
#endif

	float4 ndc = nd_tex.Sample(point_sampler, tc);
	float4 color = color_tex.Sample(point_sampler, tc);
	float3 diffuse_clr = GetDiffuse(color);
	float depth = GetDepth(ndc);

	float4 final_clr;
	if (0 == GetMtlID(ndc))
	{
		if (show_skybox)
		{
			final_clr = float4(diffuse_clr, 1);
		}
		else
		{
			clip(-1);
		}
	}
	else
	{
		float3 normal = GetNormal(ndc);
		view_dir = normalize(view_dir);

		float3 pos_es = view_dir * ((depth * depth_near_far_invfar.y) / view_dir.z);
		view_dir = -view_dir;

		float2 ds = 0;

		float spot = spot_lighting(light_pos_es.xyz, light_dir_es.xyz,
					float2(light_pos_es.w, light_dir_es.w), pos_es.xyz);
		if (spot > 0)
		{
			float3 dir = light_pos_es.xyz - pos_es;
			float len = length(dir);
			dir = normalize(dir);
			ds.x = diffuse_term(dir, normal);
			if (ds.x > 0)
			{
				ds.y = specular_term(normalize(dir + view_dir), normal, GetShininess(ndc));
				float atten = attenuation_term(light_pos_es.xyz, pos_es.xyz, light_falloff.xyz);
				
				ds *= VSM(pos_es, len) * spot * atten;
			}
			else
			{
				clip(-1);
			}
		}
		else
		{
			clip(-1);
		}

		final_clr = CalcColor(ds, diffuse_clr, GetSpecular(color));
	}

	return final_clr;
}

float4 DeferredShadingDirectionalPS(float4 pos_ss : TEXCOORD0
#ifndef KLAYGE_D3D9
	, noperspective float2 tc : TEXCOORD1, noperspective float3 view_dir : TEXCOORD2
#endif
	) : SV_Target
{
#ifdef KLAYGE_D3D9
	pos_ss.xy /= pos_ss.w;

	float2 tc = pos_ss.xy * 0.5f;
	tc.y *= flipping;
	tc += 0.5;
	
	float3 view_dir = texcoord_to_view(tc);
#endif
	
	float4 ndc = nd_tex.Sample(point_sampler, tc);
	float4 color = color_tex.Sample(point_sampler, tc);
	float3 diffuse_clr = GetDiffuse(color);
	float depth = GetDepth(ndc);

	float4 final_clr;
	if (0 == GetMtlID(ndc))
	{
		if (show_skybox)
		{
			final_clr = float4(diffuse_clr, 1);
		}
		else
		{
			clip(-1);
		}
	}
	else
	{
		float3 normal = GetNormal(ndc);
		view_dir = normalize(view_dir);

		float3 pos_es = view_dir * ((depth * depth_near_far_invfar.y) / view_dir.z);
		view_dir = -view_dir;

		float2 ds = 0;

		float3 dir = light_dir_es.xyz;
		ds.x = diffuse_term(dir, normal);
		if (ds.x > 0)
		{
			ds.y = specular_term(normalize(dir + view_dir), normal, GetShininess(ndc));
		}
		else
		{
			clip(-1);
		}

		final_clr = CalcColor(ds, diffuse_clr, GetSpecular(color));
	}

	return final_clr;
}

float4 DeferredShadingAmbientPS(float4 pos_ss : TEXCOORD0
#ifndef KLAYGE_D3D9
	, noperspective float2 tc : TEXCOORD1, noperspective float3 view_dir : TEXCOORD2
#endif
	) : SV_Target
{
#ifdef KLAYGE_D3D9
	pos_ss.xy /= pos_ss.w;

	float2 tc = pos_ss.xy * 0.5f;
	tc.y *= flipping;
	tc += 0.5;
	
	float3 view_dir = texcoord_to_view(tc);
#endif
	
	float4 ndc = nd_tex.Sample(point_sampler, tc);
	float4 color = color_tex.Sample(point_sampler, tc);
	float3 diffuse_clr = GetDiffuse(color);
	float depth = GetDepth(ndc);

	float4 final_clr;
	if (0 == GetMtlID(ndc))
	{
		if (show_skybox)
		{
			final_clr = float4(diffuse_clr, 1);
		}
		else
		{
			clip(-1);
		}
	}
	else
	{
		float3 normal = GetNormal(ndc);
		view_dir = normalize(view_dir);

		float3 pos_es = view_dir * ((depth * depth_near_far_invfar.y) / view_dir.z);
		view_dir = -view_dir;

		float2 ds = 0;

		float ssao = 1;
		if (ssao_enabled)
		{
			ssao = ssao_tex.Sample(point_sampler, tc).x;
		}

		final_clr = CalcColor(float2(0.1f * ssao, 0), diffuse_clr, GetSpecular(color));
	}

	return final_clr;
}


void ShowQuadVS(float4 pos : POSITION,
				out float2 oTc0 : TEXCOORD0,
				out float3 oViewDir : TEXCOORD1,
				out float4 oPos : SV_Position)
{
	oPos = pos;
	oPos += texel_to_pixel_offset;
	
	oTc0 = oPos.xy / oPos.w * 0.5f;
	oTc0.y *= flipping;
	oTc0 += 0.5;
	
	oViewDir = texcoord_to_view(oTc0);
}

float4 ShowPositionPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 ndc = nd_tex.Sample(point_sampler, tc0);
	float depth = GetDepth(ndc);
	
	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth * depth_near_far_invfar.y);

	return float4(pos_es, 1);
}

float4 ShowNormalPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 ndc = nd_tex.Sample(point_sampler, tc0);
	float3 normal = GetNormal(ndc);
	
	return float4(normal / 2 + 0.5f, 1);
}

float4 ShowDepthPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 ndc = nd_tex.Sample(point_sampler, tc0);
	float depth = GetDepth(ndc);
	return float4(depth.xxx, 1);
}

float4 ShowDiffusePS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 color = color_tex.Sample(point_sampler, tc0);
	float3 diffuse_clr = GetDiffuse(color);
	return float4(diffuse_clr, 1);
}

float4 ShowSpecularPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 color = color_tex.Sample(point_sampler, tc0);
	float specular_clr = GetSpecular(color);
	return float4(specular_clr.xxx, 1);
}

float4 ShowEdgePS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 ndc = nd_tex.Sample(point_sampler, tc0);

	float4 color = GetEdgeWeight(tc0);
	return color;
}

float4 ShowSSAOPS(float2 tc0 : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 ndc = nd_tex.Sample(point_sampler, tc0);

	float4 color = ssao_tex.Sample(point_sampler, tc0).xxxx;
	return color;
}
		]]>
	</shader>

	<technique name="DeferredShadingPoint">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="DeferredShadingPointPS()"/>
		</pass>
	</technique>
	
	<technique name="DeferredShadingSpot">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="DeferredShadingSpotPS()"/>
		</pass>
	</technique>
				
	<technique name="DeferredShadingDirectional">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="DeferredShadingDirectionalPS()"/>
		</pass>
	</technique>
			
	<technique name="DeferredShadingAmbient">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>

			<state name="vertex_shader" value="DeferredShadingVS()"/>
			<state name="pixel_shader" value="DeferredShadingAmbientPS()"/>
		</pass>
	</technique>

	<technique name="ShowPosition">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
			
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShowQuadVS()"/>
			<state name="pixel_shader" value="ShowPositionPS()"/>
		</pass>
	</technique>

	<technique name="ShowNormal">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
	
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShowQuadVS()"/>
			<state name="pixel_shader" value="ShowNormalPS()"/>
		</pass>
	</technique>

	<technique name="ShowDepth">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
			
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShowQuadVS()"/>
			<state name="pixel_shader" value="ShowDepthPS()"/>
		</pass>
	</technique>

	<technique name="ShowDiffuse">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
	
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShowQuadVS()"/>
			<state name="pixel_shader" value="ShowDiffusePS()"/>
		</pass>
	</technique>

	<technique name="ShowSpecular">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
				
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShowQuadVS()"/>
			<state name="pixel_shader" value="ShowSpecularPS()"/>
		</pass>
	</technique>

	<technique name="ShowEdge">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>
			
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShowQuadVS()"/>
			<state name="pixel_shader" value="ShowEdgePS()"/>
		</pass>
	</technique>

	<technique name="ShowSSAO">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="ShowQuadVS()"/>
			<state name="pixel_shader" value="ShowSSAOPS()"/>
		</pass>
	</technique>
</effect>
