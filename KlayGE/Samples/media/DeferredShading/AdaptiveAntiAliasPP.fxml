<?xml version='1.0'?>

<effect>
	<include name="PostProcess.fxml"/>
	<include name="DeferredShadingUtil.fxml"/>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="bilinear_clamp_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="texture2D" name="src_tex"/>
	<parameter type="texture2D" name="color_tex"/>
	<parameter type="float2" name="inv_width_height"/>

	<shader>
		<![CDATA[
float GetEdgeWeight(float2 tc0)
{
	float4 tc1 = tc0.xyxy + inv_width_height.xyxy * float4(-1, -1, +0, -1);
	float4 tc2 = tc0.xyxy + inv_width_height.xyxy * float4(+1, -1, +1, +0);
	float4 tc3 = tc0.xyxy + inv_width_height.xyxy * float4(+1, +1, +0, +1);
	float4 tc4 = tc0.xyxy + inv_width_height.xyxy * float4(-1, +1, -1, +0);
	
	float4 nd[9];  
	// Retrieve normal and depth data for all neighbors.
	nd[0] = src_tex.Sample(point_sampler, tc0);
	nd[1] = src_tex.Sample(point_sampler, tc1.xy);
	nd[2] = src_tex.Sample(point_sampler, tc1.zw);
	nd[3] = src_tex.Sample(point_sampler, tc2.xy);
	nd[4] = src_tex.Sample(point_sampler, tc2.zw);
	nd[5] = src_tex.Sample(point_sampler, tc3.xy);
	nd[6] = src_tex.Sample(point_sampler, tc3.zw);
	nd[7] = src_tex.Sample(point_sampler, tc4.xy);
	nd[8] = src_tex.Sample(point_sampler, tc4.zw);

	// Compute Deltas in Depth.
	float4 Deltas1;
	float4 Deltas2;
	float depth0 = GetDepth(nd[0]);
	Deltas1.x = GetDepth(nd[1]);
	Deltas1.y = GetDepth(nd[2]);
	Deltas1.z = GetDepth(nd[3]);
	Deltas1.w = GetDepth(nd[4]);
	Deltas2.x = GetDepth(nd[5]);
	Deltas2.y = GetDepth(nd[6]);
	Deltas2.z = GetDepth(nd[7]);
	Deltas2.w = GetDepth(nd[8]);
	// Compute andbsolute gradients from center.
	Deltas1 = abs(Deltas1 - depth0);
	Deltas2 = abs(depth0 - Deltas2);
	// Find min and max gradient, ensuring min != 0
	float4 maxDeltas = max(Deltas1, Deltas2);
	float4 minDeltas = max(min(Deltas1, Deltas2), 0.00001);
	// Compare change in gradients, flagging ones that change
	// significantly.
	// How severe the change must be to get flagged is a function of the
	// minimum gradient. It is not resolution dependent. The constant
	// number here would change based on how the depth values are stored
	// and how sensitive the edge detection should be.
	float4 depthResults = step(minDeltas * 18.0, maxDeltas);
	// Compute change in the cosine of the angle between normals.
	float3 normal0 = GetNormal(nd[0]);
	Deltas1.x = dot(GetNormal(nd[1]), normal0);
	Deltas1.y = dot(GetNormal(nd[2]), normal0);
	Deltas1.z = dot(GetNormal(nd[3]), normal0);
	Deltas1.w = dot(GetNormal(nd[4]), normal0);
	Deltas2.x = dot(GetNormal(nd[5]), normal0);
	Deltas2.y = dot(GetNormal(nd[6]), normal0);
	Deltas2.z = dot(GetNormal(nd[7]), normal0);
	Deltas2.w = dot(GetNormal(nd[8]), normal0);
	Deltas1 = abs(Deltas1 - Deltas2);
	// Compare change in the cosine of the angles, flagging changes
	// above some constant threshold. The cosine of the angle is not a
	// linear function of the angle, so to have the flagging be
	// independent of the angles involved, an arccos function would be
	// required.
	float4 normalResults = step(0.4, Deltas1);
	normalResults = max(normalResults, depthResults);
	return dot(normalResults, 0.25);
}  

float4 AdaptiveAntiAliasPS(float2 tc0 : TEXCOORD0) : SV_Target
{
	float2 offset = GetEdgeWeight(tc0) * inv_width_height;
	return (color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(-offset.x, -offset.y))
			+ color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(+offset.x, -offset.y))
			+ color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(-offset.x, +offset.y))
			+ color_tex.Sample(bilinear_clamp_sampler, tc0 + float2(+offset.x, +offset.y))) * 0.25f;
}

float4 ShowEdgePS(float2 tc0 : TEXCOORD0) : SV_Target
{
	return GetEdgeWeight(tc0);
}
		]]>
	</shader>
	
	<technique name="AdaptiveAntiAlias">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="AdaptiveAntiAliasPS()"/>
		</pass>
	</technique>

	<technique name="AdaptiveAntiAliasShowEdge">
		<pass name="p0">
			<state name="depth_write_mask" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="ShowEdgePS()"/>
		</pass>
	</technique>
</effect>
