<?xml version='1.0'?>

<effect>
	<parameter type="float4x4" name="model_view_proj"/>
	<parameter type="float4x4" name="model"/>
	<parameter type="float4x4" name="obj_model_to_light_model"/>

	<shader>
		<![CDATA[
void GenShadowMapVS(float4 Position : POSITION,
						float3 Normal   : NORMAL,
						out float4 oPos : POSITION,
						out float4 oLightWorldPos : TEXCOORD0)
{
    oPos = mul(Position, model_view_proj);
    oLightWorldPos = mul(Position, obj_model_to_light_model);
}

half4 GenShadowMapPS(float4 pos : POSITION, float4 LightWorldPos : TEXCOORD0) : COLOR
{
	LightWorldPos /= LightWorldPos.w;
	half dist = length(LightWorldPos.xyz);
	return half4(dist, dist * dist, 0, 1);
}
		]]>
	</shader>

	<technique name="GenShadowMap">
		<pass name="p0">
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="GenShadowMapVS()"/>
			<state name="pixel_shader" value="GenShadowMapPS()"/>
		</pass>
	</technique>

	<parameter type="float3" name="light_pos"/>
	<parameter type="float4x4" name="light_view_proj" array_size="6"/>

	<parameter type="samplerCUBE" name="lamp_sampler">
		<state name="filtering" value="bilinear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>
	<parameter type="sampler2D" name="shadow_map_x_pos_sampler">
		<state name="filtering" value="bilinear"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>
	<parameter type="sampler2D" name="shadow_map_x_neg_sampler">
		<state name="filtering" value="bilinear"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>
	<parameter type="sampler2D" name="shadow_map_y_pos_sampler">
		<state name="filtering" value="bilinear"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>
	<parameter type="sampler2D" name="shadow_map_y_neg_sampler">
		<state name="filtering" value="bilinear"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>
	<parameter type="sampler2D" name="shadow_map_z_pos_sampler">
		<state name="filtering" value="bilinear"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>
	<parameter type="sampler2D" name="shadow_map_z_neg_sampler">
		<state name="filtering" value="bilinear"/>
		<state name="address_u" value="border"/>
		<state name="address_v" value="border"/>
		<state name="border_clr" r="0" g="0" b="0" a="0"/>
	</parameter>

	<shader>
		<![CDATA[
void RenderSceneVS(float4 Position : POSITION,
					float3 Normal   : NORMAL,
					out float4 oPos : POSITION,
					out float3 oDiffuse : COLOR0,
					out float4 oLightWorldPos : TEXCOORD0,
					out float4 oLightProjPos[6] : TEXCOORD1)
{
	float4 world_pos = mul(Position, model);
	float3 world_normal = normalize(mul(Normal, (float3x3)model));

	oPos = mul(Position, model_view_proj);
	oLightWorldPos = mul(Position, obj_model_to_light_model);
	for (int i = 0; i < 6; ++ i)
	{
		oLightProjPos[i] = mul(world_pos, light_view_proj[i]);
	}
	
	world_pos /= world_pos.w;
	oDiffuse = dot(normalize(light_pos - world_pos.xyz), world_normal);
}

float4 RenderScenePS(float4 pos : POSITION, float3 diffuse : COLOR0,
				float4 LightWorldPos : TEXCOORD0,
				float4 LightProjPos[6] : TEXCOORD1) : COLOR 
{
	half3 ori_color = diffuse * texCUBE(lamp_sampler, LightWorldPos).rgb;
	LightWorldPos /= LightWorldPos.w;
	half dist = length(LightWorldPos.xyz);

	for (int i = 0; i < 6; ++ i)
	{
		LightProjPos[i].xy /= LightProjPos[i].w;
		LightProjPos[i].y = -LightProjPos[i].y;
		LightProjPos[i].xy = LightProjPos[i].xy / 2 + 0.5f;
	}
	
	half2 moments[6];
	moments[0] = tex2D(shadow_map_x_pos_sampler, LightProjPos[0].xy);
	moments[1] = tex2D(shadow_map_x_neg_sampler, LightProjPos[1].xy);
	moments[2] = tex2D(shadow_map_y_pos_sampler, LightProjPos[2].xy);
	moments[3] = tex2D(shadow_map_y_neg_sampler, LightProjPos[3].xy);
	moments[4] = tex2D(shadow_map_z_pos_sampler, LightProjPos[4].xy);
	moments[5] = tex2D(shadow_map_z_neg_sampler, LightProjPos[5].xy);

	half3 final_color = 0;
	for (int j = 0; j < 6; ++ j)
	{
		if (LightProjPos[j].z > 0)
		{
			half3 color = ori_color / (0.001f + 0.4 * moments[j].y);
			if (dist > moments[j].x + 0.1f)
			{
				// Variance shadow mapping
				half variance = moments[j].y - moments[j].x * moments[j].x;
				half m_d = moments[j].x - dist;
				half p_max = variance / (variance + m_d * m_d);

				color *= p_max;
			}
			
			final_color += color;
		}
	}

	return float4(final_color, 1.0);
}
		]]>
	</shader>

	<technique name="RenderScene">
		<pass name="p0">
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="RenderSceneVS()"/>
			<state name="pixel_shader" value="RenderScenePS()"/>
		</pass>
	</technique>
</effect>
