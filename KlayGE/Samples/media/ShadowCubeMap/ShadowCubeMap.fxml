<?xml version='1.0'?>

<effect>
	<include name="Lighting.fxml"/>

	<parameter type="float4x4" name="mvp"/>
	<parameter type="float4x4" name="model"/>
	<parameter type="float4x4" name="obj_model_to_light_model"/>

	<parameter type="float3" name="light_falloff"/>

	<shader>
		<![CDATA[
void GenShadowMapVS(float4 Position : POSITION,
						float3 Normal   : NORMAL,
						out float oDist : TEXCOORD0,
						out float4 oPos : SV_Position)
{
    oPos = mul(Position, mvp);
    float4 LightWorldPos = mul(Position, obj_model_to_light_model);
    LightWorldPos /= LightWorldPos.w;
	oDist = length(LightWorldPos.xyz);
}

float4 GenShadowMapPS(float dist : TEXCOORD0) : SV_Target
{
	float2 dxdy = float2(ddx(dist), ddy(dist));
	return float4(dist, dist * dist + 0.25f * dot(dxdy, dxdy), 0, 1);
}
		]]>
	</shader>

	<technique name="GenShadowMap">
		<pass name="p0">
			<state name="cull_mode" value="none"/>

			<state name="vertex_shader" value="GenShadowMapVS()"/>
			<state name="pixel_shader" value="GenShadowMapPS()"/>
		</pass>
	</technique>

	<parameter type="float" name="min_variance"/>
	<parameter type="float" name="bleeding_reduce"/>
	<parameter type="float3" name="light_pos"/>
	<parameter type="int" name="flipping"/>

	<parameter type="textureCUBE" name="light_projective_tex"/>
	<parameter type="textureCUBE" name="shadow_cube_tex"/>
	<parameter type="sampler" name="cube_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
void RenderSceneVS(float4 Position : POSITION,
					float3 Normal   : NORMAL,
					out float3 oLightWorldPos : TEXCOORD0,
					out float3 oLightWorldNormal : TEXCOORD1,
					out float4 oPos : SV_Position)
{
	oPos = mul(Position, mvp);
	oLightWorldPos = mul(Position, obj_model_to_light_model).xyz;
	oLightWorldNormal = mul(Normal, (float3x3)obj_model_to_light_model);
}

float linstep(float min, float max, float v)
{
	return clamp((v - min) / (max - min), 0, 1);
}

float4 RenderScenePS(float3 LightWorldPos : TEXCOORD0,
					float3 LightWorldNormal : TEXCOORD1) : SV_Target 
{
	float n_dot_l = dot(-LightWorldPos, LightWorldNormal) / sqrt(dot(LightWorldPos, LightWorldPos) * dot(LightWorldNormal, LightWorldNormal));

	float3 ori_color = n_dot_l * light_projective_tex.Sample(cube_sampler, LightWorldPos).rgb;
	float3 shadow_dir = float3(LightWorldPos.x, flipping * LightWorldPos.y, LightWorldPos.z);
	float2 moments = shadow_cube_tex.Sample(cube_sampler, shadow_dir).xy;
	
	float dist_sq = dot(LightWorldPos, LightWorldPos);
	float dist = sqrt(dist_sq);

	float p = (dist <= moments.x);
	// Variance shadow mapping
	float variance = moments.y - moments.x * moments.x;
	variance = max(variance, min_variance);
	float m_d = moments.x - dist;
	float p_max = variance / (variance + m_d * m_d);
	p_max = linstep(bleeding_reduce, 1, p_max);

	float atten = attenuation_term(0, LightWorldPos, light_falloff);
	atten *= max(p, p_max);
	
	return float4(ori_color * atten, 1.0);
}
		]]>
	</shader>

	<technique name="RenderScene">
		<pass name="p0">
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="RenderSceneVS()"/>
			<state name="pixel_shader" value="RenderScenePS()"/>
		</pass>
	</technique>


	<shader>
		<![CDATA[
void PointLightProxyVS(float4 pos : POSITION,
			out float3 oLightWorldPos : TEXCOORD0,
			out float4 oPos : SV_Position)
{
	oPos = mul(pos, mvp);
	oLightWorldPos = pos.xyz;
}

float4 PointLightProxyPS(float3 LightWorldPos : TEXCOORD0) : SV_Target
{
	float atten = attenuation_term(0, LightWorldPos, light_falloff);	
	return atten * light_projective_tex.Sample(cube_sampler, LightWorldPos);
}
		]]>
	</shader>

	<technique name="PointLightProxy">
		<pass name="p0">
			<state name="cull_mode" value="back"/>

			<state name="vertex_shader" value="PointLightProxyVS()"/>
			<state name="pixel_shader" value="PointLightProxyPS()"/>
		</pass>
	</technique>
</effect>
