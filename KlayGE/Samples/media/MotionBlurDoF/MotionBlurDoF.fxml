<?xml version='1.0'?>

<effect>
	<include name="Lighting.fxml"/>
	<include name="PostProcess.fxml"/>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="view"/>
		<parameter type="float4x4" name="proj"/>
		<parameter type="float3" name="light_in_world" x="2" y="2" z="-3"/>
		<parameter type="float" name="inv_depth_range"/>
	</cbuffer>

	<parameter type="float4x4" name="modelmat" semantic="WORLD"/>
	<parameter type="float4x4" name="last_modelmat"/>
	<parameter type="float4" name="color"/>

	<parameter type="float4" name="mid_value" value="0.5"/>

	<shader>
		<![CDATA[
float3 CalcColor(float3 pos_ws, float3 normal_ws, float3 clr)
{
	return clr * (0.02f + saturate(point_lighting(light_in_world, pos_ws, normal_ws))) - mid_value.rgb;
}

void ColorDepthInstancedVS(float4 pos			: POSITION,
					float3 normal		: NORMAL,

					float4 row0			: TEXCOORD1,
					float4 row1			: TEXCOORD2,
					float4 row2			: TEXCOORD3,
					float4 last_row0	: TEXCOORD4,
					float4 last_row1	: TEXCOORD5,
					float4 last_row2	: TEXCOORD6,
					float3 clr			: COLOR0,

					out float4 oClrDepth : TEXCOORD0,
					out float3 oPosWS : TEXCOORD1,
					out float3 oNormalWS : TEXCOORD2,
					out float4 oPos		: SV_Position)
{
	float4x4 model = { row0, row1, row2, float4(0, 0, 0, 1) };

	float4 pos_ws = mul(model, pos);
	normal = mul((float3x3)model, normal * 2 - 1);
	oPos = mul(mul(pos_ws, view), proj);
	oPosWS = pos_ws.xyz;
	oNormalWS = normal;
	oClrDepth.xyz = clr;
	oClrDepth.w = oPos.w * inv_depth_range;
}

void ColorDepthNonInstancedVS(float4 pos			: POSITION,
					float3 normal		: NORMAL,

					out float4 oClrDepth : TEXCOORD0,
					out float3 oPosWS : TEXCOORD1,
					out float3 oNormalWS : TEXCOORD2,
					out float4 oPos		: SV_Position)
{
	float4 pos_ws = mul(pos, modelmat);
	normal = mul(normal * 2 - 1, (float3x3)modelmat);
	oPos = mul(mul(pos_ws, view), proj);
	oPosWS = pos_ws.xyz;
	oNormalWS = normal;
	oClrDepth.xyz = color.rgb;
	oClrDepth.w = oPos.w * inv_depth_range;
}

float4 ColorDepthPS(float4 clr_depth : TEXCOORD0, float3 pos_ws : TEXCOORD1, float3 normal_ws : TEXCOORD2) : SV_Target
{
	return float4(CalcColor(pos_ws, normal_ws, clr_depth.xyz), clr_depth.w);
}
		]]>
	</shader>

	<technique name="ColorDepthInstanced">
		<pass name="p0">
			<state name="vertex_shader" value="ColorDepthInstancedVS()"/>
			<state name="pixel_shader" value="ColorDepthPS()"/>
		</pass>
	</technique>
	
	<technique name="ColorDepthNonInstanced">
		<pass name="p0">
			<state name="vertex_shader" value="ColorDepthNonInstancedVS()"/>
			<state name="pixel_shader" value="ColorDepthPS()"/>
		</pass>
	</technique>

	<parameter type="float4" name="clear_clr"/>
	<shader>
		<![CDATA[
float4 ClearFloatPS(float2 tex_coord0 : TEXCOORD0) : SV_Target
{
	return clear_clr - mid_value;
}
		]]>
	</shader>
	<technique name="ClearFloat">
		<pass name="p0">
			<state name="depth_enable" value="false"/>

			<state name="vertex_shader" value="PostProcessVS()"/>
			<state name="pixel_shader" value="ClearFloatPS()"/>
		</pass>
	</technique>

	<cbuffer name="per_frame">
		<parameter type="float4x4" name="prev_view"/>
		<parameter type="float4x4" name="prev_proj"/>
	</cbuffer>
	
	<shader>
		<![CDATA[
void CalcMotionVector(float4 pos_curr, float4 pos_prev, float3 normal_es,
					out float2 oVelocity, out float4 oPos)
{
	pos_curr = mul(pos_curr, view);
	pos_prev = mul(pos_prev, prev_view);
	float3 motion_vec = pos_curr.xyz - pos_prev.xyz;
	
	pos_curr = mul(pos_curr, proj);
	pos_prev = mul(pos_prev, prev_proj);
	oPos = dot(motion_vec, normal_es) > 0 ? pos_curr : pos_prev;
	
	pos_curr /= pos_curr.w;
	pos_prev /= pos_prev.w;
	oVelocity = (pos_curr.xy - pos_prev.xy) * 0.5f;
}

void MotionVectorInstancedVS(float4 pos			: POSITION,
					float3 normal		: NORMAL,

					float4 row0			: TEXCOORD1,
					float4 row1			: TEXCOORD2,
					float4 row2			: TEXCOORD3,
					float4 last_row0	: TEXCOORD4,
					float4 last_row1	: TEXCOORD5,
					float4 last_row2	: TEXCOORD6,
					float3 clr			: COLOR0,

					out float2 oVelocity : TEXCOORD0,
					out float4 oPos		: SV_Position)
{
	float4x4 model = { row0, row1, row2, float4(0, 0, 0, 1) };
	float4x4 last_model = { last_row0, last_row1, last_row2, float4(0, 0, 0, 1) };

	normal = mul(mul((float3x3)model, normal * 2 - 1), (float3x3)view);
	CalcMotionVector(mul(model, pos), mul(last_model, pos), normal, oVelocity, oPos);
}

void MotionVectorNonInstancedVS(float4 pos			: POSITION,
					float3 normal		: NORMAL,

					out float2 oVelocity : TEXCOORD0,
					out float4 oPos		: SV_Position)
{
	float4 pos_ws = mul(pos, modelmat);
	normal = mul(mul(normal * 2 - 1, (float3x3)modelmat), (float3x3)view);
	CalcMotionVector(mul(pos, modelmat), mul(pos, last_modelmat), normal, oVelocity, oPos);
}

float4 MotionVectorPS(float2 velocity : TEXCOORD0) : SV_Target
{
	return float4(velocity, 1, 1);
}
		]]>
	</shader>

	<technique name="MotionVectorInstanced">
		<pass name="p0">
			<state name="vertex_shader" value="MotionVectorInstancedVS()"/>
			<state name="pixel_shader" value="MotionVectorPS()"/>
		</pass>
	</technique>

	<technique name="MotionVectorNonInstanced">
		<pass name="p0">
			<state name="vertex_shader" value="MotionVectorNonInstancedVS()"/>
			<state name="pixel_shader" value="MotionVectorPS()"/>
		</pass>
	</technique>
</effect>
